var documenterSearchIndex = {"docs":
[{"location":"tutorials/tutorial_LODF_matrix/#LODF-matrix","page":"LODF matrix","title":"LODF matrix","text":"","category":"section"},{"location":"tutorials/tutorial_LODF_matrix/","page":"LODF matrix","title":"LODF matrix","text":"In this tutorial the methods for computing the Line Outage Distribution Factor (LODF) are presented. Before diving into this tutorial we encourage the user to load PowerNetworkMatrices, hit the ? key in the REPL terminal and look for the documentiont of the different LODF methods avialable.","category":"page"},{"location":"tutorials/tutorial_LODF_matrix/#Evaluation-of-the-LODF-matrix","page":"LODF matrix","title":"Evaluation of the LODF matrix","text":"","category":"section"},{"location":"tutorials/tutorial_LODF_matrix/","page":"LODF matrix","title":"LODF matrix","text":"As for the PTDF matrix, the LODF one can be evaluated according to two different approaches:","category":"page"},{"location":"tutorials/tutorial_LODF_matrix/","page":"LODF matrix","title":"LODF matrix","text":"Dense: considers functions for dense matrix multiplication and inversion\nKLU: considers functions for sparse matrix multiplication  and inversion (default)","category":"page"},{"location":"tutorials/tutorial_LODF_matrix/","page":"LODF matrix","title":"LODF matrix","text":"The evaluation of the LODF matrix can be easily performed starting from importing the system's data and then by simply calling the LODF method.","category":"page"},{"location":"tutorials/tutorial_LODF_matrix/","page":"LODF matrix","title":"LODF matrix","text":"using PowerNetworkMatrices\nusing PowerSystemCaseBuilder\n\nconst PNM = PowerNetworkMatrices\nconst PSB = PowerSystemCaseBuilder\n\n# get the System data\nsys = PSB.build_system(PSB.PSITestSystems, \"c_sys5\");\n\n# compute the LODF matrix\nlodf_1 = LODF(sys);\n\nlodf_2 = LODF(sys, linear_solver=\"Dense\");\n\n# show matrix\nget_lodf_data(lodf_1)","category":"page"},{"location":"tutorials/tutorial_LODF_matrix/","page":"LODF matrix","title":"LODF matrix","text":"Advanced users might be interested in computing the LODF matrix starting from either the branches and buses data (CASE 1), the IncidenceMatrix and PTDF structures (CASE 2), or by the information related to IncidenceMatrix, BA_Matrix and ABA_Matrix (CASE 3).","category":"page"},{"location":"tutorials/tutorial_LODF_matrix/","page":"LODF matrix","title":"LODF matrix","text":"# CASE 1\n\n# get the branches and buses data\nbranches = PNM.get_ac_branches(sys);\nbuses = PNM.get_buses(sys);\n\n# compute the LODF matrix from branches and buses data\nlodf_3 = LODF(branches, buses);\n\n# CASE 2\n\n# get the Incidence and PTDF matrix\na = IncidenceMatrix(sys);\nptdf = PTDF(sys);\n\n# compute LODF matrix with the two netwrok matrices\nlodf_4 = LODF(a, ptdf);\n\n# CASE 3\n\n# get the BA and ABA matrices (ABA matrix must include LU factorization \n# matrices)\nba = BA_Matrix(sys);\naba = ABA_Matrix(sys, factorize = true);\n\n# compute LODF matrix with the three netwrok matrices\nlodf_5 = LODF(a, aba, ba);","category":"page"},{"location":"tutorials/tutorial_LODF_matrix/","page":"LODF matrix","title":"LODF matrix","text":"NOTE: whenever the method LODF(sys::System) is used, the methods previously defined for CASE 1 and CASE 2 are executed in sequence. Therefore the method LODF(a::IncidenceMatrix, ptdf::PTDF) is the default one when evaluating the LODF matrix from the System data directly.","category":"page"},{"location":"tutorials/tutorial_LODF_matrix/#Available-methods-for-the-computation-of-the-LODF-matrix","page":"LODF matrix","title":"Available methods for the computation of the LODF matrix","text":"","category":"section"},{"location":"tutorials/tutorial_LODF_matrix/","page":"LODF matrix","title":"LODF matrix","text":"For those methods that either require the evaluation of the PTDF matrix, or that execute this evaluation internally, two different approaches casen be used.","category":"page"},{"location":"tutorials/tutorial_LODF_matrix/","page":"LODF matrix","title":"LODF matrix","text":"As for the PTDF matrix, here too the optional argument linear_solver can be specified with either KLU (for sparse matrix calculation) or Dense (for sparse matrix calculation).","category":"page"},{"location":"tutorials/tutorial_LODF_matrix/","page":"LODF matrix","title":"LODF matrix","text":"lodf_dense = LODF(sys, linear_solver=\"Dense\");","category":"page"},{"location":"tutorials/tutorial_LODF_matrix/","page":"LODF matrix","title":"LODF matrix","text":"NOTE (1): by default the \"KLU\" method is selected, which appeared to require significant less time and memory with respect to \"Dense\". Please note that wether the KLU or Dense method is used, the resultig LODF matrix is stored as a dense one.","category":"page"},{"location":"tutorials/tutorial_LODF_matrix/","page":"LODF matrix","title":"LODF matrix","text":"NOTE (2): for the moment, the method LODF(a::IncidenceMatrix, aba::ABA_Matrix, ba::BA_Matrix) will take KLU as linear_solver option.","category":"page"},{"location":"tutorials/tutorial_LODF_matrix/#\"Sparse\"-LODF-matrix","page":"LODF matrix","title":"\"Sparse\" LODF matrix","text":"","category":"section"},{"location":"tutorials/tutorial_LODF_matrix/","page":"LODF matrix","title":"LODF matrix","text":"The LODF matrix can be computed in a \"sparse\" fashion by defining the input argument tol. If this argument is defined, then elements of the LODF matrix whose absolute values are below the set threshold are dropped. In addition, the matrix will be stored as a sparse one of type SparseArrays.SparseMatrixCSC{Float64, Int64} type instead of Matrix{Float64} one.","category":"page"},{"location":"tutorials/tutorial_LODF_matrix/","page":"LODF matrix","title":"LODF matrix","text":"By considering an \"extreme\" value of 0.4 as tol, the LODF matrix can be computed as follows:","category":"page"},{"location":"tutorials/tutorial_LODF_matrix/","page":"LODF matrix","title":"LODF matrix","text":"lodf_sparse = LODF(sys, tol=0.4);\nget_lodf_data(lodf_sparse)","category":"page"},{"location":"tutorials/tutorial_LODF_matrix/","page":"LODF matrix","title":"LODF matrix","text":"Please consider that 0.4 was used for the purpose of this tutorial. In practice much smaller values are used (e.g., 1e-5).","category":"page"},{"location":"tutorials/tutorial_LODF_matrix/","page":"LODF matrix","title":"LODF matrix","text":"NOTE (1): elements whose absolute values exceed the tol argument are removed from the LODF matrix after this has been computed.","category":"page"},{"location":"tutorials/tutorial_LODF_matrix/","page":"LODF matrix","title":"LODF matrix","text":"NOTE (2): the tol argument does not refer to the \"sparsification\" tolerance of the PTDF matrix that is computed in the LODF method.","category":"page"},{"location":"tutorials/tutorial_LODF_matrix/","page":"LODF matrix","title":"LODF matrix","text":"NOTE (3): in case the method LODF(a::IncidenceMatrix, ptdf::PTDF) is considered, an error will be thrown whenever the tol argument in the PTDF structure used as input is different than 1e-15.","category":"page"},{"location":"tutorials/intro_page/#SIIP-Examples","page":"SIIP-Examples","title":"SIIP-Examples","text":"","category":"section"},{"location":"tutorials/intro_page/","page":"SIIP-Examples","title":"SIIP-Examples","text":"All the tutorials for the SIIP project are part of a separate repository SIIP-Examples.","category":"page"},{"location":"quick_start_guide/#Quick-Start-Guide","page":"Quick Start Guide","title":"Quick Start Guide","text":"","category":"section"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"note: Note\nPowerSystemCaseBuilder.jl is a helper library that makes it easier to reproduce examples in the documentation and tutorials. Normally you would pass your local files to create the system data instead of calling the function build_system. For more details visit PowerSystemCaseBuilder Documentation","category":"page"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"For more details about loading data and adding more dynamic components check the Creating a System with Dynamic devices section of the documentation in PowerSystems.jl.","category":"page"},{"location":"quick_start_guide/#Loading-data","page":"Quick Start Guide","title":"Loading data","text":"","category":"section"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"Data can be loaded from a pss/e raw file and a pss/e dyr file.","category":"page"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"using PowerNetworkMatrices\nusing PowerSystemCaseBuilder\n\nconst PNM = PowerNetworkMatrices\nconst PSB = PowerSystemCaseBuilder\n\nsys = PSB.build_system(PSB.PSITestSystems, \"c_sys5\")","category":"page"},{"location":"quick_start_guide/#Computation-of-the-PTDF-matrix","page":"Quick Start Guide","title":"Computation of the PTDF matrix","text":"","category":"section"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"Once system data is loaded, netwrok matrices can be evaluated. The following example shows how the PTDF matrix is computed.","category":"page"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"The function PTDF is called for the evaluation of the matrix and other data. These are stored in a structure of type PTDF.","category":"page"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"# evaluate the PTDF structure containing the matrix and other data.\nptdf_matrix = PNM.PTDF(sys);\n\n# show the PTDF matrix.\nPNM.get_data(ptdf_matrix)","category":"page"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"As it can be seen, PTDF matrix is stored such that the number of rows is equal to the number of buses, number of columns equal to the number of branches.","category":"page"},{"location":"tutorials/tutorial_Incidence_BA_ABA_matrices/#Incidence,-BA-and-ABA-matrices","page":"Incidence, BA and ABA matrices","title":"Incidence, BA and ABA matrices","text":"","category":"section"},{"location":"tutorials/tutorial_Incidence_BA_ABA_matrices/","page":"Incidence, BA and ABA matrices","title":"Incidence, BA and ABA matrices","text":"In this tutorial the IncidenceMatrix, BA_matrix and ABA_matrix are presented. The methods used for their evaluation, as well as how data is stored is shown in the following subsections.","category":"page"},{"location":"tutorials/tutorial_Incidence_BA_ABA_matrices/","page":"Incidence, BA and ABA matrices","title":"Incidence, BA and ABA matrices","text":"The matrices here presented are the building blocks for the compuation of the PTDF and LODF matrices.","category":"page"},{"location":"tutorials/tutorial_Incidence_BA_ABA_matrices/#IncidenceMatrix","page":"Incidence, BA and ABA matrices","title":"IncidenceMatrix","text":"","category":"section"},{"location":"tutorials/tutorial_Incidence_BA_ABA_matrices/","page":"Incidence, BA and ABA matrices","title":"Incidence, BA and ABA matrices","text":"The PowerNetworkMatrices package defines the structure IncidenceMatrix, which store the Incidence Matrix of the considered system as well as the most relevant network data.","category":"page"},{"location":"tutorials/tutorial_Incidence_BA_ABA_matrices/","page":"Incidence, BA and ABA matrices","title":"Incidence, BA and ABA matrices","text":"At first, the System data is loaded.","category":"page"},{"location":"tutorials/tutorial_Incidence_BA_ABA_matrices/","page":"Incidence, BA and ABA matrices","title":"Incidence, BA and ABA matrices","text":"using PowerNetworkMatrices\nusing PowerSystemCaseBuilder\n\nconst PNM = PowerNetworkMatrices\nconst PSB = PowerSystemCaseBuilder\n\nsys = PSB.build_system(PSB.PSITestSystems, \"c_sys5\");","category":"page"},{"location":"tutorials/tutorial_Incidence_BA_ABA_matrices/","page":"Incidence, BA and ABA matrices","title":"Incidence, BA and ABA matrices","text":"Then the Incidence Matrix is computed as follows:","category":"page"},{"location":"tutorials/tutorial_Incidence_BA_ABA_matrices/","page":"Incidence, BA and ABA matrices","title":"Incidence, BA and ABA matrices","text":"incidence_matrix = PNM.IncidenceMatrix(sys);","category":"page"},{"location":"tutorials/tutorial_Incidence_BA_ABA_matrices/","page":"Incidence, BA and ABA matrices","title":"Incidence, BA and ABA matrices","text":"The incidence_matrix variable is a structure of type IncidenceMatrix featuring the following fields:","category":"page"},{"location":"tutorials/tutorial_Incidence_BA_ABA_matrices/","page":"Incidence, BA and ABA matrices","title":"Incidence, BA and ABA matrices","text":"# axis names: row and column names.\n# row names: names of the branches\n# column names: names of the buses\nincidence_matrix.axes\n\n# data: Incidence Matrix\nincidence_matrix.data\n\n# lookup: dictionary linking the branches names and bus numbers with the row\n# and column numbers, respectively.\nincidence_matrix.axes\n\n# ref_bus_positions: set containing the positions of the reference buses.\n# this represents the positions where to add the column of zeros. Please refer to the\n# example in the BA matrix for more details.\nincidence_matrix.ref_bus_positions","category":"page"},{"location":"tutorials/tutorial_Incidence_BA_ABA_matrices/","page":"Incidence, BA and ABA matrices","title":"Incidence, BA and ABA matrices","text":"Please note that the matrix data can be easily access by using the following function:","category":"page"},{"location":"tutorials/tutorial_Incidence_BA_ABA_matrices/","page":"Incidence, BA and ABA matrices","title":"Incidence, BA and ABA matrices","text":"PNM.get_data(incidence_matrix)","category":"page"},{"location":"tutorials/tutorial_Incidence_BA_ABA_matrices/","page":"Incidence, BA and ABA matrices","title":"Incidence, BA and ABA matrices","text":"Note that the number of columns is lower than the actual number of system buses since the column related to the reference bus is discarded.","category":"page"},{"location":"tutorials/tutorial_Incidence_BA_ABA_matrices/#BA_Matrix","page":"Incidence, BA and ABA matrices","title":"BA_Matrix","text":"","category":"section"},{"location":"tutorials/tutorial_Incidence_BA_ABA_matrices/","page":"Incidence, BA and ABA matrices","title":"Incidence, BA and ABA matrices","text":"The BA_Matrix is a structure containing the matrix coming from the product of the IncidenceMatrix and the diagonal matrix containing the impedence of the system's branches (\"B\" matrix).","category":"page"},{"location":"tutorials/tutorial_Incidence_BA_ABA_matrices/","page":"Incidence, BA and ABA matrices","title":"Incidence, BA and ABA matrices","text":"The BA_Matrix is computed as follows:","category":"page"},{"location":"tutorials/tutorial_Incidence_BA_ABA_matrices/","page":"Incidence, BA and ABA matrices","title":"Incidence, BA and ABA matrices","text":"ba_matrix = PNM.BA_Matrix(sys);","category":"page"},{"location":"tutorials/tutorial_Incidence_BA_ABA_matrices/","page":"Incidence, BA and ABA matrices","title":"Incidence, BA and ABA matrices","text":"As for the IncidenceMatrix, here too the BA_Matrix structure feature the same fields.","category":"page"},{"location":"tutorials/tutorial_Incidence_BA_ABA_matrices/","page":"Incidence, BA and ABA matrices","title":"Incidence, BA and ABA matrices","text":"An example related to accessing the matrix data is now provided:","category":"page"},{"location":"tutorials/tutorial_Incidence_BA_ABA_matrices/","page":"Incidence, BA and ABA matrices","title":"Incidence, BA and ABA matrices","text":"# access data by explicitly calling the field \"data\"\nba_matrix.data\n\n# or by using the \"get_data\" function\nPNM.get_data(ba_matrix)","category":"page"},{"location":"tutorials/tutorial_Incidence_BA_ABA_matrices/","page":"Incidence, BA and ABA matrices","title":"Incidence, BA and ABA matrices","text":"Note that the number of columns is lower than the actual number of system buses since the column related to the reference bus is discarded.","category":"page"},{"location":"tutorials/tutorial_Incidence_BA_ABA_matrices/","page":"Incidence, BA and ABA matrices","title":"Incidence, BA and ABA matrices","text":"To add the column of zeros related to the reference bus, it is necessary to use the information contained in the ref_bus_positions field.","category":"page"},{"location":"tutorials/tutorial_Incidence_BA_ABA_matrices/","page":"Incidence, BA and ABA matrices","title":"Incidence, BA and ABA matrices","text":"new_ba_matrix = hcat(\n    ba_matrix.data[:,1:collect(ba_matrix.ref_bus_positions)[1]-1],\n    zeros(size(ba_matrix, 1), 1),\n    ba_matrix.data[:, collect(ba_matrix.ref_bus_positions)[1]:end]\n    )","category":"page"},{"location":"tutorials/tutorial_Incidence_BA_ABA_matrices/","page":"Incidence, BA and ABA matrices","title":"Incidence, BA and ABA matrices","text":"However, trying to change the data field with a matrix of different dimension will result in an error.","category":"page"},{"location":"tutorials/tutorial_Incidence_BA_ABA_matrices/","page":"Incidence, BA and ABA matrices","title":"Incidence, BA and ABA matrices","text":"ba_matrix.data = hcat(\n    ba_matrix.data[:,1:collect(ba_matrix.ref_bus_positions)[1]-1],\n    zeros(size(ba_matrix, 1), 1),\n    ba_matrix.data[:, collect(ba_matrix.ref_bus_positions)[1]:end]\n    )","category":"page"},{"location":"tutorials/tutorial_Incidence_BA_ABA_matrices/#ABA_Matrix","page":"Incidence, BA and ABA matrices","title":"ABA_Matrix","text":"","category":"section"},{"location":"tutorials/tutorial_Incidence_BA_ABA_matrices/","page":"Incidence, BA and ABA matrices","title":"Incidence, BA and ABA matrices","text":"The ABA_Matrix is a structure containing the matrix coming from the product of the IncidenceMatrix and the BA_Matrix. It features the same fields as the IncidenceMatrix and the BA_Matrix, plus the K one. The field ABA_Matrix.K stores the LU factorization matrices (using the methods contained in the package KLU).","category":"page"},{"location":"tutorials/tutorial_Incidence_BA_ABA_matrices/","page":"Incidence, BA and ABA matrices","title":"Incidence, BA and ABA matrices","text":"To evaluate the ABA_Matrix, the following command is sufficient:","category":"page"},{"location":"tutorials/tutorial_Incidence_BA_ABA_matrices/","page":"Incidence, BA and ABA matrices","title":"Incidence, BA and ABA matrices","text":"aba_matrix = ABA_Matrix(sys);","category":"page"},{"location":"tutorials/tutorial_Incidence_BA_ABA_matrices/","page":"Incidence, BA and ABA matrices","title":"Incidence, BA and ABA matrices","text":"By default the LU factorization matrices are not computed, leaving the K field empty. In case these are wanted, the keyword factorize must be true.","category":"page"},{"location":"tutorials/tutorial_Incidence_BA_ABA_matrices/","page":"Incidence, BA and ABA matrices","title":"Incidence, BA and ABA matrices","text":"aba_matrix_with_LU = ABA_Matrix(sys; factorize=true);\n\naba_matrix_with_LU.K","category":"page"},{"location":"tutorials/tutorial_Incidence_BA_ABA_matrices/","page":"Incidence, BA and ABA matrices","title":"Incidence, BA and ABA matrices","text":"If the ABA_Matrix is already computed but the LU factorization was not performed, this can be done by considering the following command:","category":"page"},{"location":"tutorials/tutorial_Incidence_BA_ABA_matrices/","page":"Incidence, BA and ABA matrices","title":"Incidence, BA and ABA matrices","text":"aba_matrix.K\naba_matrix = factorize(aba_matrix);\naba_matrix.K","category":"page"},{"location":"tutorials/tutorial_Incidence_BA_ABA_matrices/","page":"Incidence, BA and ABA matrices","title":"Incidence, BA and ABA matrices","text":"The following command can then be used to check if the ABA_Matrix contains the LU factorization matrices:","category":"page"},{"location":"tutorials/tutorial_Incidence_BA_ABA_matrices/","page":"Incidence, BA and ABA matrices","title":"Incidence, BA and ABA matrices","text":"is_factorized(aba_matrix)","category":"page"},{"location":"tutorials/tutorial_VirtualPTDF_matrix/#VirtualPTDF","page":"VirtualPTDF matrix","title":"VirtualPTDF","text":"","category":"section"},{"location":"tutorials/tutorial_VirtualPTDF_matrix/","page":"VirtualPTDF matrix","title":"VirtualPTDF matrix","text":"Contrary to the traditional PTDF matrix, the VirtualPTDF is a stucture contatining rows of the original matrix, related to specific system branches. The different rows of the PTDF matrix are cached in the VirtualPTDF structure as they are evaluated. This allows to keep just the portion of the original matrix which is of interest to the user, avoiding the unecessary computation of the whole matrix.","category":"page"},{"location":"tutorials/tutorial_VirtualPTDF_matrix/","page":"VirtualPTDF matrix","title":"VirtualPTDF matrix","text":"Refer to the different arguments of the VirtualPTDF methods by looking at the \"Public API Reference\" page.","category":"page"},{"location":"tutorials/tutorial_VirtualPTDF_matrix/#How-the-VirtualPTDF-works","page":"VirtualPTDF matrix","title":"How the VirtualPTDF works","text":"","category":"section"},{"location":"tutorials/tutorial_VirtualPTDF_matrix/","page":"VirtualPTDF matrix","title":"VirtualPTDF matrix","text":"The VirtualPTDF is a structure containing everything needed to compute any row of the PTDF matrix and store it. To do so, the VirtualPTDF must store the BA matrix (coming from the BA_Matrix struct) and the inverse of the ABA matrix (coming from ABA_MAtrix struct). In particular, KLU is used to get the LU factorization matrices of the ABA matrix and these ones are stored, avoid the inversion.","category":"page"},{"location":"tutorials/tutorial_VirtualPTDF_matrix/","page":"VirtualPTDF matrix","title":"VirtualPTDF matrix","text":"Once the VirtualPTDF is initialized, each row of the PTDF matrix can be evaluated separately. The algorithmic procedure is the following:","category":"page"},{"location":"tutorials/tutorial_VirtualPTDF_matrix/","page":"VirtualPTDF matrix","title":"VirtualPTDF matrix","text":"Define the VirtualPTDF structure\nCall any element of the matrix to define and store the relative row as well as showing the selected element","category":"page"},{"location":"tutorials/tutorial_VirtualPTDF_matrix/","page":"VirtualPTDF matrix","title":"VirtualPTDF matrix","text":"Regarding point 2, if the row has been stored previosly then the desired element is just loaded from the cache and shown.","category":"page"},{"location":"tutorials/tutorial_VirtualPTDF_matrix/","page":"VirtualPTDF matrix","title":"VirtualPTDF matrix","text":"The flowchart below shows how the VirtualPTDF is structured and how it works. Examples will be presented in the following sections.","category":"page"},{"location":"tutorials/tutorial_VirtualPTDF_matrix/","page":"VirtualPTDF matrix","title":"VirtualPTDF matrix","text":"<img src=\"../../assets/VirtualPTDF_scheme.png\"/>","category":"page"},{"location":"tutorials/tutorial_VirtualPTDF_matrix/#Initialize-VirtualPTDF-and-compute/access-row/element","page":"VirtualPTDF matrix","title":"Initialize VirtualPTDF and compute/access row/element","text":"","category":"section"},{"location":"tutorials/tutorial_VirtualPTDF_matrix/","page":"VirtualPTDF matrix","title":"VirtualPTDF matrix","text":"As for the PTDF matrix, at first the System data must be loaded. The \"RTS-GMLC\" systems is considered as example:","category":"page"},{"location":"tutorials/tutorial_VirtualPTDF_matrix/","page":"VirtualPTDF matrix","title":"VirtualPTDF matrix","text":"using PowerNetworkMatrices\nusing PowerSystemCaseBuilder\n\nconst PNM = PowerNetworkMatrices;\nconst PSB = PowerSystemCaseBuilder;\n\nsys = PSB.build_system(PSB.PSISystems, \"RTS_GMLC_DA_sys\");","category":"page"},{"location":"tutorials/tutorial_VirtualPTDF_matrix/","page":"VirtualPTDF matrix","title":"VirtualPTDF matrix","text":"At this point the VirtualPTDF is initialized with the following simple command:","category":"page"},{"location":"tutorials/tutorial_VirtualPTDF_matrix/","page":"VirtualPTDF matrix","title":"VirtualPTDF matrix","text":"v_ptdf = VirtualPTDF(sys);","category":"page"},{"location":"tutorials/tutorial_VirtualPTDF_matrix/","page":"VirtualPTDF matrix","title":"VirtualPTDF matrix","text":"Now, an element of the matrix can be computed by calling the branch name and bus number:","category":"page"},{"location":"tutorials/tutorial_VirtualPTDF_matrix/","page":"VirtualPTDF matrix","title":"VirtualPTDF matrix","text":"el_C31_2_105 = v_ptdf[\"C31-2\", 105]","category":"page"},{"location":"tutorials/tutorial_VirtualPTDF_matrix/","page":"VirtualPTDF matrix","title":"VirtualPTDF matrix","text":"Alternatively, the number of the branch and bus (corresponding to the number of the PTDF row and column) can be used. In this case the row and column numbers are mapped by the dictonaries contained in the lookup field. ","category":"page"},{"location":"tutorials/tutorial_VirtualPTDF_matrix/","page":"VirtualPTDF matrix","title":"VirtualPTDF matrix","text":"row_number = v_ptdf.lookup[1][\"C31-2\"]\ncol_number = v_ptdf.lookup[2][105]\nel_C31_2_105_bis = v_ptdf[row_number, col_number]","category":"page"},{"location":"tutorials/tutorial_VirtualPTDF_matrix/","page":"VirtualPTDF matrix","title":"VirtualPTDF matrix","text":"NOTE: this example was made for the sake of completeness and considering the actual branch name and bus number is reccomended.","category":"page"},{"location":"tutorials/tutorial_VirtualPTDF_matrix/","page":"VirtualPTDF matrix","title":"VirtualPTDF matrix","text":"As previosly mentioned, in order to evaluate a single element of the VirtualPTDF, the entire row related to the selected branch must be considered. For this reason it is cached in the VirtualPTDF structure for later calls. This is evident by looking at the following example:","category":"page"},{"location":"tutorials/tutorial_VirtualPTDF_matrix/","page":"VirtualPTDF matrix","title":"VirtualPTDF matrix","text":"sys_2k = PSB.build_system(PSB.PSYTestSystems, \"tamu_ACTIVSg2000_sys\");\n\nv_ptdf_2k = VirtualPTDF(sys_2k);\n\n# evaluate PTDF row related to branch \"ODESSA 2 0  -1001-ODESSA 3 0  -1064-i_1\"\n@time v_ptdf_2k[\"ODESSA 2 0  -1001-ODESSA 3 0  -1064-i_1\", 8155]\n\n# call same element after the row has been stored\n@time v_ptdf_2k[\"ODESSA 2 0  -1001-ODESSA 3 0  -1064-i_1\", 8155]","category":"page"},{"location":"tutorials/tutorial_VirtualPTDF_matrix/#VirtualPTDF-with-distributed-slack-bus","page":"VirtualPTDF matrix","title":"VirtualPTDF with distributed slack bus","text":"","category":"section"},{"location":"tutorials/tutorial_VirtualPTDF_matrix/","page":"VirtualPTDF matrix","title":"VirtualPTDF matrix","text":"As for the PTDF matrix, here too each row can be evaluated considering distibuted slack buses. A vector of type Vector{Float64} is defined, specifying the weights for each bus of the system. ","category":"page"},{"location":"tutorials/tutorial_VirtualPTDF_matrix/","page":"VirtualPTDF matrix","title":"VirtualPTDF matrix","text":"# smaller system for the next examples\nsys_2 = PSB.build_system(PSB.PSITestSystems, \"c_sys5\");\n\n# consider equal distribution accross each bus for this example\nbuscount = length(PNM.get_buses(sys_2));\ndist_slack = 1 / buscount * ones(buscount);\ndist_slack_array = dist_slack / sum(dist_slack);","category":"page"},{"location":"tutorials/tutorial_VirtualPTDF_matrix/","page":"VirtualPTDF matrix","title":"VirtualPTDF matrix","text":"Now initialize the VirtualPTDF by defining the dist_slack field with the vector of weights previosly computed:","category":"page"},{"location":"tutorials/tutorial_VirtualPTDF_matrix/","page":"VirtualPTDF matrix","title":"VirtualPTDF matrix","text":"v_ptdf_distr = VirtualPTDF(sys_2, dist_slack=dist_slack_array);\nv_ptdf_orig = VirtualPTDF(sys_2);","category":"page"},{"location":"tutorials/tutorial_VirtualPTDF_matrix/","page":"VirtualPTDF matrix","title":"VirtualPTDF matrix","text":"Now check the difference with the same row related to the branch \"1\" evaluated without considering distributed slack bus.","category":"page"},{"location":"tutorials/tutorial_VirtualPTDF_matrix/","page":"VirtualPTDF matrix","title":"VirtualPTDF matrix","text":"row_distr = [v_ptdf_distr[\"1\", j] for j in v_ptdf_distr.axes[2]]\nrow_original = [v_ptdf_orig[\"1\", j] for j in v_ptdf_orig.axes[2]]","category":"page"},{"location":"tutorials/tutorial_VirtualPTDF_matrix/#\"Sparse\"-VirtualPTDF","page":"VirtualPTDF matrix","title":"\"Sparse\" VirtualPTDF","text":"","category":"section"},{"location":"tutorials/tutorial_VirtualPTDF_matrix/","page":"VirtualPTDF matrix","title":"VirtualPTDF matrix","text":"Sparsification of each row can be achieved in the same fashion as for the PTDF matrix, by removing those elements whose absolute values is below a certain threshold.","category":"page"},{"location":"tutorials/tutorial_VirtualPTDF_matrix/","page":"VirtualPTDF matrix","title":"VirtualPTDF matrix","text":"As for the example show for the PTDF matrix, here to a very high values of 0.2 is considered for the tol field. Again, this value is considered just for the sake of this example.","category":"page"},{"location":"tutorials/tutorial_VirtualPTDF_matrix/","page":"VirtualPTDF matrix","title":"VirtualPTDF matrix","text":"v_ptdf_dense = VirtualPTDF(sys_2);\nv_ptdf_sparse = VirtualPTDF(sys_2, tol=0.2);","category":"page"},{"location":"tutorials/tutorial_VirtualPTDF_matrix/","page":"VirtualPTDF matrix","title":"VirtualPTDF matrix","text":"Let's now evaluate the same row as before and compare the results:","category":"page"},{"location":"tutorials/tutorial_VirtualPTDF_matrix/","page":"VirtualPTDF matrix","title":"VirtualPTDF matrix","text":"original_row = [v_ptdf_dense[\"1\", j] for j in v_ptdf_dense.axes[2]]\nsparse_row = [v_ptdf_sparse[\"1\", j] for j in v_ptdf_sparse.axes[2]]","category":"page"},{"location":"tutorials/tutorial_PTDF_matrix/#PTDF-matrix","page":"PTDF matrix","title":"PTDF matrix","text":"","category":"section"},{"location":"tutorials/tutorial_PTDF_matrix/","page":"PTDF matrix","title":"PTDF matrix","text":"In this tutorial the methods for computing the Power Transfer Distribution Factors (PTDF) are presented. Before diving into this tutorial we encourage the user to load PowerNetworkMatrices, hit the ? key in the REPL terminal and look for the documention of the different PTDF methods available.","category":"page"},{"location":"tutorials/tutorial_PTDF_matrix/#Evaluation-of-the-PTDF-matrix","page":"PTDF matrix","title":"Evaluation of the PTDF matrix","text":"","category":"section"},{"location":"tutorials/tutorial_PTDF_matrix/","page":"PTDF matrix","title":"PTDF matrix","text":"The PTDF matrix can be evaluated according to two different approaches:","category":"page"},{"location":"tutorials/tutorial_PTDF_matrix/","page":"PTDF matrix","title":"PTDF matrix","text":"Dense: considers functions for dense matrix multiplication and inversion\nKLU: considers functions for sparse matrix multiplication and inversion (default)","category":"page"},{"location":"tutorials/tutorial_PTDF_matrix/","page":"PTDF matrix","title":"PTDF matrix","text":"The evaluation of the PTDF matrix can be easily performed starting from importing the system's data and then by simply calling the PTDF method.","category":"page"},{"location":"tutorials/tutorial_PTDF_matrix/","page":"PTDF matrix","title":"PTDF matrix","text":"using PowerNetworkMatrices\nusing PowerSystemCaseBuilder\n\nconst PNM = PowerNetworkMatrices\nconst PSB = PowerSystemCaseBuilder\n\nsys = PSB.build_system(PSB.PSITestSystems, \"c_sys5\");\n\nptdf_1 = PTDF(sys);\n\nget_ptdf_data(ptdf_1)","category":"page"},{"location":"tutorials/tutorial_PTDF_matrix/","page":"PTDF matrix","title":"PTDF matrix","text":"Advanced users might be interested in computing the PTDF matrix starting from either the data contained in the IncidenceMatrix and BA_matrix structures, or by the information related to the branches and buses of the system.","category":"page"},{"location":"tutorials/tutorial_PTDF_matrix/","page":"PTDF matrix","title":"PTDF matrix","text":"# evaluate the BA_matrix and Incidence_Matrix\nba_matrix = BA_Matrix(sys);\na_matrix = IncidenceMatrix(sys);\n\n# get the PTDF matrix starting from the values of the \n# previosly cumputed matrices\nptdf_2 = PTDF(a_matrix, ba_matrix);\nget_ptdf_data(ptdf_2)\n\n# get the buses and branches of the system\nbranches = PNM.get_ac_branches(sys);\nbuses = PNM.get_buses(sys);\nptdf_3 = PTDF(branches, buses);\nget_ptdf_data(ptdf_3)","category":"page"},{"location":"tutorials/tutorial_PTDF_matrix/","page":"PTDF matrix","title":"PTDF matrix","text":"NOTE: both the get_ac_branches and get_ac_branches functions are not exported by the PowerNetworkMatrices package, and therefore require the package name to be called as a prefix. However, they are shown here just for the sake of making an example.","category":"page"},{"location":"tutorials/tutorial_PTDF_matrix/#Available-methods-for-the-computation-of-the-PTDF-matrix","page":"PTDF matrix","title":"Available methods for the computation of the PTDF matrix","text":"","category":"section"},{"location":"tutorials/tutorial_PTDF_matrix/","page":"PTDF matrix","title":"PTDF matrix","text":"As previously mentioned, the PTDF matrix can be evaluated considering different approaches. The method can be selected by specifying the field linear_solver in the PTDF function.","category":"page"},{"location":"tutorials/tutorial_PTDF_matrix/","page":"PTDF matrix","title":"PTDF matrix","text":"ptdf_dense = PTDF(sys, linear_solver=\"Dense\");\nget_ptdf_data(ptdf_dense)\n\nptdf_klu = PTDF(sys, linear_solver=\"KLU\");\nget_ptdf_data(ptdf_klu)","category":"page"},{"location":"tutorials/tutorial_PTDF_matrix/","page":"PTDF matrix","title":"PTDF matrix","text":"By default the \"KLU\" method is selected, which appeared to require significant less time and memory with respect to \"Dense\". Please note that either the KLU or Dense method is used, the resulting PTDF matrix is stored as a dense one.","category":"page"},{"location":"tutorials/tutorial_PTDF_matrix/#Evaluating-the-PTDF-matrix-considering-distributed-slack-bus","page":"PTDF matrix","title":"Evaluating the PTDF matrix considering distributed slack bus","text":"","category":"section"},{"location":"tutorials/tutorial_PTDF_matrix/","page":"PTDF matrix","title":"PTDF matrix","text":"Whenever needed, the PTDF matrix can be computed with a distributed slack bus. To do so, a vector of type Vector{Float64} needs to be defined, specifying the weights for each bus of the system. These weights identify how the load on the slakc bus is redistributed accross the system.","category":"page"},{"location":"tutorials/tutorial_PTDF_matrix/","page":"PTDF matrix","title":"PTDF matrix","text":"# consider equal distribution accross each bus for this example\nbuscount = length(PNM.get_buses(sys));\ndist_slack = 1 / buscount * ones(buscount);\ndist_slack_array = dist_slack / sum(dist_slack);","category":"page"},{"location":"tutorials/tutorial_PTDF_matrix/","page":"PTDF matrix","title":"PTDF matrix","text":"Once the vector of the weights is defined, the PTDF matrix can be computed by defining the input argument dist_slack (empty array Float64[] by default):","category":"page"},{"location":"tutorials/tutorial_PTDF_matrix/","page":"PTDF matrix","title":"PTDF matrix","text":"ptdf_distr = PTDF(sys, dist_slack=dist_slack_array);","category":"page"},{"location":"tutorials/tutorial_PTDF_matrix/","page":"PTDF matrix","title":"PTDF matrix","text":"The difference between a the matrix computed with and without the dist_slack field defined can be seen as follows:","category":"page"},{"location":"tutorials/tutorial_PTDF_matrix/","page":"PTDF matrix","title":"PTDF matrix","text":"# with no distributed slack bus\nget_ptdf_data(ptdf_klu)\n# with distributed slack bus\nget_ptdf_data(ptdf_distr)","category":"page"},{"location":"tutorials/tutorial_PTDF_matrix/#\"Sparse\"-PTDF-matrix","page":"PTDF matrix","title":"\"Sparse\" PTDF matrix","text":"","category":"section"},{"location":"tutorials/tutorial_PTDF_matrix/","page":"PTDF matrix","title":"PTDF matrix","text":"The PTFD matrix can be computed in a \"sparse\" fashion by defining the input argument tol. If this argument is defined, then elements of the PTDF matrix whose absolute values are below the set threshold are dropped. In addition, the matrix will be stored as a sparse one of type SparseArrays.SparseMatrixCSC{Float64, Int64} instead of Matrix{Float64}.","category":"page"},{"location":"tutorials/tutorial_PTDF_matrix/","page":"PTDF matrix","title":"PTDF matrix","text":"By considering an \"extreme\" value of 0.2 as tol, the PTDF matrix can be computed as follows:","category":"page"},{"location":"tutorials/tutorial_PTDF_matrix/","page":"PTDF matrix","title":"PTDF matrix","text":"ptdf_sparse = PTDF(sys, tol=0.2);\nget_ptdf_data(ptdf_sparse)","category":"page"},{"location":"tutorials/tutorial_PTDF_matrix/","page":"PTDF matrix","title":"PTDF matrix","text":"NOTE: 0.2 was used for the purpose of this tutorial. In practice much smaller values are used (e.g., 1e-5).","category":"page"},{"location":"api/internal/#Internal-API","page":"Internal API Reference","title":"Internal API","text":"","category":"section"},{"location":"api/internal/","page":"Internal API Reference","title":"Internal API Reference","text":"Modules = [PowerNetworkMatrices]\nPublic = false","category":"page"},{"location":"api/internal/#PowerNetworkMatrices.Adjacency","page":"Internal API Reference","title":"PowerNetworkMatrices.Adjacency","text":"Nodal incidence matrix (Adjacency) is an N x N matrix describing a power system with N buses. It represents the directed connectivity of the buses in a power system.\n\nThe Adjacency Struct is indexed using the Bus Numbers, no need for them to be sequential\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerNetworkMatrices.Adjacency-Tuple{Any, Any}","page":"Internal API Reference","title":"PowerNetworkMatrices.Adjacency","text":"Adjacency(branches, nodes; check_connectivity, kwargs...)\n\n\nBuilds a Adjacency from a collection of buses and branches. The return is an N x N Adjacency Array indexed with the bus numbers.\n\nKeyword arguments\n\ncheck_connectivity::Bool: Checks connectivity of the network using Goderya's algorithm\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.Adjacency-Tuple{PowerSystems.System}","page":"Internal API Reference","title":"PowerNetworkMatrices.Adjacency","text":"Adjacency(sys; check_connectivity, kwargs...)\n\n\nBuilds a Adjacency from the system. The return is an N x N Adjacency Array indexed with the bus numbers.\n\nKeyword arguments\n\ncheck_connectivity::Bool: Checks connectivity of the network using Goderya's algorithm\nconnectivity_method::Function = goderya_connectivity: method (goderya_connectivity or dfs_connectivity) for connectivity validation\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.PowerNetworkMatrix","page":"Internal API Reference","title":"PowerNetworkMatrices.PowerNetworkMatrix","text":"Type PowerNetworkMatrix gathers all the different types of Matrices considered in this package \n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerNetworkMatrices.PowerNetworkMatrixKey","page":"Internal API Reference","title":"PowerNetworkMatrices.PowerNetworkMatrixKey","text":"Structure to store the keys of a power network matrix\n\nArguments\n\nI<:Tuple:       turple containing the indices of the matrix\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerNetworkMatrices.PowerNetworkMatrixKeys","page":"Internal API Reference","title":"PowerNetworkMatrices.PowerNetworkMatrixKeys","text":"Structure to store the keys of a power network matrix\n\nArguments\n\nproduct_iter::Base.Iterators.ProductIterator{T} where T <: Tuple:       iterator of the indices of the network power matrix\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerNetworkMatrices.RowCache","page":"Internal API Reference","title":"PowerNetworkMatrices.RowCache","text":"Structure used for saving the rows of the Virtual PTDF and LODF matrix.\n\nArguments\n\ntemp_cache::Dict{Int, Union{Vector{Float64}, SparseArrays.SparseVector{Float64}}}:       Dictionay saving the row of the PTDF/LODF matrix\npersistent_cache_keys::Set{Int}:       Set listing the rows to keep in temp_cache\nmax_cache_size::Int       Defines the maximum allowed cache size (rows*row_size)\nmax_num_keys::Int       Defines the maximum number of keys saved (rows of the matrix)\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerNetworkMatrices.RowCache-Tuple{Int64, Set{Int64}, Any}","page":"Internal API Reference","title":"PowerNetworkMatrices.RowCache","text":"RowCache(max_cache_size, persistent_rows, row_size)\n\n\nStructure used for saving the rows of the Virtual PTDF and LODF matrix.\n\nArguments\n\nmax_cache_size::Int       Defines the maximum allowed cache size (rows*row_size).\npersistent_rows::Set{Int}:       Set listing the rows to keep in temp_cache.\nrow_size       Defines the size of the single row to store.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Base.eachindex-Tuple{VirtualLODF}","page":"Internal API Reference","title":"Base.eachindex","text":"eachindex(vlodf)\n\n\nGives the cartesian indexes of the LODF matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Base.eachindex-Tuple{VirtualPTDF}","page":"Internal API Reference","title":"Base.eachindex","text":"eachindex(vptdf)\n\n\nGives the cartesian indexes of the PTDF matrix (same as the BA one).\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Base.empty!-Tuple{PowerNetworkMatrices.RowCache}","page":"Internal API Reference","title":"Base.empty!","text":"empty!(cache)\n\n\nErases the cache.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Base.getindex-Tuple{PowerNetworkMatrices.RowCache, Int64}","page":"Internal API Reference","title":"Base.getindex","text":"getindex(cache, key)\n\n\nGets the row of the stored matrix in cache.\n\nArguments\n\ncache::RowCache:       cache where the row vector is going to be saved\nkey::Int:       row number (corresponding to the enumerated branch index) related to the row vector.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Base.getindex-Tuple{VirtualLODF, Any, Any}","page":"Internal API Reference","title":"Base.getindex","text":"getindex(vlodf, row, column)\n\n\nGets the value of the element of the LODF matrix given the row and column indices corresponding to the selected and outage branch respectively. If column is a Colon then the entire row is returned.\n\nArguments\n\nvlodf::VirtualLODF:       VirtualLODF struct where to evaluate and store the row values.\nrow:       selected line name\ncolumn:       outage line name. If Colon then get the values of the whole row.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Base.getindex-Tuple{VirtualPTDF, Any, Any}","page":"Internal API Reference","title":"Base.getindex","text":"getindex(vptdf, row, column)\n\n\nGets the value of the element of the PTDF matrix given the row and column indices corresponding to the branch and buses one respectively. If column is a Colon then the entire row is returned.\n\nArguments\n\nvptdf::VirtualPTDF:       VirtualPTDF struct where to evaluate and store the row values.\nrow:       Branch index.\ncolumn:       Bus index. If Colon then get the values of the whole row.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Base.haskey-Tuple{PowerNetworkMatrices.RowCache, Int64}","page":"Internal API Reference","title":"Base.haskey","text":"haskey(cache, key)\n\n\nChecks if key is present as a key of the dictionary in cache\n\nArguments\n\ncache::RowCache:       cache where data is stored.\nkey::Int:       row number (corresponds to the enumerated branch index).\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Base.isempty-Tuple{PowerNetworkMatrices.RowCache}","page":"Internal API Reference","title":"Base.isempty","text":"isempty(cache)\n\n\nCheck if cache is empty.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Base.isempty-Tuple{VirtualLODF}","page":"Internal API Reference","title":"Base.isempty","text":"isempty(vlodf)\n\n\nChecks if the any of the fields of VirtualLODF is empty.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Base.isempty-Tuple{VirtualPTDF}","page":"Internal API Reference","title":"Base.isempty","text":"isempty(vptdf)\n\n\nChecks if the any of the fields of VirtualPTDF is empty.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Base.length-Tuple{PowerNetworkMatrices.RowCache}","page":"Internal API Reference","title":"Base.length","text":"length(cache)\n\n\nShows the number of rows stored in cache\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Base.setindex!-Tuple{VirtualLODF, Any, CartesianIndex}","page":"Internal API Reference","title":"Base.setindex!","text":"setindex!(_, _, _)\n\n\n!!! STILL TO IMPLEMENT !!!\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Base.setindex!-Tuple{VirtualLODF, Any, Vararg{Any}}","page":"Internal API Reference","title":"Base.setindex!","text":"setindex!(_, _, idx)\n\n\n!!! STILL TO IMPLEMENT !!!\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Base.setindex!-Tuple{VirtualPTDF, Any, CartesianIndex}","page":"Internal API Reference","title":"Base.setindex!","text":"setindex!(_, _, _)\n\n\n!!! STILL TO IMPLEMENT !!!\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Base.setindex!-Tuple{VirtualPTDF, Any, Vararg{Any}}","page":"Internal API Reference","title":"Base.setindex!","text":"setindex!(_, _, idx)\n\n\n!!! STILL TO IMPLEMENT !!!\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Base.setindex!-Union{Tuple{T}, Tuple{PowerNetworkMatrices.RowCache{T}, T, Int64}} where T<:Union{SparseArrays.SparseVector{Float64}, Vector{Float64}}","page":"Internal API Reference","title":"Base.setindex!","text":"setindex!(cache, val, key)\n\n\nAllocates vector as row of the matrix saved in cache.\n\nArguments\n\ncache::RowCache:       cache where the row vector is going to be saved\nval::Union{Vector{Float64}, SparseArrays.SparseVector{Float64}}:       vector to be saved\nkey::Int:       row number (corresponding to the enumerated branch index) related to the input row vector\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Base.size-Tuple{VirtualLODF}","page":"Internal API Reference","title":"Base.size","text":"size(vlodf)\n\n\nShows the size of the whole LODF matrix, not the number of rows stored.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Base.size-Tuple{VirtualPTDF}","page":"Internal API Reference","title":"Base.size","text":"size(vptdf)\n\n\nGives the size of the whole PTDF matrix, not the number of rows stored.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices._calculate_PTDF_matrix_DENSE-Tuple{SparseArrays.SparseMatrixCSC{Int8, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Set{Int64}, Vector{Float64}}","page":"Internal API Reference","title":"PowerNetworkMatrices._calculate_PTDF_matrix_DENSE","text":"_calculate_PTDF_matrix_DENSE(\n    A,\n    BA,\n    ref_bus_positions,\n    dist_slack\n)\n\n\nFunciton for internal use only.\n\nComputes the PTDF matrix by means of the LAPACK and BLAS functions for dense matrices.\n\nArguments\n\nA::Matrix{Int8}:       Incidence Matrix\nBA::Matrix{T} where {T <: Union{Float32, Float64}}:       BA matrix\nref_bus_positions::Set{Int}:       vector containing the indexes of the reference slack buses.\ndist_slack::Vector{Float64}):       vector containing the weights for the distributed slacks.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices._calculate_PTDF_matrix_KLU-Tuple{SparseArrays.SparseMatrixCSC{Int8, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Set{Int64}, Vector{Float64}}","page":"Internal API Reference","title":"PowerNetworkMatrices._calculate_PTDF_matrix_KLU","text":"_calculate_PTDF_matrix_KLU(\n    A,\n    BA,\n    ref_bus_positions,\n    dist_slack\n)\n\n\nFunciton for internal use only.\n\nComputes the PTDF matrix by means of the KLU.LU factorization for sparse matrices.\n\nArguments\n\nA::SparseArrays.SparseMatrixCSC{Int8, Int}:       Incidence Matrix\nBA::SparseArrays.SparseMatrixCSC{Float64, Int}:       BA matrix\nref_bus_positions::Set{Int}:       vector containing the indexes of the reference slack buses.\ndist_slack::Vector{Float64}:       vector containing the weights for the distributed slacks.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices._calculate_PTDF_matrix_MKLPardiso-Tuple{SparseArrays.SparseMatrixCSC{Int8, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Set{Int64}, Vector{Float64}}","page":"Internal API Reference","title":"PowerNetworkMatrices._calculate_PTDF_matrix_MKLPardiso","text":"_calculate_PTDF_matrix_MKLPardiso(\n    A,\n    BA,\n    ref_bus_positions,\n    dist_slack\n)\n\n\nFunciton for internal use only.\n\nComputes the PTDF matrix by means of the MKL Pardiso for dense matrices.\n\nArguments\n\nA::SparseArrays.SparseMatrixCSC{Int8, Int}:       Incidence Matrix\nBA::SparseArrays.SparseMatrixCSC{Float64, Int}:       BA matrix\nref_bus_positions::Set{Int}:       vector containing the indexes of the referece slack buses.\ndist_slack::Vector{Float64}:       vector containing the weights for the distributed slacks.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.assign_reference_buses!-Tuple{Dict{Int64, Set{Int64}}, Vector{Int64}}","page":"Internal API Reference","title":"PowerNetworkMatrices.assign_reference_buses!","text":"assign_reference_buses!(subnetworks, ref_buses)\n\n\nTakes the reference bus numbers and re-assigns the keys in the subnetwork dictionaries to use the reference bus withing each subnetwork.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.calculate_ABA_matrix-Tuple{SparseArrays.SparseMatrixCSC{Int8, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Set{Int64}}","page":"Internal API Reference","title":"PowerNetworkMatrices.calculate_ABA_matrix","text":"calculate_ABA_matrix(A, BA, ref_bus_positions)\n\n\nEvaluates the ABA matrix given the System's Incidence matrix (A), BA matrix and reference bus positions.\n\nArguments\n\nA::SparseArrays.SparseMatrixCSC{Int8, Int}:       Incidence matrix.\nBA::SparseArrays.SparseMatrixCSC{Float64, Int}       BA matrix.\n\nNOTE:\n\nevaluates A with \"calculateAmatrix\", or extract A.data (if A::IncidenceMatrix)\nevaluates BA with \"calculateBAmatrix\", or extract BA.data (if A::BA_Matrix)\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.calculate_A_matrix-Tuple{Any, Vector{PowerSystems.ACBus}}","page":"Internal API Reference","title":"PowerNetworkMatrices.calculate_A_matrix","text":"calculate_A_matrix(branches, buses)\n\n\nEvaluates the Incidence matrix A given the branches and node of a System.\n\nArguments\n\nbranches:       vector containing the branches of the considered system (should be AC branches).\nbuses::Vector{PSY.ACBus}:       vector containing the buses of the considered system.\n\nNOTE:\n\nthe matrix features all the columns, including the ones related to the reference buses (each column is related to a system's bus).\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.calculate_BA_matrix-Tuple{Any, Dict{Int64, Int64}}","page":"Internal API Reference","title":"PowerNetworkMatrices.calculate_BA_matrix","text":"calculate_BA_matrix(branches, bus_lookup)\n\n\nEvaluates the transposed BA matrix given the System's banches, reference bus positions and bus_lookup.\n\nArguments\n\nbranches:       vector containing the branches of the considered system (should be AC branches).\nref_bus_positions::Set{Int}:       Vector containing the indexes of the columns of the BA matrix corresponding       to the reference buses\nbus_lookup::Dict{Int, Int}:       dictionary mapping the bus numbers with their enumerated indexes.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.calculate_PTDF_matrix_DENSE-Tuple{Any, Vector{PowerSystems.ACBus}, Dict{Int64, Int64}, Vector{Float64}}","page":"Internal API Reference","title":"PowerNetworkMatrices.calculate_PTDF_matrix_DENSE","text":"calculate_PTDF_matrix_DENSE(\n    branches,\n    buses,\n    bus_lookup,\n    dist_slack\n)\n\n\nComputes the PTDF matrix by means of the LAPACK and BLAS functions for dense matrices.\n\nArguments\n\nbranches:       vector of the System AC branches\nbuses::Vector{PSY.ACBus}:       vector of the System buses\nbus_lookup::Dict{Int, Int}:       dictionary mapping the bus numbers with their enumerated indexes.\ndist_slack::Vector{Float64}:       vector containing the weights for the distributed slacks.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.calculate_PTDF_matrix_KLU-Tuple{Any, Vector{PowerSystems.ACBus}, Dict{Int64, Int64}, Vector{Float64}}","page":"Internal API Reference","title":"PowerNetworkMatrices.calculate_PTDF_matrix_KLU","text":"calculate_PTDF_matrix_KLU(\n    branches,\n    buses,\n    bus_lookup,\n    dist_slack\n)\n\n\nComputes the PTDF matrix by means of the KLU.LU factorization for sparse matrices.\n\nArguments\n\nbranches:       vector of the System AC branches\nbuses::Vector{PSY.ACBus}:       vector of the System buses\nbus_lookup::Dict{Int, Int}:       dictionary mapping the bus numbers with their enumerated indexes.\ndist_slack::Vector{Float64}:       vector containing the weights for the distributed slacks.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.calculate_PTDF_matrix_MKLPardiso-Tuple{Any, Vector{PowerSystems.ACBus}, Dict{Int64, Int64}, Vector{Float64}}","page":"Internal API Reference","title":"PowerNetworkMatrices.calculate_PTDF_matrix_MKLPardiso","text":"calculate_PTDF_matrix_MKLPardiso(\n    branches,\n    buses,\n    bus_lookup,\n    dist_slack\n)\n\n\nComputes the PTDF matrix by means of the MKL Pardiso for dense matrices.\n\nArguments\n\nbranches:       vector of the System AC branches\nbuses::Vector{PSY.ACBus}:       vector of the System buses\nbus_lookup::Dict{Int, Int}:       dictionary mapping the bus numbers with their enumerated indexes.\ndist_slack::Vector{Float64}:       vector containing the weights for the distributed slacks.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.calculate_adjacency-Tuple{Any, Vector{PowerSystems.ACBus}, Dict{Int64, Int64}}","page":"Internal API Reference","title":"PowerNetworkMatrices.calculate_adjacency","text":"calculate_adjacency(branches, buses, bus_lookup)\n\n\nEvaluates the Adjacency matrix given the System's banches, buses and bus_lookup.\n\nNOTE:\n\nbus_lookup is a dictionary mapping the bus numbers (as shown in the Systems) with their enumerated indxes.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.calculate_adjacency-Tuple{Any, Vector{PowerSystems.ACBus}}","page":"Internal API Reference","title":"PowerNetworkMatrices.calculate_adjacency","text":"calculate_adjacency(branches, buses)\n\n\nEvaluates the Adjacency matrix given the banches and buses of a given System.\n\nArguments\n\nbranches:       vector containing the branches of the considered system (should be AC branches).\nbuses::Vector{PSY.ACBus}:       vector containing the buses of the considered system.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.calculate_radial_branches-Tuple{SparseArrays.SparseMatrixCSC{Int8, Int64}, Dict{String, Int64}, Dict{Int64, Int64}, Set{Int64}}","page":"Internal API Reference","title":"PowerNetworkMatrices.calculate_radial_branches","text":"calculate_radial_branches(\n    A,\n    line_map,\n    bus_map,\n    ref_bus_positions\n)\n\n\nused to calculate the branches in the system that are radial and can be ignored in the models by exploring the structure of the incidence matrix\n\nArguments\n\nA::SparseArrays.SparseMatrixCSC{Int8, Int64}: Data from the IncidenceMatrix\nline_map::Dict{String, Int}: Map of Line Name to Matrix Index\nbus_map::Dict{Int, Int}: Map of Bus Name to Matrix Index\nref_bus_positions::Set{Int}:       Set containing the indexes of the columns of the BA matrix corresponding       to the reference buses\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.check_cache_size!-Tuple{PowerNetworkMatrices.RowCache}","page":"Internal API Reference","title":"PowerNetworkMatrices.check_cache_size!","text":"check_cache_size!(cache; new_add)\n\n\nCheck saved rows in cache and delete one not belonging to persistent_cache_keys.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.evaluate_A_matrix_values-Tuple{PowerSystems.System}","page":"Internal API Reference","title":"PowerNetworkMatrices.evaluate_A_matrix_values","text":"evaluate_A_matrix_values(sys)\n\n\nBuilds the Incidence matrix of the system by evaluating the actual matrix and other relevant values.\n\nArguments\n\nsys::PSY.System: the PowerSystem system to consider\nradial_network_reduction::RadialNetworkReduction:       Structure containing the radial branches and leaf buses that were removed       while evaluating the matrix\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.find_slack_positions-Tuple{Any}","page":"Internal API Reference","title":"PowerNetworkMatrices.find_slack_positions","text":"find_slack_positions(buses)\n\n\nGets the indices  of the reference (slack) buses. NOTE:\n\nthe indices  corresponds to the columns of zeros belonging to the PTDF matrix.\nBA and ABA matrix miss the columns related to the reference buses.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.get_ac_branches","page":"Internal API Reference","title":"PowerNetworkMatrices.get_ac_branches","text":"get_ac_branches(sys)\nget_ac_branches(sys, radial_branches)\n\n\nGets the AC branches from a given Systems.\n\n\n\n\n\n","category":"function"},{"location":"api/internal/#PowerNetworkMatrices.get_bus_indices-Tuple{Any, Any}","page":"Internal API Reference","title":"PowerNetworkMatrices.get_bus_indices","text":"get_bus_indices(branch, bus_lookup)\n\n\nEvaluates the bus indices for the given branch.\n\nArguments\n\nbranch:       system's branch\nbus_lookup:       dictionary mapping the system's buses and branches\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.get_buses","page":"Internal API Reference","title":"PowerNetworkMatrices.get_buses","text":"get_buses(sys)\nget_buses(sys, bus_reduction_map)\n\n\nGets the non-isolated buses from a given System\n\n\n\n\n\n","category":"function"},{"location":"api/internal/#PowerNetworkMatrices.get_data-Tuple{PowerNetworkMatrices.PowerNetworkMatrix}","page":"Internal API Reference","title":"PowerNetworkMatrices.get_data","text":"get_data(mat)\n\n\nreturns the raw array data of the PowerNetworkMatrix\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.get_lookup-Tuple{PowerNetworkMatrices.PowerNetworkMatrix}","page":"Internal API Reference","title":"PowerNetworkMatrices.get_lookup","text":"get_lookup(mat)\n\n\nreturns the lookup tuple of the `PowerNetworkMatrix`. The first entry corresponds\nto the first dimension and the second entry corresponds to the second dimension. For\ninstance in Ybus the first dimension is buses and second dimension is buses too, and in\nPTDF the first dimension is branches and the second dimension is buses\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.get_mapped_bus_number-Tuple{RadialNetworkReduction, Int64}","page":"Internal API Reference","title":"PowerNetworkMatrices.get_mapped_bus_number","text":"get_mapped_bus_number(rb, bus_number)\n\n\nInterface to obtain the parent bus number of a reduced bus when radial branches are eliminated\n\nArguments\n\nrb::RadialNetworkReduction: RadialNetworkReduction object\nbus_number::Int: Bus number of the reduced bus\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.get_mapped_bus_number-Tuple{RadialNetworkReduction, PowerSystems.ACBus}","page":"Internal API Reference","title":"PowerNetworkMatrices.get_mapped_bus_number","text":"get_mapped_bus_number(rb, bus)\n\n\nInterface to obtain the parent bus number of a reduced bus when radial branches are eliminated\n\nArguments\n\nrb::RadialNetworkReduction: RadialNetworkReduction object\nbus::ACBus: Reduced bus\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.get_tol-Tuple{VirtualLODF}","page":"Internal API Reference","title":"PowerNetworkMatrices.get_tol","text":"get_tol(mat)\n\n\nGets the tolerance used for sparsifying the rows of the VirtualLODF matrix\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.get_tol-Tuple{VirtualPTDF}","page":"Internal API Reference","title":"PowerNetworkMatrices.get_tol","text":"get_tol(vptdf)\n\n\nGets the tolerance used for sparsifying the rows of the VirtualPTDF matrix\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.lookup_index-Tuple{Any, Dict}","page":"Internal API Reference","title":"PowerNetworkMatrices.lookup_index","text":"lookup_index(i, lookup)\n\n\nGets bus indices to a certain branch index\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.lookup_index-Tuple{PowerSystems.ACBranch, Dict}","page":"Internal API Reference","title":"PowerNetworkMatrices.lookup_index","text":"lookup_index(i, lookup)\n\n\nGets bus indices to a certain branch name\n\nArguments\n\ni::PSY.ACBranch:       Power System AC branch\nlookup::Dict:       Dictionary mapping branch and buses\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.lookup_index-Tuple{PowerSystems.ACBus, Dict}","page":"Internal API Reference","title":"PowerNetworkMatrices.lookup_index","text":"lookup_index(i, lookup)\n\n\nGets bus indices to a certain branch name\n\nArguments\n\ni::PSY.ACBranch:       Power System AC branch\nlookup::Dict:       Dictionary mapping branches and buses\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.make_ax_ref-Tuple{AbstractVector{PowerSystems.ACBus}}","page":"Internal API Reference","title":"PowerNetworkMatrices.make_ax_ref","text":"make_ax_ref(buses)\n\n\nEvaluates the map linking the system's buses and branches.\n\nArguments\n\nbuses::AbstractVector{PSY.ACBus}:       system's buses\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.make_ax_ref-Tuple{AbstractVector}","page":"Internal API Reference","title":"PowerNetworkMatrices.make_ax_ref","text":"make_ax_ref(ax)\n\n\nCheckes if repetitions are present in the dictionary mapping buses and branches.\n\nArguments\n\nax::AbstractVector:       generic abstract vector\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.purge_one!-Tuple{PowerNetworkMatrices.RowCache}","page":"Internal API Reference","title":"PowerNetworkMatrices.purge_one!","text":"purge_one!(cache)\n\n\nDeletes a row from the stored matrix in cache not belonging to the persistentcachekeys set.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.sparsify-Tuple{Matrix{Float64}, Float64}","page":"Internal API Reference","title":"PowerNetworkMatrices.sparsify","text":"sparsify(dense_array, tol)\n\n\nReturn a sparse matrix given a dense one by dropping element whose absolute value is above a certain tolerance.\n\nArguments\n\ndense_array::Matrix{Float64}`:       input matrix (e.g., PTDF matrix).\ntol::Float64:       tolerance.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.sparsify-Tuple{Vector{Float64}, Float64}","page":"Internal API Reference","title":"PowerNetworkMatrices.sparsify","text":"sparsify(dense_array, tol)\n\n\nReturn a sparse vector given a dense one by dropping element whose absolute value is above a certain tolerance.\n\nArguments\n\ndense_array::Vector{Float64}`:       input vector (e.g., PTDF row from VirtualPTDF).\ntol::Float64:       tolerance.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.to_index-Tuple{PowerNetworkMatrices.PowerNetworkMatrix, Vararg{Any}}","page":"Internal API Reference","title":"PowerNetworkMatrices.to_index","text":"to_index(A, idx)\n\n\nGiven the indices, gets the values of the power network matrix considered\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.validate_linear_solver-Tuple{String}","page":"Internal API Reference","title":"PowerNetworkMatrices.validate_linear_solver","text":"validate_linear_solver(linear_solver)\n\n\nValidates if the selected linear solver is supported.\n\n\n\n\n\n","category":"method"},{"location":"#PowerNetworkMatrices.jl","page":"Welcome Page","title":"PowerNetworkMatrices.jl","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"CurrentModule = PowerNetworkMatrices","category":"page"},{"location":"#Overview","page":"Welcome Page","title":"Overview","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"PowerNetworkMatrices.jl is a Julia package for the evaluation of network matrices given the system's data. The package allows to compute the matrices according to different methods, providing a flexible and powerful tool.","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"The documentation and code are organized according to the needs of different users depending on their skillset and requirements. In broad terms there are three categories:","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"Modeler: Users that want to run a particular analysis or experiment and use PowerNetworkMatrices.jl to develop data sets.\nModel Developer: Users that want to develop custom components and structs in order to exploit PowerNetworkMatrices.jl features to produce custom data sets.\nCode Base Developers: Users that want to add new core functionalities or fix bugs in the core capabilities of PowerNetworkMatrices.jl.","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"PowerNetworkMatrices.jl is an active project under development, and we welcome your feedback, suggestions, and bug reports.","category":"page"},{"location":"#Installation","page":"Welcome Page","title":"Installation","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"The latest stable release of PowerNetworkMatrices can be installed using the Julia package manager with","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"] add PowerNetworkMatrices","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"For the current development version, \"checkout\" this package with","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"] add PowerNetworkMatrices#master","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"PowerNetworkMatrices has been developed as part of the Scalable Integrated Infrastructure Planning (SIIP) initiative at the U.S. Department of Energy's National Renewable Energy Laboratory (NREL).","category":"page"},{"location":"tutorials/tutorial_VirtualLODF_matrix/#VirtualLODF","page":"VirtualLODF matrix","title":"VirtualLODF","text":"","category":"section"},{"location":"tutorials/tutorial_VirtualLODF_matrix/","page":"VirtualLODF matrix","title":"VirtualLODF matrix","text":"The VirtualLODF structure follows the same philosofy as the VirtualPTDF: it contains rows of the original LODF matrix, evaluated and cached on demand.","category":"page"},{"location":"tutorials/tutorial_VirtualLODF_matrix/","page":"VirtualLODF matrix","title":"VirtualLODF matrix","text":"Refer to the different arguments of the VirtualLODF methods by looking at the \"Public API Reference\" page.","category":"page"},{"location":"tutorials/tutorial_VirtualLODF_matrix/#How-the-VirtualLODF-works","page":"VirtualLODF matrix","title":"How the VirtualLODF works","text":"","category":"section"},{"location":"tutorials/tutorial_VirtualLODF_matrix/","page":"VirtualLODF matrix","title":"VirtualLODF matrix","text":"The VirtualLODF structure retains many of the similarities of the VirtualPTDF. However, its computation is more complex and requires some additional data.","category":"page"},{"location":"tutorials/tutorial_VirtualLODF_matrix/","page":"VirtualLODF matrix","title":"VirtualLODF matrix","text":"Starting from the system data, the IncidenceMatrix, BA_Matrix and ABA_Matrix (with relative LU factorization matrices) are evaluated. The ABA_Matrix and BA_Matrix are used for the computation of the diagonal elements of the PTDF matrix, and this vector is stored in the VirtualLODF structure together with the other structures mentioned above.","category":"page"},{"location":"tutorials/tutorial_VirtualLODF_matrix/","page":"VirtualLODF matrix","title":"VirtualLODF matrix","text":"Once the VirtualLODF is initialized, each row of the matrix can be evaluated separately and on user request. The algorithmic procedure is the following:","category":"page"},{"location":"tutorials/tutorial_VirtualLODF_matrix/","page":"VirtualLODF matrix","title":"VirtualLODF matrix","text":"Define the VirtualPTDF structure\nCall any element of the matrix to define and store the relative row as well as showing the selected element","category":"page"},{"location":"tutorials/tutorial_VirtualLODF_matrix/","page":"VirtualLODF matrix","title":"VirtualLODF matrix","text":"Regarding point 2, if the row has been stored previosly then the desired element is just loaded from the cache and shown.","category":"page"},{"location":"tutorials/tutorial_VirtualLODF_matrix/","page":"VirtualLODF matrix","title":"VirtualLODF matrix","text":"The flowchart below shows how the VirtualLODF is structured and how it works. Examples will be presented in the following sections.","category":"page"},{"location":"tutorials/tutorial_VirtualLODF_matrix/","page":"VirtualLODF matrix","title":"VirtualLODF matrix","text":"<img src=\"../../assets/VirtualLODF_scheme.png\"/>","category":"page"},{"location":"tutorials/tutorial_VirtualLODF_matrix/#Initialize-VirtualLODF-and-compute/access-row/element","page":"VirtualLODF matrix","title":"Initialize VirtualLODF and compute/access row/element","text":"","category":"section"},{"location":"tutorials/tutorial_VirtualLODF_matrix/","page":"VirtualLODF matrix","title":"VirtualLODF matrix","text":"As for the LODF matrix, at first the System data must be loaded. The \"RTS-GMLC\" systems is considered as example:","category":"page"},{"location":"tutorials/tutorial_VirtualLODF_matrix/","page":"VirtualLODF matrix","title":"VirtualLODF matrix","text":"using PowerNetworkMatrices\nusing PowerSystemCaseBuilder\n\nconst PNM = PowerNetworkMatrices;\nconst PSB = PowerSystemCaseBuilder;\n\nsys = PSB.build_system(PSB.PSISystems, \"RTS_GMLC_DA_sys\");","category":"page"},{"location":"tutorials/tutorial_VirtualLODF_matrix/","page":"VirtualLODF matrix","title":"VirtualLODF matrix","text":"At this point the VirtualLODF is initialized with the following simple command:","category":"page"},{"location":"tutorials/tutorial_VirtualLODF_matrix/","page":"VirtualLODF matrix","title":"VirtualLODF matrix","text":"v_lodf = VirtualLODF(sys);","category":"page"},{"location":"tutorials/tutorial_VirtualLODF_matrix/","page":"VirtualLODF matrix","title":"VirtualLODF matrix","text":"Now, an element of the matrix can be computed by calling the branch name and bus number:","category":"page"},{"location":"tutorials/tutorial_VirtualLODF_matrix/","page":"VirtualLODF matrix","title":"VirtualLODF matrix","text":"el_C31_2_105 = v_lodf[\"C31-2\", \"A3\"]","category":"page"},{"location":"tutorials/tutorial_VirtualLODF_matrix/","page":"VirtualLODF matrix","title":"VirtualLODF matrix","text":"This element represent the portion flowing on line \"A3\" now diverted on line \"C31-2\" as a consequence of its outage.","category":"page"},{"location":"tutorials/tutorial_VirtualLODF_matrix/","page":"VirtualLODF matrix","title":"VirtualLODF matrix","text":"Alternatively, the number of the branch and bus (corresponding to the number of the PTDF row and column) can be used. In this case the row and column numbers are mapped by the dictonaries contained in the lookup field. ","category":"page"},{"location":"tutorials/tutorial_VirtualLODF_matrix/","page":"VirtualLODF matrix","title":"VirtualLODF matrix","text":"row_number = v_lodf.lookup[1][\"C31-2\"]\ncol_number = v_lodf.lookup[2][\"A3\"]\nel_C31_2_105_bis = v_lodf[row_number, col_number]","category":"page"},{"location":"tutorials/tutorial_VirtualLODF_matrix/","page":"VirtualLODF matrix","title":"VirtualLODF matrix","text":"NOTE: this example was made for the sake of completeness and considering the actual branch names is recommended.","category":"page"},{"location":"tutorials/tutorial_VirtualLODF_matrix/","page":"VirtualLODF matrix","title":"VirtualLODF matrix","text":"As previosly mentioned, in order to evaluate a single element of the VirtualLODF, the entire row related to the selected branch must be considered. For this reason it is cached for later calls. This is evident by looking at the following example:","category":"page"},{"location":"tutorials/tutorial_VirtualLODF_matrix/","page":"VirtualLODF matrix","title":"VirtualLODF matrix","text":"sys_2k = PSB.build_system(PSB.PSYTestSystems, \"tamu_ACTIVSg2000_sys\");\n\nv_lodf_2k = VirtualLODF(sys_2k);\n\n# evaluate PTDF row related to branch \"ODESSA 2 0  -1001-ODESSA 3 0  -1064-i_1\"\n@time v_lodf_2k[\"ODESSA 2 0  -1001-ODESSA 3 0  -1064-i_1\", \n                \"BRYAN 1 1   -8159-BRYAN 1 0   -8158-i_1\"]\n\n# call same element after the row has been stored\n@time v_lodf_2k[\"ODESSA 2 0  -1001-ODESSA 3 0  -1064-i_1\", \n                \"BRYAN 1 1   -8159-BRYAN 1 0   -8158-i_1\"]","category":"page"},{"location":"tutorials/tutorial_VirtualLODF_matrix/#\"Sparse\"-VirtualPTDF","page":"VirtualLODF matrix","title":"\"Sparse\" VirtualPTDF","text":"","category":"section"},{"location":"tutorials/tutorial_VirtualLODF_matrix/","page":"VirtualLODF matrix","title":"VirtualLODF matrix","text":"Sparsification of each row can be achieved in the same fashion as for the LODF matrix, by removing those elements whose absolute values is below a certain threshold.","category":"page"},{"location":"tutorials/tutorial_VirtualLODF_matrix/","page":"VirtualLODF matrix","title":"VirtualLODF matrix","text":"As for the example show for the LODF matrix, here to a very high values of 0.4 is considered for the tol field. Again, this value is considered just for the sake of this example.","category":"page"},{"location":"tutorials/tutorial_VirtualLODF_matrix/","page":"VirtualLODF matrix","title":"VirtualLODF matrix","text":"# smaller system for the next examples\nsys_2 = PSB.build_system(PSB.PSITestSystems, \"c_sys5\");\n\nv_lodf_dense = VirtualLODF(sys_2);\nv_lodf_sparse = VirtualLODF(sys_2, tol=0.4);","category":"page"},{"location":"tutorials/tutorial_VirtualLODF_matrix/","page":"VirtualLODF matrix","title":"VirtualLODF matrix","text":"Let's now evaluate the same row as before and compare the results:","category":"page"},{"location":"tutorials/tutorial_VirtualLODF_matrix/","page":"VirtualLODF matrix","title":"VirtualLODF matrix","text":"original_row = [v_lodf_dense[\"1\", j] for j in v_lodf_dense.axes[2]]\nsparse_row = [v_lodf_sparse[\"1\", j] for j in v_lodf_sparse.axes[2]]","category":"page"},{"location":"api/public/#Public-API-Reference","page":"Public API Reference","title":"Public API Reference","text":"","category":"section"},{"location":"api/public/","page":"Public API Reference","title":"Public API Reference","text":"Modules = [PowerNetworkMatrices]\nPublic = true","category":"page"},{"location":"api/public/#PowerNetworkMatrices.ABA_Matrix","page":"Public API Reference","title":"PowerNetworkMatrices.ABA_Matrix","text":"Structure containing the ABA matrix and other relevant data.\n\nArguments\n\ndata::SparseArrays.SparseMatrixCSC{Float64, Int}:       the ABA matrix coming from the product between the Incidence Matrix A and       the Matrix BA.\naxes<:NTuple{2, Dict}:       Tuple containing two identical vectors, both containing the number of       each bus of the network (each one related to a row/column of the Matrix       in \"data\"), excluding the slack buses.\nlookup<:NTuple{2, Dict}:       Tuple containing 2 Dictionaries mapping the number of rows and columns       with the number of the buses.\nref_bus_positions::Set{Int}:       Vector containing the indexes of the columns of the BA matrix corresponding       to the reference buses\nK<:Union{Nothing, KLU.KLUFactorization{Float64, Int}}:       either nothing or a container for KLU factorization matrices (LU factorization)\nradial_network_reduction::RadialNetworkReduction:       Structure containing the radial branches and leaf buses that were removed       while evaluating the matrix\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PowerNetworkMatrices.ABA_Matrix-Tuple{PowerSystems.System}","page":"Public API Reference","title":"PowerNetworkMatrices.ABA_Matrix","text":"ABA_Matrix(sys; factorize, reduce_radial_branches)\n\n\nBuilds the ABA matrix from a System\n\nArguments\n\nsys::PSY.System:       system to consider\n\nKeyword arguments\n\nfactorize: if true populates ABA_Matrix.K with KLU factorization matrices\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.AdjacencyMatrix","page":"Public API Reference","title":"PowerNetworkMatrices.AdjacencyMatrix","text":"Nodal incidence matrix (Adjacency) is an N x N matrix describing a power system with N buses. It represents the directed connectivity of the buses in a power system.\n\nThe AdjacencyMatrix Struct is indexed using the Bus Numbers, no need for them to be sequential\n\nArguments\n\ndata::SparseArrays.SparseMatrixCSC{Int8, Int}:       stores the incidence matrix\naxes<:NTuple{2, Dict}:       Tuple containing two vectors, the first one contains the names of each       line of the network (each one related to a row of the Matrix in \"data\"),       the second one contains the names of each bus of the network (each one       related to a column of the Matrix in \"data\")\nlookup<:NTuple{2, Dict}:       Tuple containing 2 Dictionaries mapping the number of rows and columns       with the names of branches and buses\nref_bus_positions::Set{Int}:       Vector containing the indexes of the columns of the BA matrix corresponding       to the reference buses\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PowerNetworkMatrices.AdjacencyMatrix-Tuple{Any, Vector{PowerSystems.ACBus}}","page":"Public API Reference","title":"PowerNetworkMatrices.AdjacencyMatrix","text":"AdjacencyMatrix(\n    branches,\n    buses;\n    check_connectivity,\n    kwargs...\n)\n\n\nBuilds a AdjacencyMatrix from a collection of buses and branches. The return is an N x N AdjacencyMatrix Array indexed with the bus numbers.\n\nArguments\n\ncheck_connectivity::Bool:       Checks connectivity of the network using Depth First Search (DFS) algorithm\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.AdjacencyMatrix-Tuple{PowerSystems.System}","page":"Public API Reference","title":"PowerNetworkMatrices.AdjacencyMatrix","text":"AdjacencyMatrix(sys; check_connectivity, kwargs...)\n\n\nBuilds a AdjacencyMatrix from the system. The return is an N x N AdjacencyMatrix Array indexed with the bus numbers.\n\nArguments\n\ncheck_connectivity::Bool:       Checks connectivity of the network using Depth First Search (DFS) algorithm\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.BA_Matrix","page":"Public API Reference","title":"PowerNetworkMatrices.BA_Matrix","text":"Structure containing the BA matrix and other relevant data.\n\nArguments\n\ndata::SparseArrays.SparseMatrixCSC{Float64, Int}:       the transposed BA matrix coming from the product between the Incidence       Matrix A and the Matrix of Susceptance B\naxes<:NTuple{2, Dict}:       Tuple containing two vectors, the first one contains the names of each       buse of the network (each one related to a row of the Matrix in \"data\"),       the second one contains the names of each line of the network (each one       related to a column of the Matrix in \"data\")\nlookup<:NTuple{2, Dict}:       Tuple containing 2 Dictionaries mapping the number of rows and columns       with the names of buses and branches\nref_bus_positions::Set{Int}:       Set containing the indexes of the columns of the BA matrix corresponding       to the reference buses\nradial_network_reduction::RadialNetworkReduction:       Structure containing the radial branches and leaf buses that were removed       while evaluating the matrix\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PowerNetworkMatrices.BA_Matrix-Tuple{PowerSystems.System}","page":"Public API Reference","title":"PowerNetworkMatrices.BA_Matrix","text":"BA_Matrix(sys; reduce_radial_branches)\n\n\nBuild the BA matrix from a given System\n\nArguments\n\nsys::PSY.System:       PSY system for which the matrix is constructed\nreduce_radial_branches::Bool:       if True the matrix is build considering radial branches removed from       the system\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.IncidenceMatrix","page":"Public API Reference","title":"PowerNetworkMatrices.IncidenceMatrix","text":"Incidence matrix: shows connection between buses, defining lines\n\nArguments\n\ndata::SparseArrays.SparseMatrixCSC{Int8, Int}:       the actual Incidence matrix.\naxes<:NTuple{2, Dict}:       Tuple containing two vectors (the first one showing the branches names,       the second showing the buses numbers).\nlookup<:NTuple{2, Dict}:       Tuple containing two dictionaries, the first mapping the branches       and buses with their enumerated indexes.\nref_bus_positions::Set{Int}:       Vector containing the indices of the reference slack buses.\nradial_network_reduction::RadialNetworkReduction:       Structure containing the radial branches and leaf buses that were removed       while evaluating the matrix\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PowerNetworkMatrices.IncidenceMatrix-Tuple{PowerSystems.System}","page":"Public API Reference","title":"PowerNetworkMatrices.IncidenceMatrix","text":"IncidenceMatrix(sys)\n\n\nBuilds the Incidence matrix of the system by evaluating the actual matrix and other relevant values.\n\nArguments\n\nsys::PSY.System:       the PowerSystem system to consider\nreduce_radial_branches::Bool:       if True the matrix will be evaluated discarding       all the radial branches and leaf buses (optional, default value is false)\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.LODF","page":"Public API Reference","title":"PowerNetworkMatrices.LODF","text":"The Line Outage Distribution Factor (LODF) matrix gathers a sensitivity coefficients of how a change in a line's flow affects the flows on other lines in the system.\n\nArguments\n\ndata<:AbstractArray{Float64, 2}:       the transposed LODF matrix.\naxes<:NTuple{2, Dict}:       Tuple containing two identical vectors containing the names of the       branches related to each row/column.\nlookup<:NTuple{2, Dict}:       Tuple containing two identical dictionaries mapping the branches        their enumerated indexes (row and column numbers).\ntol::Base.RefValue{Float64}:       tolerance used for sparsifying the matrix (dropping element whose       absolute value is below this threshold).\nradial_network_reduction::RadialNetworkReduction:       Structure containing the radial branches and leaf buses that were removed       while evaluating the matrix\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PowerNetworkMatrices.LODF-Tuple{Any, Vector{PowerSystems.ACBus}}","page":"Public API Reference","title":"PowerNetworkMatrices.LODF","text":"LODF(\n    branches,\n    buses;\n    linear_solver,\n    tol,\n    radial_network_reduction\n)\n\n\nBuilds the LODF matrix given the data of branches and buses of the system.\n\nArguments\n\nbranches:       vector of the System AC branches\nbuses::Vector{PSY.ACBus}:       vector of the System buses\n\nKeyword Arguments\n\nlinear_solver::String       linear solver to use for matrix evaluation.       Available options: \"KLU\", \"Dense\" (OpenBLAS) or \"MKLPardiso\".       Default solver: \"KLU\".\ntol::Float64:       Tolerance to eliminate entries in the LODF matrix (default eps())\nradial_network_reduction::RadialNetworkReduction:       Structure containing the radial branches and leaf buses that were removed       while evaluating the ma\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.LODF-Tuple{IncidenceMatrix, ABA_Matrix, BA_Matrix}","page":"Public API Reference","title":"PowerNetworkMatrices.LODF","text":"LODF(A, ABA, BA; linear_solver, tol, reduce_radial_branches)\n\n\nBuilds the LODF matrix given the Incidence Matrix and the PTDF matrix of the system.\n\nNOTE: this method does not support distributed slack bus.\n\nArguments\n\nA::IncidenceMatrix:       Structure containing the Incidence matrix of the system.\nABA::ABA_Matrix:       Structure containing the ABA matrix of the system.\nBA::BA_Matrix:       Structure containing the transposed BA matrix of the system.\nlinear_solver::String:       Linear solver to be used. Options are \"Dense\" and \"KLU\".\ntol::Float64:       Tolerance to eliminate entries in the LODF matrix (default eps()).\nreduce_radial_branches::Bool:       True to reduce the network by simplifying the radial branches and mapping the       eliminate buses\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.LODF-Tuple{IncidenceMatrix, PTDF}","page":"Public API Reference","title":"PowerNetworkMatrices.LODF","text":"LODF(A, PTDFm; linear_solver, tol, reduce_radial_branches)\n\n\nBuilds the LODF matrix given the Incidence Matrix and the PTDF matrix of the system.\n\nNOTE: tol is referred to the LODF sparsification, not the PTDF one. PTDF matrix must be considered as NON sparsified (\"tol\" argument not specified when calling the PTDF method).\n\nArguments\n\nA::IncidenceMatrix:       Structure containing the Incidence matrix of the system.\nPTDFm::PTDF:       Strucutre containing the transposed PTDF matrix of the system.\nlinear_solver::String:       Linear solver to be used. Options are \"Dense\" and \"KLU\".\ntol::Float64:       Tolerance to eliminate entries in the LODF matrix (default eps()).\nreduce_radial_branches::Bool:       True to reduce the network by simplifying the radial branches and mapping the       eliminate buses\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.LODF-Tuple{PowerSystems.System}","page":"Public API Reference","title":"PowerNetworkMatrices.LODF","text":"LODF(sys; reduce_radial_branches, kwargs...)\n\n\nBuilds the LODF matrix from a system. Note that reduce_radial_branches kwargs is explicitly mentioned because needed inside of the function.\n\nArguments\n\nsys::PSY.System:       Power Systems system\n\nKeyword Arguments\n\nreduce_radial_branches::Bool=false:       if True the matrix will be evaluated discarding       all the radial branches and leaf buses (optional, default value is false)\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.PTDF","page":"Public API Reference","title":"PowerNetworkMatrices.PTDF","text":"Power Transfer Distribution Factors (PTDF) indicate the incremental change in real power that occurs on transmission lines due to real power injections changes at the buses.\n\nThe PTDF struct is indexed using the Bus numbers and Branch names.\n\nArguments\n\ndata<:AbstractArray{Float64, 2}:       the transposed PTDF matrix.\naxes<:NTuple{2, Dict}:       Tuple containing two vectors: the first one showing the bus numbers,       the second showing the branch names. The information contained in this       field matches the axes of the fiels data.\nlookup<:NTuple{2, Dict}:       Tuple containing two dictionaries mapping the bus numbers and branch       names with the indices of the matrix contained in data.\nsubnetworks::Dict{Int, Set{Int}}:       dictionary containing the set of bus indexes defining the subnetworks       of the system.\ntol::Base.RefValue{Float64}:       tolerance used for sparsifying the matrix (dropping element whose       absolute value is below this threshold).\nradial_network_reduction::RadialNetworkReduction:       Structure containing the radial branches and leaf buses that were removed       while evaluating the matrix\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PowerNetworkMatrices.PTDF-Tuple{AbstractString}","page":"Public API Reference","title":"PowerNetworkMatrices.PTDF","text":"PTDF(filename)\n\n\nDeserialize a PTDF from an HDF5 file.\n\nArguments\n\nfilename::AbstractString: File containing a serialized PTDF.\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.PTDF-Tuple{Any, Vector{PowerSystems.ACBus}}","page":"Public API Reference","title":"PowerNetworkMatrices.PTDF","text":"PTDF(\n    branches,\n    buses;\n    dist_slack,\n    linear_solver,\n    tol,\n    radial_network_reduction\n)\n\n\nBuilds the PTDF matrix from a group of branches and buses. The return is a PTDF array indexed with the bus numbers.\n\nArguments\n\nbranches:       vector of the System AC branches\nbuses::Vector{PSY.ACBus}:       vector of the System buses\n\nKeyword Arguments\n\ndist_slack::Vector{Float64}:       vector of weights to be used as distributed slack bus.       The distributed slack vector has to be the same length as the number of buses\nlinear_solver::String:       Linear solver to be used. Options are \"Dense\", \"KLU\" and \"MKLPardiso\ntol::Float64:       Tolerance to eliminate entries in the PTDF matrix (default eps())\nradial_network_reduction::RadialNetworkReduction:       Structure containing the radial branches and leaf buses that were removed       while evaluating the ma\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.PTDF-Tuple{IncidenceMatrix, BA_Matrix}","page":"Public API Reference","title":"PowerNetworkMatrices.PTDF","text":"PTDF(\n    A,\n    BA;\n    dist_slack,\n    linear_solver,\n    tol,\n    reduce_radial_branches\n)\n\n\nBuilds the PTDF matrix from a system. The return is a PTDF array indexed with the bus numbers.\n\nArguments\n\nA::IncidenceMatrix:       Incidence Matrix (full structure)\nBA::BA_Matrix:       BA matrix (full structure)\n\nKeyword Arguments\n\ndist_slack::Vector{Float64}:       Vector of weights to be used as distributed slack bus.       The distributed slack vector has to be the same length as the number of buses.\nlinear_solver::String:       Linear solver to be used. Options are \"Dense\", \"KLU\" and \"MKLPardiso.\ntol::Float64:       Tolerance to eliminate entries in the PTDF matrix (default eps()).\nreduce_radial_branches::Bool:       True to reduce the network by simplifying the radial branches and mapping the       eliminate buses\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.PTDF-Tuple{PowerSystems.System}","page":"Public API Reference","title":"PowerNetworkMatrices.PTDF","text":"PTDF(sys; dist_slack, reduce_radial_branches, kwargs...)\n\n\nBuilds the PTDF matrix from a system. The return is a PTDF array indexed with the bus numbers. Note that dist_slack and reduce_radial_branches kwargs are explicitly mentioned because needed inside of the function.\n\nArguments\n\nsys::PSY.System:       PSY system for which the matrix is constructed\n\nKeyword Arguments\n\ndist_slack::Vector{Float64}=Float64[]:       vector of weights to be used as distributed slack bus.       The distributed slack vector has to be the same length as the number of buse\nreduce_radial_branches::Bool=false:       if True the matrix will be evaluated discarding       all the radial branches and leaf buses (optional, default value is false)\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.RadialNetworkReduction-Tuple{IncidenceMatrix}","page":"Public API Reference","title":"PowerNetworkMatrices.RadialNetworkReduction","text":"RadialNetworkReduction(A)\n\n\nStructure to collect information the branches in the system that are radial and can be ignored in the models.\n\nArguments\n\nA::IncidenceMatrix: IncidenceMatrix\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.VirtualLODF","page":"Public API Reference","title":"PowerNetworkMatrices.VirtualLODF","text":"The Virtual Line Outage Distribution Factor (VirtualLODF) structure gathers the rows of the LODF matrix as they are evaluated on-the-go. These rows are evalauted independently, cached in the structure and do not require the computation of the whole matrix (therefore significantly reducing the computational requirements).\n\nThe VirtualLODF is initialized with no row stored.\n\nThe VirtualLODF struct is indexed using branch names.\n\nArguments\n\nK::KLU.KLUFactorization{Float64, Int}:       LU factorization matrices of the ABA matrix, evaluated by means of KLU.\nBA::SparseArrays.SparseMatrixCSC{Float64, Int}:       BA matrix.\nA::SparseArrays.SparseMatrixCSC{Int8, Int}:       Incidence matrix.\ninv_PTDF_A_diag::Vector{Float64}:       Vector contiaining the element-wise reciprocal of the diagonal elements       coming from multuiplying the PTDF matrix with th Incidence matrix\nref_bus_positions::Set{Int}:       Vector containing the indexes of the rows of the transposed BA matrix       corresponding to the reference buses.\naxes<:NTuple{2, Dict}:       Tuple containing two vectors showing the branch names.\nlookup<:NTuple{2, Dict}:       Tuple containing two dictionaries, mapping the branches names       the enumerated row indexes indexes.\nvalid_ix::Vector{Int}:       Vector containing the row/columns indices of matrices related the buses       which are not slack ones.\ntemp_data::Vector{Float64}:       Temporary vector for internal use.\ncache::RowCache:       Cache were LODF rows are stored.\nsubnetworks::Dict{Int, Set{Int}}:       Dictionary containing the subsets of buses defining the different subnetwork of the system.\ntol::Base.RefValue{Float64}:       Tolerance related to scarification and values to drop.\nradial_network_reduction::RadialNetworkReduction:       Structure containing the radial branches and leaf buses that were removed       while evaluating the matrix\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PowerNetworkMatrices.VirtualLODF-Tuple{Any, Vector{PowerSystems.ACBus}}","page":"Public API Reference","title":"PowerNetworkMatrices.VirtualLODF","text":"VirtualLODF(\n    branches,\n    buses;\n    tol,\n    max_cache_size,\n    persistent_lines,\n    radial_network_reduction\n)\n\n\nBuilds the LODF matrix from a group of branches and buses. The return is a VirtualLODF struct with an empty cache.\n\nArguments\n\nbranches:       Vector of the system's AC branches.\nbuses::Vector{PSY.ACBus}:       Vector of the system's buses.\n\nKeyword Arguments\n\ntol::Float64 = eps():       Tolerance related to sparsification and values to drop.\nmax_cache_size::Int:       max cache size in MiB (inizialized as MAXCACHESIZE_MiB).\npersistent_lines::Vector{String}:       line to be evaluated as soon as the VirtualPTDF is created (initialized as empty vector of strings).\nradial_network_reduction::RadialNetworkReduction:       Structure containing the radial branches and leaf buses that were removed       while evaluating the matrix\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.VirtualLODF-Tuple{PowerSystems.System}","page":"Public API Reference","title":"PowerNetworkMatrices.VirtualLODF","text":"VirtualLODF(sys; reduce_radial_branches, kwargs...)\n\n\nBuilds the Virtual LODF matrix from a system. The return is a VirtualLODF struct with an empty cache.\n\nArguments\n\nsys::PSY.System:       PSY system for which the matrix is constructed\n\nKeyword Arguments\n\nreduce_radial_branches::Bool=false:       if True the matrix will be evaluated discarding       all the radial branches and leaf buses (optional, default value is false)\nkwargs...:       other keyword arguments used by VirtualPTDF\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.VirtualPTDF","page":"Public API Reference","title":"PowerNetworkMatrices.VirtualPTDF","text":"The Virtual Power Transfer Distribution Factor (VirtualPTDF) structure gathers the rows of the PTDF matrix as they are evaluated on-the-go. These rows are evalauted independently, cached in the structure and do not require the computation of the whole matrix (therefore significantly reducing the computational requirements).\n\nThe VirtualPTDF is initialized with no row stored.\n\nThe VirtualPTDF is indexed using branch names and bus numbers as for the PTDF matrix.\n\nArguments\n\nK::KLU.KLUFactorization{Float64, Int}:       LU factorization matrices of the ABA matrix, evaluated by means of KLU\nBA::SparseArrays.SparseMatrixCSC{Float64, Int}:       BA matric\nref_bus_positions::Set{Int}:       Vector containing the indexes of the columns of the BA matrix corresponding       to the reference buses\ndist_slack::Vector{Float64}:       Vector of weights to be used as distributed slack bus.       The distributed slack vector has to be the same length as the number of buses.\naxes<:NTuple{2, Dict}:       Tuple containing two vectors: the first one showing the branches names,       the second showing the buses numbers. There is no link between the       order of the vector of the branches names and the way the PTDF rows are       stored in the cache.\nlookup<:NTuple{2, Dict}:       Tuple containing two dictionaries, mapping the branches       and buses with their enumerated indexes. The branch indexes refer to       the key of the cache dictionary. The bus indexes refer to the position       of the elements in the PTDF row stored.\ntemp_data::Vector{Float64}:       Temporary vector for internal use.\nvalid_ix::Vector{Int}:       Vector containing the row/columns indices of matrices related the buses       which are not slack ones.\ncache::RowCache:       Cache were PTDF rows are stored.\nsubnetworks::Dict{Int, Set{Int}}:       Dictionary containing the subsets of buses defining the different subnetwork of the system.\ntol::Base.RefValue{Float64}:       Tolerance related to scarification and values to drop.\nradial_network_reduction::RadialNetworkReduction:       Structure containing the radial branches and leaf buses that were removed       while evaluating the matrix\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PowerNetworkMatrices.VirtualPTDF-Tuple{Any, Vector{PowerSystems.ACBus}}","page":"Public API Reference","title":"PowerNetworkMatrices.VirtualPTDF","text":"VirtualPTDF(\n    branches,\n    buses;\n    dist_slack,\n    tol,\n    max_cache_size,\n    persistent_lines,\n    radial_network_reduction\n)\n\n\nBuilds the PTDF matrix from a group of branches and buses. The return is a VirtualPTDF struct with an empty cache.\n\nArguments\n\nbranches:       Vector of the system's AC branches.\nbuses::Vector{PSY.ACBus}:       Vector of the system's buses.\n\nKeyword Arguments\n\ndist_slack::Vector{Float64} = Float64[]:       Vector of weights to be used as distributed slack bus.       The distributed slack vector has to be the same length as the number of buses.\ntol::Float64 = eps():       Tolerance related to sparsification and values to drop.\nmax_cache_size::Int:       max cache size in MiB (inizialized as MAXCACHESIZE_MiB).\npersistent_lines::Vector{String}:       line to be evaluated as soon as the VirtualPTDF is created (initialized as empty vector of strings).\nradial_network_reduction::RadialNetworkReduction:       Structure containing the radial branches and leaf buses that were removed       while evaluating the matrix\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.VirtualPTDF-Tuple{PowerSystems.System}","page":"Public API Reference","title":"PowerNetworkMatrices.VirtualPTDF","text":"VirtualPTDF(\n    sys;\n    dist_slack,\n    reduce_radial_branches,\n    kwargs...\n)\n\n\nBuilds the Virtual PTDF matrix from a system. The return is a VirtualPTDF struct with an empty cache.\n\nArguments\n\nsys::PSY.System:       PSY system for which the matrix is constructed\n\nKeyword Arguments\n\ndist_slack::Vector{Float64}=Float64[]:       vector of weights to be used as distributed slack bus.       The distributed slack vector has to be the same length as the number of buse\nreduce_radial_branches::Bool=false:       if True the matrix will be evaluated discarding       all the radial branches and leaf buses (optional, default value is false)\nkwargs...:       other keyword arguments used by VirtualPTDF\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.Ybus","page":"Public API Reference","title":"PowerNetworkMatrices.Ybus","text":"Nodal admittance matrix (Ybus) is an N x N matrix describing a power system with N buses. It represents the nodal admittance of the buses in a power system.\n\nThe Ybus Struct is indexed using the Bus Numbers, no need for them to be sequential\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PowerNetworkMatrices.Ybus-2","page":"Public API Reference","title":"PowerNetworkMatrices.Ybus","text":"Ybus(branches, buses; ...)\nYbus(branches, buses, fixed_admittances; check_connectivity)\n\n\nBuilds a Ybus from a collection of buses and branches. The return is a Ybus Array indexed with the bus numbers and the branch names.\n\nArguments\n\ncheck_connectivity::Bool: Checks connectivity of the network using Depth First Search (DFS)\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PowerNetworkMatrices.Ybus-Tuple{PowerSystems.System}","page":"Public API Reference","title":"PowerNetworkMatrices.Ybus","text":"Ybus(sys; kwargs...)\n\n\nBuilds a Ybus from the system. The return is a Ybus Array indexed with the bus numbers and the branch names.\n\nArguments\n\ncheck_connectivity::Bool: Checks connectivity of the network\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.factorize-Union{Tuple{ABA_Matrix{Ax, L, Nothing}}, Tuple{L}, Tuple{Ax}} where {Ax, L<:Tuple{Dict, Dict}}","page":"Public API Reference","title":"PowerNetworkMatrices.factorize","text":"factorize(ABA)\n\n\nEvaluates the LU factorization matrices of the ABA matrix, using KLU.\n\nArguments\n\nABA::ABA_Matrix{Ax, L, Nothing} where {Ax, L <: NTuple{2, Dict}}:       container for the ABA matrix, with ABA.K == nothing (LU matrices in K not evaluated)\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.find_subnetworks-Tuple{AdjacencyMatrix}","page":"Public API Reference","title":"PowerNetworkMatrices.find_subnetworks","text":"find_subnetworks(M)\n\n\nEvaluates subnetworks by looking for the subsets of buses connected each other, but not connected with buses of other subsets.\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.find_subnetworks-Tuple{PowerSystems.System}","page":"Public API Reference","title":"PowerNetworkMatrices.find_subnetworks","text":"find_subnetworks(sys)\n\n\nFinds the subnetworks in a system using Depth First Search (DFS). Returns a dictionary keyed by the reference bus of the subnetworks if they exist\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.find_subnetworks-Tuple{SparseArrays.SparseMatrixCSC, Vector{Int64}}","page":"Public API Reference","title":"PowerNetworkMatrices.find_subnetworks","text":"find_subnetworks(M, bus_numbers)\n\n\nFinds the subnetworks present in the considered System. This is evaluated by taking a the ABA or Adjacency Matrix.\n\nArguments\n\nM::SparseArrays.SparseMatrixCSC:       input sparse matrix.\nbus_numbers::Vector{Int}:       vector containing the indices of the system's buses.\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.from_hdf5-Tuple{Type{PTDF}, AbstractString}","page":"Public API Reference","title":"PowerNetworkMatrices.from_hdf5","text":"from_hdf5(_, filename)\n\n\nDeserialize a PTDF from an HDF5 file.\n\nArguments\n\n::Type{PTDF}:\nfilename::AbstractString: File containing a serialized PTDF.\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.to_hdf5-Tuple{PTDF, AbstractString}","page":"Public API Reference","title":"PowerNetworkMatrices.to_hdf5","text":"to_hdf5(ptdf, filename; compress, compression_level, force)\n\n\nSerialize the PTDF to an HDF5 file.\n\nArguments\n\nptdf::PTDF: matrix\nfilename::AbstractString: File to create\ncompress::Bool: Whether to enabled compression, defaults to true.\ncompression_level::Int: Compression level to use if compression is enabled.\nforce::Bool: Whether to overwrite the file if it already exists, defaults to false.\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.validate_connectivity-Tuple{AdjacencyMatrix}","page":"Public API Reference","title":"PowerNetworkMatrices.validate_connectivity","text":"validate_connectivity(M)\n\n\nValidates connectivity by checking that the number of subnetworks is 1 (fully connected network).\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.validate_connectivity-Tuple{PowerSystems.System}","page":"Public API Reference","title":"PowerNetworkMatrices.validate_connectivity","text":"validate_connectivity(sys)\n\n\nChecks the network connectivity of the system using Depth First Search (DFS)\n\n\n\n\n\n","category":"method"}]
}
