<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Public API Reference · PowerNetworkMatrices.jl</title><meta name="title" content="Public API Reference · PowerNetworkMatrices.jl"/><meta property="og:title" content="Public API Reference · PowerNetworkMatrices.jl"/><meta property="twitter:title" content="Public API Reference · PowerNetworkMatrices.jl"/><meta name="description" content="Documentation for PowerNetworkMatrices.jl."/><meta property="og:description" content="Documentation for PowerNetworkMatrices.jl."/><meta property="twitter:description" content="Documentation for PowerNetworkMatrices.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="PowerNetworkMatrices.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PowerNetworkMatrices.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Welcome Page</a></li><li><a class="tocitem" href="../../quick_start_guide/">Quick Start Guide</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/tutorial_Incidence_BA_ABA_matrices/">Incidence, BA and ABA matrices</a></li><li><a class="tocitem" href="../../tutorials/tutorial_PTDF_matrix/">PTDF matrix</a></li><li><a class="tocitem" href="../../tutorials/tutorial_VirtualPTDF_matrix/">VirtualPTDF matrix</a></li><li><a class="tocitem" href="../../tutorials/tutorial_LODF_matrix/">LODF matrix</a></li><li><a class="tocitem" href="../../tutorials/tutorial_VirtualLODF_matrix/">VirtualLODF matrix</a></li><li><a class="tocitem" href="../../tutorials/tutorial_RadialReduction/">RadialReduction</a></li><li><a class="tocitem" href="../../tutorials/tutorial_DegreeTwoReduction/">DegreeTwoReduction</a></li></ul></li><li class="is-active"><a class="tocitem" href>Public API Reference</a></li><li><a class="tocitem" href="../internal/">Internal API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Public API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Public API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/main/docs/src/api/public.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Public-API-Reference"><a class="docs-heading-anchor" href="#Public-API-Reference">Public API Reference</a><a id="Public-API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Public-API-Reference" title="Permalink"></a></h1><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.ABA_Matrix"><a class="docstring-binding" href="#PowerNetworkMatrices.ABA_Matrix"><code>PowerNetworkMatrices.ABA_Matrix</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Structure containing the ABA matrix and related power system analysis data.</p><p>The ABA matrix represents the bus susceptance matrix computed as A^T * B * A, where A is the incidence matrix and B is the branch susceptance matrix. This matrix is fundamental for DC power flow analysis, sensitivity calculations, and linear power system studies.</p><p><strong>Fields</strong></p><ul><li><code>data::SparseArrays.SparseMatrixCSC{Float64, Int}</code>:       The ABA matrix data representing the bus susceptance matrix. This square matrix has       dimensions equal to the number of buses excluding reference buses</li><li><code>axes::Ax</code>:       Tuple containing identical bus number vectors for rows and columns, excluding reference buses</li><li><code>lookup::L &lt;: NTuple{2, Dict}</code>:       Tuple of identical dictionaries providing fast lookup from bus numbers to matrix indices</li><li><code>subnetwork_axes::Dict{Int, Ax}</code>:       Mapping from reference bus numbers to their corresponding subnetwork axes</li><li><code>ref_bus_position::Vector{Int}</code>:       Vector containing the original indices of reference buses before matrix reduction</li><li><code>K::F &lt;: Union{Nothing, KLU.KLUFactorization{Float64, Int}}</code>:       Optional KLU factorization object for efficient linear system solving. Nothing if unfactorized</li><li><code>network_reduction_data::NetworkReductionData</code>:       Container for network reduction information applied during matrix construction</li></ul><p><strong>Mathematical Properties</strong></p><ul><li><strong>Matrix Form</strong>: ABA = A^T * B * A (bus susceptance matrix)</li><li><strong>Dimensions</strong>: (n<em>buses - n</em>ref) × (n<em>buses - n</em>ref)</li><li><strong>Symmetry</strong>: Positive definite symmetric matrix (for connected networks)</li><li><strong>Sparsity</strong>: Inherits sparsity pattern from network topology</li></ul><p><strong>Notes</strong></p><ul><li>Reference buses are excluded from the matrix to ensure invertibility</li><li>Factorization enables efficient solving of linear systems Ax = b</li><li>Used primarily for DC power flow analysis and power system sensitivity studies</li><li>Supports various network reduction techniques for computational efficiency</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/32a38fe1050b7787d39da4653c300562fee085d9/src/BA_ABA_matrices.jl#L142">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.ABA_Matrix-Tuple{PowerSystems.System}"><a class="docstring-binding" href="#PowerNetworkMatrices.ABA_Matrix-Tuple{PowerSystems.System}"><code>PowerNetworkMatrices.ABA_Matrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ABA_Matrix(sys; factorize, network_reductions, kwargs...)
</code></pre><pre><code class="language-julia hljs">ABA_Matrix(sys::PSY.System; factorize::Bool = false, network_reductions::Vector{NetworkReduction} = NetworkReduction[], kwargs...)</code></pre><p>Construct an ABA_Matrix from a PowerSystems.System by computing A^T * B * A where A is the incidence matrix and B is the branch susceptance matrix. The resulting matrix is fundamental for DC power flow analysis and power system sensitivity studies.</p><p><strong>Arguments</strong></p><ul><li><code>sys::PSY.System</code>: The power system from which to construct the ABA matrix</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>factorize::Bool = false</code>:       Whether to perform KLU factorization during construction for efficient linear system solving</li><li><code>network_reductions::Vector{NetworkReduction} = NetworkReduction[]</code>:       Vector of network reduction algorithms to apply before matrix construction</li><li><code>include_constant_impedance_loads::Bool=true</code>:        Whether to include constant impedance loads as shunt admittances in the network model</li><li><code>subnetwork_algorithm=iterative_union_find</code>:       Algorithm used for identifying electrical islands and connected components</li><li>Additional keyword arguments are passed to the underlying <code>Ybus</code> constructor</li></ul><p><strong>Returns</strong></p><ul><li><code>ABA_Matrix</code>: The constructed ABA matrix structure containing:<ul><li>Bus susceptance matrix data (excluding reference buses)</li><li>Network topology information and reference bus positions</li><li>Optional KLU factorization for efficient solving</li></ul></li></ul><p><strong>Mathematical Process</strong></p><ol><li><strong>Ybus Construction</strong>: Creates admittance matrix from system data</li><li><strong>Incidence Matrix</strong>: Computes bus-branch incidence matrix A</li><li><strong>BA Matrix</strong>: Forms branch susceptance weighted incidence matrix</li><li><strong>ABA Computation</strong>: Calculates A^T * B * A (bus susceptance matrix)</li><li><strong>Reference Bus Removal</strong>: Excludes reference buses for invertibility</li><li><strong>Optional Factorization</strong>: Performs KLU decomposition if requested</li></ol><p><strong>Notes</strong></p><ul><li>Reference buses are automatically detected and excluded from the final matrix</li><li>Factorization significantly improves performance for repeated linear system solves</li><li>Network reductions can dramatically improve computational efficiency for large systems</li><li>The resulting matrix supports PTDF, LODF, and other power system analysis calculations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/32a38fe1050b7787d39da4653c300562fee085d9/src/BA_ABA_matrices.jl#L200">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.ABA_Matrix-Tuple{Ybus}"><a class="docstring-binding" href="#PowerNetworkMatrices.ABA_Matrix-Tuple{Ybus}"><code>PowerNetworkMatrices.ABA_Matrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ABA_Matrix(ybus; factorize)
</code></pre><pre><code class="language-julia hljs">ABA_Matrix(ybus::Ybus; factorize::Bool = false)</code></pre><p>Construct an ABA_Matrix from a Ybus matrix by computing A^T * B * A where A is the incidence matrix and B is the branch susceptance matrix. The resulting matrix is fundamental for DC power flow analysis and power system sensitivity studies. Network reductions can be passed via the computed Ybus matrix.</p><p><strong>Arguments</strong></p><ul><li><code>ybus::Ybus</code>: The power system Ybus matrix from which to construct the ABA matrix</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>factorize::Bool = false</code>:       Whether to perform KLU factorization during construction for efficient linear system solving</li></ul><p><strong>Returns</strong></p><ul><li><code>ABA_Matrix</code>: The constructed ABA matrix structure containing:<ul><li>Bus susceptance matrix data (excluding reference buses)</li><li>Network topology information and reference bus positions</li><li>Optional KLU factorization for efficient solving</li></ul></li></ul><p><strong>Mathematical Process</strong></p><ol><li><strong>Incidence Matrix</strong>: Computes bus-branch incidence matrix A (from Ybus matrix)</li><li><strong>BA Matrix</strong>: Forms branch susceptance weighted incidence matrix</li><li><strong>ABA Computation</strong>: Calculates A^T * B * A (bus susceptance matrix)</li><li><strong>Reference Bus Removal</strong>: Excludes reference buses for invertibility</li><li><strong>Optional Factorization</strong>: Performs KLU decomposition if requested</li></ol><p><strong>Notes</strong></p><ul><li>Reference buses are automatically detected and excluded from the final matrix</li><li>Factorization significantly improves performance for repeated linear system solves</li><li>Network reductions can dramatically improve computational efficiency for large systems</li><li>The resulting matrix supports PTDF, LODF, and other power system analysis calculations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/32a38fe1050b7787d39da4653c300562fee085d9/src/BA_ABA_matrices.jl#L254">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.AdjacencyMatrix"><a class="docstring-binding" href="#PowerNetworkMatrices.AdjacencyMatrix"><code>PowerNetworkMatrices.AdjacencyMatrix</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AdjacencyMatrix{Ax, L} &lt;: PowerNetworkMatrix{Int8}</code></pre><p>An N × N adjacency matrix representing the connectivity structure of a power system with N buses. This matrix describes the directed connectivity between buses, where non-zero entries indicate electrical connections through transmission lines, transformers, or other network elements.</p><p>The matrix is indexed using bus numbers, which do not need to be sequential. Each element <code>A[i,j]</code> is non-zero if there is a direct electrical connection between bus <code>i</code> and bus <code>j</code>. Diagonal elements are typically zero since self-loops are not meaningful in power network topology.</p><p><strong>Fields</strong></p><ul><li><code>data::SparseArrays.SparseMatrixCSC{Int8, Int}</code>: The sparse adjacency matrix storing connectivity information as Int8 values (zero for no connection, non-zero for connection)</li><li><code>axes::Ax</code>: Tuple containing the axis labels for both dimensions. The first element contains bus identifiers for rows, the second contains bus identifiers for columns (typically identical)</li><li><code>lookup::L</code>: Tuple of dictionaries providing bidirectional mapping between bus numbers and their corresponding matrix indices</li><li><code>subnetwork_axes::Dict{Int, Ax}</code>: Dictionary mapping subnetwork identifiers to their corresponding axis information, used for handling electrical islands</li><li><code>network_reduction_data::NetworkReductionData</code>: Container for network reduction algorithms and their associated data, enabling efficient matrix operations on reduced networks</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create from a PowerSystems.System
sys = System(&quot;case5.m&quot;)
adj = AdjacencyMatrix(sys)

# Create from a Ybus matrix
ybus = Ybus(sys)
adj = AdjacencyMatrix(ybus)

# Check connectivity
is_connected = validate_connectivity(adj)
subnetworks = find_subnetworks(adj)</code></pre><p>See also: <a href="#PowerNetworkMatrices.Ybus"><code>Ybus</code></a>, <a href="../../tutorials/tutorial_Incidence_BA_ABA_matrices/#IncidenceMatrix"><code>IncidenceMatrix</code></a>, <a href="../internal/#PowerNetworkMatrices.PowerNetworkMatrix"><code>PowerNetworkMatrix</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/32a38fe1050b7787d39da4653c300562fee085d9/src/AdjacencyMatrix.jl#L2">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.AdjacencyMatrix-Tuple{PowerSystems.System}"><a class="docstring-binding" href="#PowerNetworkMatrices.AdjacencyMatrix-Tuple{PowerSystems.System}"><code>PowerNetworkMatrices.AdjacencyMatrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">AdjacencyMatrix(sys; kwargs...)
</code></pre><pre><code class="language-julia hljs">AdjacencyMatrix(sys::PSY.System; kwargs...)</code></pre><p>Construct an AdjacencyMatrix from a PowerSystems.System.</p><p><strong>Arguments</strong></p><ul><li><code>sys::PSY.System</code>: The power system from which to construct the adjacency matrix</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>network_reductions::Vector{NetworkReduction}=[]</code>: Network reduction algorithms to apply</li><li><code>include_constant_impedance_loads::Bool=true</code>: Whether to include constant impedance loads as shunt admittances</li><li><code>subnetwork_algorithm=iterative_union_find</code>: Algorithm for finding electrical islands</li></ul><p><strong>Returns</strong></p><ul><li><code>AdjacencyMatrix</code>: An N x N adjacency matrix indexed with bus numbers showing connectivity</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/32a38fe1050b7787d39da4653c300562fee085d9/src/AdjacencyMatrix.jl#L199">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.AdjacencyMatrix-Tuple{Ybus}"><a class="docstring-binding" href="#PowerNetworkMatrices.AdjacencyMatrix-Tuple{Ybus}"><code>PowerNetworkMatrices.AdjacencyMatrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">AdjacencyMatrix(ybus)
</code></pre><pre><code class="language-julia hljs">AdjacencyMatrix(ybus::Ybus)</code></pre><p>Construct an AdjacencyMatrix from a Ybus matrix.</p><p><strong>Arguments</strong></p><ul><li><code>ybus::Ybus</code>: The Ybus matrix from which to construct the adjacency matrix</li></ul><p><strong>Returns</strong></p><ul><li><code>AdjacencyMatrix</code>: The constructed adjacency matrix showing bus connectivity</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/32a38fe1050b7787d39da4653c300562fee085d9/src/AdjacencyMatrix.jl#L220">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.ArcAdmittanceMatrix"><a class="docstring-binding" href="#PowerNetworkMatrices.ArcAdmittanceMatrix"><code>PowerNetworkMatrices.ArcAdmittanceMatrix</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Arc admittance matrix</p><p><strong>Arguments</strong></p><ul><li><code>data::SparseArrays.SparseMatrixCSC{ComplexF32, Int}</code>:       The arc admittance matrix in the from-to direction</li><li><code>axes&lt;:NTuple{2, Dict}</code>:       Tuple containing two vectors (the first one showing the arc tuples,       the second showing the buses numbers).</li><li><code>lookup&lt;:NTuple{2, Dict}</code>:       Tuple containing two dictionaries, the first mapping the arc tuples       and the second the buses with their enumerated indexes.</li><li><code>network_reduction::NetworkReduction</code>:       Structure containing the details of the network reduction applied when computing the matrix</li><li><code>direction::Symbol</code>:       Direction of admittance (:FromTo or :ToFrom)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/32a38fe1050b7787d39da4653c300562fee085d9/src/ArcAdmittanceMatrix.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.BA_Matrix"><a class="docstring-binding" href="#PowerNetworkMatrices.BA_Matrix"><code>PowerNetworkMatrices.BA_Matrix</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Structure containing the BA matrix and related network topology data.</p><p>The BA matrix represents the branch-bus incidence matrix weighted by branch susceptances, computed as the product of the incidence matrix A and the susceptance matrix B.</p><p><strong>Fields</strong></p><ul><li><code>data::SparseArrays.SparseMatrixCSC{Float64, Int}</code>:       The transposed BA matrix data. Each row corresponds to a bus and each column       corresponds to a branch, with values representing weighted branch susceptances</li><li><code>axes::Ax</code>:       Tuple containing two vectors: bus numbers (rows) and branch identifiers (columns)</li><li><code>lookup::L &lt;: NTuple{2, Dict}</code>:       Tuple of dictionaries providing fast lookup from bus/branch names to matrix indices</li><li><code>subnetwork_axes::Dict{Int, Ax}</code>:       Mapping from reference bus numbers to their corresponding subnetwork axes</li><li><code>network_reduction_data::NetworkReductionData</code>:       Container for network reduction information applied during matrix construction</li></ul><p><strong>Notes</strong></p><ul><li>The matrix is stored in transposed form for computational efficiency</li><li>Reference buses are identified through <code>subnetwork_axes</code> keys</li><li>Supports various network reduction techniques for computational efficiency</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/32a38fe1050b7787d39da4653c300562fee085d9/src/BA_ABA_matrices.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.BA_Matrix-Tuple{PowerSystems.System}"><a class="docstring-binding" href="#PowerNetworkMatrices.BA_Matrix-Tuple{PowerSystems.System}"><code>PowerNetworkMatrices.BA_Matrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">BA_Matrix(sys; network_reductions, kwargs...)
</code></pre><pre><code class="language-julia hljs">BA_Matrix(sys::PSY.System; network_reductions::Vector{NetworkReduction} = Vector{NetworkReduction}(), kwargs...)</code></pre><p>Construct a BA_Matrix from a PowerSystems.System by first building the underlying Ybus matrix and then computing the branch-bus incidence matrix weighted by branch susceptances.</p><p><strong>Arguments</strong></p><ul><li><code>sys::PSY.System</code>: The power system from which to construct the BA matrix</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>network_reductions::Vector{NetworkReduction} = Vector{NetworkReduction}()</code>:       Vector of network reduction algorithms to apply before matrix construction</li><li><code>include_constant_impedance_loads::Bool=true</code>:       Whether to include constant impedance loads as shunt admittances in the network model</li><li><code>subnetwork_algorithm=iterative_union_find</code>:       Algorithm used for identifying electrical islands and connected components</li><li>Additional keyword arguments are passed to the underlying <code>Ybus</code> constructor</li></ul><p><strong>Returns</strong></p><ul><li><code>BA_Matrix</code>: The constructed BA matrix structure containing the transposed branch-bus incidence             matrix weighted by susceptances, along with network topology information</li></ul><p><strong>Notes</strong></p><ul><li>This constructor creates a <code>Ybus</code> matrix internally and then converts it to a <code>BA_Matrix</code></li><li>Network reductions can significantly improve computational efficiency for large systems</li><li>The resulting matrix supports DC power flow calculations and sensitivity analysis</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/32a38fe1050b7787d39da4653c300562fee085d9/src/BA_ABA_matrices.jl#L44">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.BA_Matrix-Tuple{Ybus}"><a class="docstring-binding" href="#PowerNetworkMatrices.BA_Matrix-Tuple{Ybus}"><code>PowerNetworkMatrices.BA_Matrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">BA_Matrix(ybus)
</code></pre><pre><code class="language-julia hljs">BA_Matrix(ybus::Ybus)</code></pre><p>Construct a BA_Matrix from a Ybus matrix.</p><p><strong>Arguments</strong></p><ul><li><code>ybus::Ybus</code>: The Ybus matrix from which to construct the BA matrix</li></ul><p><strong>Returns</strong></p><ul><li><code>BA_Matrix</code>: The constructed BA matrix structure containing the transposed BA matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/32a38fe1050b7787d39da4653c300562fee085d9/src/BA_ABA_matrices.jl#L84">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.DegreeTwoReduction"><a class="docstring-binding" href="#PowerNetworkMatrices.DegreeTwoReduction"><code>PowerNetworkMatrices.DegreeTwoReduction</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DegreeTwoReduction &lt;: NetworkReduction</code></pre><p>Network reduction algorithm that eliminates buses with exactly two connections by combining the incident branches into a single equivalent branch. This reduction preserves the electrical characteristics of the network while simplifying its topology.</p><p><strong>Fields</strong></p><ul><li><code>irreducible_buses::Vector{Int}</code>: List of bus numbers that should not be eliminated even if they have degree two</li><li><code>reduce_reactive_power_injectors::Bool</code>: Whether to reduce buses with reactive power injections (default: true)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create degree-two reduction with default settings
reduction = DegreeTwoReduction()

# Create degree-two reduction protecting specific buses
reduction = DegreeTwoReduction(irreducible_buses=[101, 205])

# Create reduction that preserves buses with reactive power injections
reduction = DegreeTwoReduction(reduce_reactive_power_injectors=false)

# Apply to system
ybus = Ybus(system; network_reductions=[reduction])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/32a38fe1050b7787d39da4653c300562fee085d9/src/degree_two_reduction.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.IncidenceMatrix"><a class="docstring-binding" href="#PowerNetworkMatrices.IncidenceMatrix"><code>PowerNetworkMatrices.IncidenceMatrix</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Structure containing the network incidence matrix and related topology data.</p><p>The incidence matrix A represents the bus-branch connectivity of the power network, where each row corresponds to a branch and each column corresponds to a bus. Elements are:</p><ul><li>+1 for the &quot;from&quot; bus of a branch</li><li>-1 for the &quot;to&quot; bus of a branch  </li><li>0 for buses not connected to the branch</li></ul><p><strong>Fields</strong></p><ul><li><code>data::SparseArrays.SparseMatrixCSC{Int8, Int}</code>:       The incidence matrix data with dimensions (n<em>branches × n</em>buses). Values are {-1, 0, +1}       representing the directed connectivity between branches and buses</li><li><code>axes::Ax</code>:       Tuple containing (arc<em>identifiers, bus</em>numbers) where arcs are branch endpoint pairs       and buses are the network bus numbers</li><li><code>lookup::L &lt;: NTuple{2, Dict}</code>:       Tuple of dictionaries providing fast lookup from arc/bus identifiers to matrix indices</li><li><code>subnetwork_axes::Dict{Int, Ax}</code>:       Mapping from reference bus numbers to their corresponding subnetwork axes</li><li><code>network_reduction_data::NetworkReductionData</code>:       Container for network reduction information applied during matrix construction</li></ul><p><strong>Mathematical Properties</strong></p><ul><li><strong>Matrix Dimensions</strong>: (n<em>branches × n</em>buses)</li><li><strong>Element Values</strong>: {-1, 0, +1} representing directed branch-bus connectivity</li><li><strong>Row Sum</strong>: Each row sums to zero (conservation at branch level)</li><li><strong>Rank</strong>: Rank is (n<em>buses - n</em>islands) for connected networks</li><li><strong>Sparsity</strong>: Very sparse with exactly 2 non-zero elements per branch row</li></ul><p><strong>Applications</strong></p><ul><li><strong>Power Flow</strong>: Forms the basis for DC power flow equations: P = A^T * f</li><li><strong>Sensitivity Analysis</strong>: Used in PTDF and LODF calculations</li><li><strong>Network Analysis</strong>: Identifies connected components and network structure</li><li><strong>Topology Processing</strong>: Enables network reduction and equivalencing algorithms</li></ul><p><strong>Notes</strong></p><ul><li>Each branch contributes exactly one row with two non-zero entries (+1, -1)</li><li>Reference buses are preserved in the matrix but identified separately</li><li>Supports various network reduction techniques for computational efficiency</li><li>Essential building block for BA<em>Matrix and ABA</em>Matrix constructions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/32a38fe1050b7787d39da4653c300562fee085d9/src/IncidenceMatrix.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.IncidenceMatrix-Tuple{PowerSystems.System}"><a class="docstring-binding" href="#PowerNetworkMatrices.IncidenceMatrix-Tuple{PowerSystems.System}"><code>PowerNetworkMatrices.IncidenceMatrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">IncidenceMatrix(sys; network_reductions, kwargs...)
</code></pre><pre><code class="language-julia hljs">IncidenceMatrix(sys::PSY.System; network_reductions::Vector{NetworkReduction} = NetworkReduction[], kwargs...)</code></pre><p>Construct an IncidenceMatrix from a PowerSystems.System by extracting the network topology and creating the bus-branch connectivity matrix fundamental to power system analysis.</p><p><strong>Arguments</strong></p><ul><li><code>sys::PSY.System</code>: The power system from which to construct the incidence matrix</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>network_reductions::Vector{NetworkReduction} = NetworkReduction[]</code>:        Vector of network reduction algorithms to apply before matrix construction</li><li><code>include_constant_impedance_loads::Bool=true</code>:        Whether to include constant impedance loads as shunt admittances in the network model</li><li><code>subnetwork_algorithm=iterative_union_find</code>:        Algorithm used for identifying electrical islands and connected components</li><li>Additional keyword arguments are passed to the underlying <code>Ybus</code> constructor</li></ul><p><strong>Returns</strong></p><ul><li><code>IncidenceMatrix</code>: The constructed incidence matrix structure containing:<ul><li>Bus-branch connectivity matrix with {-1, 0, +1} elements</li><li>Network topology information and reference bus identification</li><li>Support for network reductions and connected component analysis</li></ul></li></ul><p><strong>Mathematical Construction</strong></p><ol><li><strong>Network Extraction</strong>: Identifies all branches and buses from the power system</li><li><strong>Connectivity Mapping</strong>: Creates directed branch-bus relationships  </li><li><strong>Matrix Assembly</strong>: Constructs sparse matrix with +1/-1 entries for branch endpoints</li><li><strong>Topology Analysis</strong>: Identifies reference buses and connected components</li><li><strong>Network Reductions</strong>: Applies specified reduction algorithms if provided</li></ol><p><strong>Applications</strong></p><ul><li><strong>Foundation Matrix</strong>: Essential for constructing BA<em>Matrix and ABA</em>Matrix</li><li><strong>DC Power Flow</strong>: Enables linearized power flow analysis through P = A^T * f</li><li><strong>Sensitivity Analysis</strong>: Required for PTDF, LODF, and other sensitivity calculations</li><li><strong>Network Analysis</strong>: Supports topology processing and network equivalencing</li></ul><p><strong>Notes</strong></p><ul><li>Each branch creates exactly one matrix row with two non-zero entries</li><li>Network reductions can significantly improve computational efficiency</li><li>Reference buses are automatically identified for later matrix operations</li><li>The matrix preserves full network topology for comprehensive power system analysis</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/32a38fe1050b7787d39da4653c300562fee085d9/src/IncidenceMatrix.jl#L84">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.IncidenceMatrix-Tuple{Ybus}"><a class="docstring-binding" href="#PowerNetworkMatrices.IncidenceMatrix-Tuple{Ybus}"><code>PowerNetworkMatrices.IncidenceMatrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">IncidenceMatrix(ybus)
</code></pre><pre><code class="language-julia hljs">IncidenceMatrix(ybus::Ybus)</code></pre><p>Construct an IncidenceMatrix from an existing Ybus matrix by extracting the network topology and creating the bus-branch connectivity matrix. This constructor leverages the network  structure already captured in the Ybus matrix.</p><p><strong>Arguments</strong></p><ul><li><code>ybus::Ybus</code>: The Ybus matrix containing network topology and admittance data</li></ul><p><strong>Returns</strong></p><ul><li><code>IncidenceMatrix</code>: The constructed incidence matrix structure containing:<ul><li>Bus-branch connectivity matrix with {-1, 0, +1} elements representing directed connections</li><li>Network topology information extracted from the Ybus structure</li><li>Reference bus identification and subnetwork axes from the source matrix</li><li>Network reduction data inherited from the Ybus matrix</li></ul></li></ul><p><strong>Construction Process</strong></p><ol><li><strong>Topology Extraction</strong>: Retrieves bus and branch information from the Ybus matrix</li><li><strong>Arc Processing</strong>: Creates directed arc representations from branch connectivity</li><li><strong>Matrix Assembly</strong>: Constructs sparse incidence matrix with +1 (from bus) and -1 (to bus) entries</li><li><strong>Isolated Bus Handling</strong>: Includes isolated buses with zero entries for completeness</li><li><strong>Metadata Transfer</strong>: Preserves reference bus positions and network reduction information</li></ol><p><strong>Mathematical Properties</strong></p><ul><li><strong>Matrix Form</strong>: A[i,j] = +1 if branch i originates at bus j, -1 if it terminates at bus j, 0 otherwise</li><li><strong>Dimensions</strong>: (n<em>branches × n</em>buses) including all network branches and buses</li><li><strong>Sparsity</strong>: Exactly 2 non-zero entries per branch row (except for isolated buses)</li><li><strong>Consistency</strong>: Maintains the same network topology and reduction state as the source Ybus</li></ul><p><strong>Notes</strong></p><ul><li>This constructor is more efficient when a Ybus matrix is already available</li><li>Preserves all network reduction information from the source matrix</li><li>Isolated buses are handled explicitly to maintain network completeness</li><li>Essential for creating downstream matrices like BA<em>Matrix and ABA</em>Matrix from existing Ybus</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/32a38fe1050b7787d39da4653c300562fee085d9/src/IncidenceMatrix.jl#L140">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.LODF"><a class="docstring-binding" href="#PowerNetworkMatrices.LODF"><code>PowerNetworkMatrices.LODF</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Structure containing the Line Outage Distribution Factor (LODF) matrix and related power system data.</p><p>The LODF matrix contains sensitivity coefficients that quantify how the outage of one transmission  line affects the power flows on all other lines in the system. Each element LODF[i,j] represents  the change in flow on line i when line j is taken out of service, normalized by the pre-outage  flow on line j.</p><p><strong>Fields</strong></p><ul><li><code>data::M &lt;: AbstractArray{Float64, 2}</code>:       The LODF matrix data stored in transposed form for computational efficiency.        Element (i,j) represents the sensitivity of line j flow to line i outage</li><li><code>axes::Ax</code>:       Tuple of identical branch/arc identifier vectors for both matrix dimensions</li><li><code>lookup::L &lt;: NTuple{2, Dict}</code>:       Tuple of identical dictionaries providing fast lookup from branch identifiers to matrix indices</li><li><code>subnetwork_axes::Dict{Int, Ax}</code>:       Mapping from reference bus numbers to their corresponding subnetwork branch axes</li><li><code>tol::Base.RefValue{Float64}</code>:       Tolerance threshold used for matrix sparsification (elements below this value are dropped)</li><li><code>network_reduction_data::NetworkReductionData</code>:       Container for network reduction information applied during matrix construction</li></ul><p><strong>Mathematical Properties</strong></p><ul><li><strong>Matrix Form</strong>: LODF[i,j] = ∂f<em>i/∂P</em>j where f<em>i is flow on line i, P</em>j is injection change due to line j outage</li><li><strong>Dimensions</strong>: (n<em>branches × n</em>branches) for all transmission lines in the system</li><li><strong>Diagonal Elements</strong>: Always -1 (100% flow reduction on the outaged line itself)</li><li><strong>Symmetry</strong>: Generally non-symmetric matrix reflecting directional flow sensitivities</li><li><strong>Physical Meaning</strong>: Values represent fraction of pre-outage flow that redistributes to other lines</li></ul><p><strong>Applications</strong></p><ul><li><strong>Contingency Analysis</strong>: Evaluate impact of single line outages on system flows</li><li><strong>Security Assessment</strong>: Identify critical transmission bottlenecks and vulnerable lines</li><li><strong>System Planning</strong>: Analyze network robustness and redundancy requirements</li><li><strong>Real-time Operations</strong>: Support operator decision-making for preventive/corrective actions</li></ul><p><strong>Computational Notes</strong></p><ul><li><strong>Storage</strong>: Matrix stored in transposed form for efficient column-wise access patterns</li><li><strong>Sparsification</strong>: Small elements removed based on tolerance to reduce memory usage</li><li><strong>Linear Approximation</strong>: Based on DC power flow assumptions (neglects voltage magnitudes and reactive power)</li><li><strong>Single Contingencies</strong>: Designed for single line outage analysis (N-1 contingencies)</li></ul><p><strong>Usage Notes</strong></p><ul><li>Access via <code>lodf[monitored_line, outaged_line]</code> returns sensitivity coefficient</li><li>Diagonal elements are always -1.0 representing complete flow loss on outaged line</li><li>Matrix sparsification improves performance but may introduce small numerical errors</li><li>Results valid under DC power flow assumptions and normal operating conditions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/32a38fe1050b7787d39da4653c300562fee085d9/src/lodf_calculations.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.LODF-Tuple{IncidenceMatrix, ABA_Matrix, BA_Matrix}"><a class="docstring-binding" href="#PowerNetworkMatrices.LODF-Tuple{IncidenceMatrix, ABA_Matrix, BA_Matrix}"><code>PowerNetworkMatrices.LODF</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">LODF(A, ABA, BA; linear_solver, tol)
</code></pre><pre><code class="language-julia hljs">LODF(A::IncidenceMatrix, ABA::ABA_Matrix, BA::BA_Matrix; linear_solver::String = &quot;KLU&quot;, tol::Float64 = eps())</code></pre><p>Construct a Line Outage Distribution Factor (LODF) matrix from incidence, ABA, and BA matrices. This constructor provides direct control over the underlying matrix computations and is most efficient when the prerequisite matrices with factorization are already available.</p><p><strong>Arguments</strong></p><ul><li><code>A::IncidenceMatrix</code>: The incidence matrix containing bus-branch connectivity information</li><li><code>ABA::ABA_Matrix</code>: The bus susceptance matrix (A^T * B * A), preferably with KLU factorization</li><li><code>BA::BA_Matrix</code>: The branch susceptance weighted incidence matrix (B * A)</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>linear_solver::String = &quot;KLU&quot;</code>:        Linear solver algorithm for matrix computations. Currently only &quot;KLU&quot; is supported</li><li><code>tol::Float64 = eps()</code>:        Sparsification tolerance for dropping small matrix elements</li></ul><p><strong>Returns</strong></p><ul><li><code>LODF</code>: The constructed LODF matrix structure with line outage sensitivity coefficients</li></ul><p><strong>Mathematical Computation</strong></p><p>This method computes LODF using the factorized form:</p><pre><code class="language-julia hljs">LODF = (A * ABA^(-1) * BA) / (1 - diag(A * ABA^(-1) * BA))</code></pre><p>where:</p><ul><li>A is the incidence matrix</li><li>ABA^(-1) uses the factorized form from the ABA matrix (requires <code>ABA.K</code> to be factorized)</li><li>BA is the susceptance-weighted incidence matrix</li></ul><p><strong>Requirements and Limitations</strong></p><ul><li><strong>Factorization Required</strong>: The ABA matrix should be pre-factorized (contains KLU factorization) for efficiency</li><li><strong>Single Slack Bus</strong>: This method does not support distributed slack bus configurations</li><li><strong>Network Consistency</strong>: All three input matrices must have equivalent network reduction states</li><li><strong>Solver Limitation</strong>: Currently only supports &quot;KLU&quot; linear solver</li></ul><p><strong>Performance Advantages</strong></p><ul><li><strong>Pre-factorization</strong>: Leverages existing KLU factorization in ABA matrix for maximum efficiency</li><li><strong>Direct Computation</strong>: Avoids intermediate PTDF calculation, reducing computational steps</li><li><strong>Memory Efficient</strong>: Works directly with sparse matrix structures throughout computation</li><li><strong>Numerical Stability</strong>: Uses numerically stable KLU solver for matrix operations</li></ul><p><strong>Error Handling</strong></p><ul><li>Validates network reduction consistency across all three input matrices</li><li>Raises error if matrices have mismatched reduction states</li><li>Validates linear solver selection (currently only &quot;KLU&quot; supported)</li></ul><p><strong>Usage Recommendations</strong></p><ul><li>Use this constructor when you have pre-computed and factorized matrices available</li><li>Ensure ABA matrix is factorized using <code>factorize(ABA)</code> or constructed with <code>factorize=true</code></li><li>For systems with distributed slack, use the PTDF-based constructor instead</li><li>Most efficient option for repeated LODF computations on the same network topology</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/32a38fe1050b7787d39da4653c300562fee085d9/src/lodf_calculations.jl#L355">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.LODF-Tuple{IncidenceMatrix, PTDF}"><a class="docstring-binding" href="#PowerNetworkMatrices.LODF-Tuple{IncidenceMatrix, PTDF}"><code>PowerNetworkMatrices.LODF</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">LODF(A, PTDFm; linear_solver, tol)
</code></pre><pre><code class="language-julia hljs">LODF(A::IncidenceMatrix, PTDFm::PTDF; linear_solver::String = &quot;KLU&quot;, tol::Float64 = eps())</code></pre><p>Construct a Line Outage Distribution Factor (LODF) matrix from existing incidence and PTDF matrices. This constructor is more efficient when the prerequisite matrices are already available.</p><p><strong>Arguments</strong></p><ul><li><code>A::IncidenceMatrix</code>: The incidence matrix containing bus-branch connectivity information</li><li><code>PTDFm::PTDF</code>: The power transfer distribution factor matrix (should be non-sparsified for accuracy)</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>linear_solver::String = &quot;KLU&quot;</code>:        Linear solver algorithm for matrix computations. Options: &quot;KLU&quot;, &quot;Dense&quot;, &quot;MKLPardiso&quot;</li><li><code>tol::Float64 = eps()</code>:        Sparsification tolerance for the LODF matrix (not applied to input PTDF)</li></ul><p><strong>Returns</strong></p><ul><li><code>LODF</code>: The constructed LODF matrix structure with line outage sensitivity coefficients</li></ul><p><strong>Mathematical Computation</strong></p><p>The LODF matrix is computed using the formula:</p><pre><code class="language-julia hljs">LODF = (A * PTDF) / (1 - diag(A * PTDF))</code></pre><p>where:</p><ul><li>A is the incidence matrix representing bus-branch connectivity</li><li>PTDF contains power transfer distribution factors</li><li>The denominator (1 - diagonal terms) accounts for the outaged line&#39;s own flow</li></ul><p><strong>Important Notes</strong></p><ul><li><strong>PTDF Sparsification</strong>: The input PTDF matrix should be non-sparsified (constructed with default tolerance) to avoid accuracy issues</li><li><strong>Tolerance Application</strong>: The <code>tol</code> parameter only affects LODF sparsification, not the input PTDF</li><li><strong>Network Consistency</strong>: Both input matrices must have equivalent network reduction states</li><li><strong>Diagonal Elements</strong>: Automatically set to -1.0 representing complete flow loss on outaged lines</li></ul><p><strong>Performance Considerations</strong></p><ul><li><strong>Matrix Validation</strong>: Warns if input PTDF was sparsified and converts to dense format for accuracy</li><li><strong>Memory Usage</strong>: Sparsification with <code>tol &gt; eps()</code> can significantly reduce memory requirements</li><li><strong>Computational Efficiency</strong>: More efficient than system-based constructor when matrices exist</li></ul><p><strong>Error Handling</strong></p><ul><li>Validates that incidence and PTDF matrices have consistent network reduction data</li><li>Issues warnings if sparsified PTDF matrices are used (potential accuracy issues)</li><li>Supports automatic conversion of sparse PTDF to dense format when necessary</li></ul><p><strong>Linear Solver Selection</strong></p><ul><li><strong>&quot;KLU&quot;</strong>: Recommended for most applications (sparse, numerically stable)</li><li><strong>&quot;Dense&quot;</strong>: Faster for smaller systems but higher memory usage</li><li><strong>&quot;MKLPardiso&quot;</strong>: Best performance for very large systems (requires MKL library)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/32a38fe1050b7787d39da4653c300562fee085d9/src/lodf_calculations.jl#L259">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.LODF-Tuple{PowerSystems.System}"><a class="docstring-binding" href="#PowerNetworkMatrices.LODF-Tuple{PowerSystems.System}"><code>PowerNetworkMatrices.LODF</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">LODF(sys; linear_solver, tol, network_reductions, kwargs...)
</code></pre><pre><code class="language-julia hljs">LODF(sys::PSY.System; linear_solver::String = &quot;KLU&quot;, tol::Float64 = eps(), network_reductions::Vector{NetworkReduction} = NetworkReduction[], kwargs...)</code></pre><p>Construct a Line Outage Distribution Factor (LODF) matrix from a PowerSystems.System by computing  the sensitivity of line flows to single line outages. This is the primary constructor for LODF  analysis starting from system data.</p><p><strong>Arguments</strong></p><ul><li><code>sys::PSY.System</code>: The power system from which to construct the LODF matrix</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>linear_solver::String = &quot;KLU&quot;</code>:        Linear solver algorithm for matrix computations. Options: &quot;KLU&quot;, &quot;Dense&quot;, &quot;MKLPardiso&quot;</li><li><code>tol::Float64 = eps()</code>:        Sparsification tolerance for dropping small matrix elements to reduce memory usage</li><li><code>network_reductions::Vector{NetworkReduction} = NetworkReduction[]</code>:        Vector of network reduction algorithms to apply before matrix construction</li><li><code>include_constant_impedance_loads::Bool=true</code>:        Whether to include constant impedance loads as shunt admittances in the network model</li><li><code>subnetwork_algorithm=iterative_union_find</code>:        Algorithm used for identifying electrical islands and connected components</li><li>Additional keyword arguments are passed to the underlying matrix constructors</li></ul><p><strong>Returns</strong></p><ul><li><code>LODF</code>: The constructed LODF matrix structure containing:<ul><li>Line-to-line outage sensitivity coefficients</li><li>Network topology information and branch identifiers</li><li>Sparsification tolerance and computational metadata</li></ul></li></ul><p><strong>Construction Process</strong></p><ol><li><strong>Ybus Construction</strong>: Creates system admittance matrix with specified reductions</li><li><strong>Incidence Matrix</strong>: Builds bus-branch connectivity matrix A</li><li><strong>BA Matrix</strong>: Computes branch susceptance weighted incidence matrix</li><li><strong>PTDF Calculation</strong>: Derives power transfer distribution factors</li><li><strong>LODF Computation</strong>: Calculates line outage distribution factors from PTDF</li><li><strong>Sparsification</strong>: Applies tolerance threshold to reduce matrix density</li></ol><p><strong>Linear Solver Options</strong></p><ul><li><strong>&quot;KLU&quot;</strong>: Sparse LU factorization (default, recommended for most cases)</li><li><strong>&quot;Dense&quot;</strong>: Dense matrix operations (faster for small systems)</li><li><strong>&quot;MKLPardiso&quot;</strong>: Intel MKL Pardiso solver (requires MKL, best for very large systems)</li></ul><p><strong>Mathematical Foundation</strong></p><p>The LODF matrix is computed using the relationship:</p><pre><code class="language-julia hljs">LODF = (A * PTDF) / (1 - diag(A * PTDF))</code></pre><p>where A is the incidence matrix and PTDF is the power transfer distribution factor matrix.</p><p><strong>Notes</strong></p><ul><li>Sparsification with <code>tol &gt; eps()</code> can significantly reduce memory usage</li><li>Network reductions can improve computational efficiency for large systems</li><li>Results are valid under DC power flow assumptions (linear approximation)</li><li>Diagonal elements are always -1.0 representing complete flow loss on outaged lines</li><li>For very large systems, consider using &quot;MKLPardiso&quot; solver with appropriate chunk size</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/32a38fe1050b7787d39da4653c300562fee085d9/src/lodf_calculations.jl#L185">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.NetworkReduction"><a class="docstring-binding" href="#PowerNetworkMatrices.NetworkReduction"><code>PowerNetworkMatrices.NetworkReduction</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NetworkReduction</code></pre><p>Abstract base type for all network reduction algorithms used in power network analysis. Network reductions are mathematical transformations that eliminate buses and branches  while preserving the electrical behavior of the remaining network elements.</p><p>Concrete implementations include:</p><ul><li><a href="../../tutorials/tutorial_RadialReduction/#RadialReduction"><code>RadialReduction</code></a>: Eliminates radial (dangling) buses and branches</li><li><a href="../../tutorials/tutorial_DegreeTwoReduction/#DegreeTwoReduction"><code>DegreeTwoReduction</code></a>: Eliminates buses with exactly two connections</li><li><a href="@ref"><code>WardReduction</code></a>: Reduces external buses while preserving study bus behavior</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/32a38fe1050b7787d39da4653c300562fee085d9/src/NetworkReduction.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.NetworkReductionData"><a class="docstring-binding" href="#PowerNetworkMatrices.NetworkReductionData"><code>PowerNetworkMatrices.NetworkReductionData</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NetworkReductionData</code></pre><p>Mutable struct containing all data mappings and metadata for network reduction operations. This structure tracks how buses and branches are mapped, combined, or eliminated during network reduction algorithms.</p><p><strong>Fields</strong></p><ul><li><code>irreducible_buses::Set{Int}</code>: Buses that cannot be reduced</li><li><code>bus_reduction_map::Dict{Int, Set{Int}}</code>: Maps retained buses to sets of eliminated buses</li><li><code>reverse_bus_search_map::Dict{Int, Int}</code>: Maps eliminated buses to their parent buses</li><li><code>direct_branch_map::Dict{Tuple{Int, Int}, PSY.ACTransmission}</code>: One-to-one branch mappings</li><li><code>reverse_direct_branch_map::Dict{PSY.ACTransmission, Tuple{Int, Int}}</code>: Reverse direct mappings</li><li><code>parallel_branch_map::Dict{Tuple{Int, Int}, BranchesParallel}</code>: Parallel branch combinations</li><li><code>reverse_parallel_branch_map::Dict{PSY.ACTransmission, Tuple{Int, Int}}</code>: Reverse parallel mappings</li><li><code>series_branch_map::Dict{Tuple{Int, Int}, BranchesSeries}</code>: Series branch combinations</li><li><code>reverse_series_branch_map::Dict{Any, Tuple{Int, Int}}</code>: Reverse series mappings</li><li><code>transformer3W_map::Dict{Tuple{Int, Int}, ThreeWindingTransformerWinding}</code>: Three-winding transformer mappings</li><li><code>reverse_transformer3W_map::Dict{ThreeWindingTransformerWinding, Tuple{Int, Int}}</code>: Reverse transformer mappings</li><li><code>removed_buses::Set{Int}</code>: Set of buses eliminated from the network</li><li><code>removed_arcs::Set{Tuple{Int, Int}}</code>: Set of arcs eliminated from the network</li><li><code>radial_arc_to_surviving_bus::Dict{Tuple{Int, Int}, Int}</code>: Maps final arcs in radial reduction chains to their surviving bus numbers</li><li><code>added_admittance_map::Dict{Int, Complex{Float32}}</code>: Admittances added to buses during reduction</li><li><code>added_branch_map::Dict{Tuple{Int, Int}, Complex{Float32}}</code>: New branches created during reduction</li><li><code>all_branch_maps_by_type::Dict{String, Any}</code>: Branch mappings organized by component type</li><li><code>reductions::ReductionContainer</code>: Container tracking applied reduction algorithms</li><li><code>name_to_arc_map::Dict{Type, DataStructures.SortedDict{String, Tuple{Tuple{Int, Int}, String}}}</code>: Lazily filled with the call to <a href="../internal/#PowerNetworkMatrices.populate_branch_maps_by_type!"><code>populate_branch_maps_by_type!</code></a>, maps string names to their corresponding arcs and the map where the arc can be found. Used in optimization models or power flow reporting after reductions are applied. It is possible to have repeated arcs for some names if case of serial or parallel combinations.</li><li><code>component_to_reduction_name_map::Dict{Type, Dict{String, String}}</code>: Lazily filled with the call to <a href="../internal/#PowerNetworkMatrices.populate_branch_maps_by_type!"><code>populate_branch_maps_by_type!</code></a>, maps component names to the names of the reduction entries used in name<em>to</em>arc_map. Used in optimization models for connecting component attributes (e.g. outages) to network reduction entries.</li><li><code>filters_applied::Dict{Type, Function}</code>: Filters applied when populating branch maps by type</li><li><code>direct_branch_name_map::Dict{String, Tuple{Int, Int}}</code>: Lazily filled, maps branch names to their corresponding arc tuples for direct branches</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/32a38fe1050b7787d39da4653c300562fee085d9/src/NetworkReductionData.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.PTDF"><a class="docstring-binding" href="#PowerNetworkMatrices.PTDF"><code>PowerNetworkMatrices.PTDF</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Structure containing the Power Transfer Distribution Factor (PTDF) matrix and related power system data.</p><p>The PTDF matrix contains sensitivity coefficients that quantify how power injections at buses affect the power flows on transmission lines. Each element PTDF[i,j] represents the incremental change in flow on line i due to a unit power injection at bus j, under DC power flow assumptions.</p><p><strong>Fields</strong></p><ul><li><code>data::M &lt;: AbstractArray{Float64, 2}</code>:       The PTDF matrix data stored in transposed form for computational efficiency.       Element (i,j) represents the sensitivity of line j flow to bus i injection</li><li><code>axes::Ax</code>:       Tuple containing (bus<em>numbers, branch</em>identifiers) for matrix dimensions</li><li><code>lookup::L &lt;: NTuple{2, Dict}</code>:       Tuple of dictionaries providing fast lookup from bus/branch identifiers to matrix indices</li><li><code>subnetwork_axes::Dict{Int, Ax}</code>:       Mapping from reference bus numbers to their corresponding subnetwork axes</li><li><code>tol::Base.RefValue{Float64}</code>:       Tolerance threshold used for matrix sparsification (elements below this value are dropped)</li><li><code>network_reduction_data::NetworkReductionData</code>:       Container for network reduction information applied during matrix construction</li></ul><p><strong>Mathematical Properties</strong></p><ul><li><strong>Matrix Form</strong>: PTDF[i,j] = ∂f<em>i/∂P</em>j where f<em>i is flow on line i, P</em>j is injection at bus j</li><li><strong>Dimensions</strong>: (n<em>buses × n</em>arcs) for all buses and impedance arcs</li><li><strong>Linear Superposition</strong>: Total flow = Σ(PTDF[i,j] × P<em>j) for all injections P</em>j</li><li><strong>Physical Meaning</strong>: Values represent the fraction of bus injection that flows through each line</li><li><strong>Reference Bus</strong>: Rows corresponding to reference buses are typically zero</li></ul><p><strong>Applications</strong></p><ul><li><strong>Power Flow Analysis</strong>: Rapid calculation of line flows for given injection patterns</li><li><strong>Sensitivity Studies</strong>: Evaluate impact of generation/load changes on transmission flows</li><li><strong>Congestion Management</strong>: Identify lines affected by specific injection changes</li><li><strong>Market Analysis</strong>: Support nodal pricing and transmission rights calculations</li><li><strong>Planning Studies</strong>: Assess transmission utilization under various scenarios</li></ul><p><strong>Computational Features</strong></p><ul><li><strong>Matrix Storage</strong>: Stored in transposed form (bus × branch) for efficient computation</li><li><strong>Sparsification</strong>: Small elements removed based on tolerance to reduce memory usage</li><li><strong>Reference Bus Handling</strong>: Reference bus injections automatically handled in calculations</li><li><strong>Distributed Slack</strong>: Supports distributed slack bus configurations for improved realism</li></ul><p><strong>Usage Notes</strong></p><ul><li>Access via <code>ptdf[bus, line]</code> returns the sensitivity coefficient</li><li>Matrix indexing uses bus numbers and branch identifiers</li><li>Sparsification improves memory efficiency but may introduce small numerical errors</li><li>Results valid under DC power flow assumptions (neglects voltage magnitudes and reactive power)</li><li>Reference bus choice affects the specific values but not the relative sensitivities</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/32a38fe1050b7787d39da4653c300562fee085d9/src/ptdf_calculations.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.PTDF-Tuple{AbstractString}"><a class="docstring-binding" href="#PowerNetworkMatrices.PTDF-Tuple{AbstractString}"><code>PowerNetworkMatrices.PTDF</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">PTDF(filename)
</code></pre><p>Deserialize a PTDF from an HDF5 file.</p><p><strong>Arguments</strong></p><ul><li><code>filename::AbstractString</code>: File containing a serialized PTDF.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/32a38fe1050b7787d39da4653c300562fee085d9/src/ptdf_calculations.jl#L72">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.PTDF-Tuple{IncidenceMatrix, BA_Matrix}"><a class="docstring-binding" href="#PowerNetworkMatrices.PTDF-Tuple{IncidenceMatrix, BA_Matrix}"><code>PowerNetworkMatrices.PTDF</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">PTDF(A, BA; dist_slack, linear_solver, tol)
</code></pre><pre><code class="language-julia hljs">PTDF(A::IncidenceMatrix, BA::BA_Matrix; dist_slack::Dict{Int, Float64} = Dict{Int, Float64}(), linear_solver = &quot;KLU&quot;, tol::Float64 = eps())</code></pre><p>Construct a Power Transfer Distribution Factor (PTDF) matrix from existing incidence and BA matrices. This constructor is more efficient when the prerequisite matrices are already available and provides direct control over the underlying matrix computations.</p><p><strong>Arguments</strong></p><ul><li><code>A::IncidenceMatrix</code>: The incidence matrix containing bus-branch connectivity information</li><li><code>BA::BA_Matrix</code>: The branch susceptance weighted incidence matrix (B × A)</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>dist_slack::Dict{Int, Float64} = Dict{Int, Float64}()</code>:       Dictionary mapping bus numbers to distributed slack participation factors.       Empty dictionary uses single slack bus (reference bus from matrices)</li><li><code>linear_solver::String = &quot;KLU&quot;</code>:       Linear solver algorithm for matrix computations. Options: &quot;KLU&quot;, &quot;Dense&quot;, &quot;MKLPardiso&quot;</li><li><code>tol::Float64 = eps()</code>:       Sparsification tolerance for dropping small matrix elements to reduce memory usage</li></ul><p><strong>Returns</strong></p><ul><li><code>PTDF</code>: The constructed PTDF matrix structure with injection-to-flow sensitivity coefficients</li></ul><p><strong>Mathematical Computation</strong></p><p>The PTDF matrix is computed using the relationship:</p><pre><code class="language-julia hljs">PTDF = (A^T × B × A)^(-1) × A^T × B</code></pre><p>where:</p><ul><li>A is the incidence matrix representing bus-branch connectivity</li><li>B is the diagonal susceptance matrix (embedded in BA matrix)</li><li>The computation involves solving the ABA linear system for efficiency</li></ul><p><strong>Distributed Slack Handling</strong></p><ul><li><strong>Single Slack</strong>: Uses reference bus identified from input matrices</li><li><strong>Distributed Slack</strong>: Applies participation factor corrections to final PTDF</li><li><strong>Automatic Processing</strong>: Dictionary converted to vector form matching matrix dimensions</li><li><strong>Validation</strong>: Ensures distributed slack bus numbers exist in the network</li><li><strong>Normalization</strong>: Participation factors automatically normalized to maintain power balance</li></ul><p><strong>Network Consistency Requirements</strong></p><ul><li><strong>Reduction Compatibility</strong>: Both input matrices must have equivalent network reduction states</li><li><strong>Reference Alignment</strong>: BA matrix reference buses determine the PTDF reference framework</li><li><strong>Topology Consistency</strong>: Matrices must represent the same network topology</li></ul><p><strong>Performance Considerations</strong></p><ul><li><strong>Matrix Reuse</strong>: More efficient when A and BA matrices are already computed</li><li><strong>Memory Management</strong>: Sparsification reduces storage requirements significantly</li><li><strong>Solver Selection</strong>: KLU recommended for sparse systems, Dense for small networks</li><li><strong>Computational Efficiency</strong>: Avoids redundant system matrix construction</li></ul><p><strong>Error Handling and Validation</strong></p><ul><li><strong>Matrix Compatibility</strong>: Validates that A and BA have consistent network reductions</li><li><strong>Slack Validation</strong>: Checks that distributed slack buses exist in the matrix structure</li><li><strong>Solver Validation</strong>: Ensures selected linear solver is supported and available</li><li><strong>Numerical Stability</strong>: Handles singular systems and provides informative error messages</li></ul><p><strong>Usage Recommendations</strong></p><ul><li><strong>Preferred Method</strong>: Use when incidence and BA matrices are already available</li><li><strong>Repeated Calculations</strong>: Ideal for multiple PTDF computations with different slack configurations</li><li><strong>Large Systems</strong>: Consider sparsification for memory efficiency</li><li><strong>Distributed Slack</strong>: Provides more realistic modeling of generator response to load changes</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/32a38fe1050b7787d39da4653c300562fee085d9/src/ptdf_calculations.jl#L390">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.PTDF-Tuple{PowerSystems.System}"><a class="docstring-binding" href="#PowerNetworkMatrices.PTDF-Tuple{PowerSystems.System}"><code>PowerNetworkMatrices.PTDF</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">PTDF(sys; dist_slack, linear_solver, tol, kwargs...)
</code></pre><pre><code class="language-julia hljs">PTDF(sys::PSY.System; dist_slack::Dict{Int, Float64} = Dict{Int, Float64}(), linear_solver = &quot;KLU&quot;, tol::Float64 = eps(), network_reductions::Vector{NetworkReduction} = NetworkReduction[], kwargs...)</code></pre><p>Construct a Power Transfer Distribution Factor (PTDF) matrix from a PowerSystems.System by computing the sensitivity of transmission line flows to bus power injections. This is the primary constructor for PTDF analysis starting from system data.</p><p><strong>Arguments</strong></p><ul><li><code>sys::PSY.System</code>: The power system from which to construct the PTDF matrix</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>dist_slack::Dict{Int, Float64} = Dict{Int, Float64}()</code>:       Dictionary mapping bus numbers to distributed slack weights for realistic slack modeling.       Empty dictionary uses single slack bus (default behavior)</li><li><code>linear_solver::String = &quot;KLU&quot;</code>:       Linear solver algorithm for matrix computations. Options: &quot;KLU&quot;, &quot;Dense&quot;, &quot;MKLPardiso&quot;</li><li><code>tol::Float64 = eps()</code>:       Sparsification tolerance for dropping small matrix elements to reduce memory usage</li><li><code>network_reductions::Vector{NetworkReduction} = NetworkReduction[]</code>:       Vector of network reduction algorithms to apply before matrix construction</li><li><code>include_constant_impedance_loads::Bool=true</code>:       Whether to include constant impedance loads as shunt admittances in the network model</li><li><code>subnetwork_algorithm=iterative_union_find</code>:       Algorithm used for identifying electrical islands and connected components</li><li>Additional keyword arguments are passed to the underlying matrix constructors</li></ul><p><strong>Returns</strong></p><ul><li><code>PTDF</code>: The constructed PTDF matrix structure containing:<ul><li>Bus-to-impedance-arc injection sensitivity coefficients</li><li>Network topology information and reference bus identification</li><li>Sparsification tolerance and computational metadata</li></ul></li></ul><p><strong>Construction Process</strong></p><ol><li><strong>Ybus Construction</strong>: Creates system admittance matrix with specified reductions</li><li><strong>Incidence Matrix</strong>: Builds bus-branch connectivity matrix A</li><li><strong>BA Matrix</strong>: Computes branch susceptance weighted incidence matrix</li><li><strong>PTDF Computation</strong>: Calculates power transfer distribution factors using A^T × B^(-1) × A</li><li><strong>Distributed Slack</strong>: Applies distributed slack correction if specified</li><li><strong>Sparsification</strong>: Removes small elements based on tolerance threshold</li></ol><p><strong>Distributed Slack Configuration</strong></p><ul><li><strong>Single Slack</strong>: Empty <code>dist_slack</code> dictionary uses conventional single slack bus</li><li><strong>Distributed Slack</strong>: Dictionary maps bus numbers to participation factors</li><li><strong>Normalization</strong>: Participation factors automatically normalized to sum to 1.0</li><li><strong>Physical Meaning</strong>: Distributed slack better represents generator response to load changes</li></ul><p><strong>Linear Solver Options</strong></p><ul><li><strong>&quot;KLU&quot;</strong>: Sparse LU factorization (default, recommended for most cases)</li><li><strong>&quot;Dense&quot;</strong>: Dense matrix operations (faster for small systems, higher memory usage)</li><li><strong>&quot;MKLPardiso&quot;</strong>: Intel MKL Pardiso solver (requires MKL library, best for very large systems)</li></ul><p><strong>Mathematical Foundation</strong></p><p>The PTDF matrix is computed as:</p><pre><code class="language-julia hljs">PTDF = (A^T × B × A)^(-1) × A^T × B</code></pre><p>where A is the incidence matrix and B is the susceptance matrix.</p><p><strong>Notes</strong></p><ul><li>Results are valid under DC power flow assumptions (linear approximation)</li><li>Reference bus selection affects specific values but not relative sensitivities</li><li>Sparsification with <code>tol &gt; eps()</code> can significantly reduce memory usage</li><li>Network reductions improve computational efficiency for large systems</li><li>Distributed slack provides more realistic representation of system response</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/32a38fe1050b7787d39da4653c300562fee085d9/src/ptdf_calculations.jl#L239">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.PTDF-Tuple{Ybus}"><a class="docstring-binding" href="#PowerNetworkMatrices.PTDF-Tuple{Ybus}"><code>PowerNetworkMatrices.PTDF</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">PTDF(ybus; dist_slack, linear_solver, tol)
</code></pre><pre><code class="language-julia hljs">PTDF(ybus::Ybus; dist_slack::Dict{Int, Float64} = Dict{Int, Float64}(), linear_solver = &quot;KLU&quot;, tol::Float64 = eps(), network_reductions::Vector{NetworkReduction} = NetworkReduction[], kwargs...)</code></pre><p>Construct a Power Transfer Distribution Factor (PTDF) matrix from existing Ybus matrix. This constructor is more efficient when the prerequisite matrices are already available and provides direct control over the underlying matrix computations.</p><p><strong>Arguments</strong></p><ul><li><code>ybus::Ybus</code>: The power system Ybus matrix from which to construct the PTDF matrix </li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>dist_slack::Dict{Int, Float64} = Dict{Int, Float64}()</code>:       Dictionary mapping bus numbers to distributed slack weights for realistic slack modeling.       Empty dictionary uses single slack bus (default behavior)</li><li><code>linear_solver::String = &quot;KLU&quot;</code>:       Linear solver algorithm for matrix computations. Options: &quot;KLU&quot;, &quot;Dense&quot;, &quot;MKLPardiso&quot;</li><li><code>tol::Float64 = eps()</code>:       Sparsification tolerance for dropping small matrix elements to reduce memory usage</li></ul><p><strong>Returns</strong></p><ul><li><code>PTDF</code>: The constructed PTDF matrix structure containing:<ul><li>Bus-to-impedance-arc injection sensitivity coefficients</li><li>Network topology information and reference bus identification</li><li>Sparsification tolerance and computational metadata</li></ul></li></ul><p><strong>Construction Process</strong></p><ol><li><strong>Incidence Matrix</strong>: Builds bus-branch connectivity matrix A (from Ybus matrix)</li><li><strong>BA Matrix</strong>: Computes branch susceptance weighted incidence matrix</li><li><strong>PTDF Computation</strong>: Calculates power transfer distribution factors using A^T × B^(-1) × A</li><li><strong>Distributed Slack</strong>: Applies distributed slack correction if specified</li><li><strong>Sparsification</strong>: Removes small elements based on tolerance threshold</li></ol><p><strong>Distributed Slack Configuration</strong></p><ul><li><strong>Single Slack</strong>: Empty <code>dist_slack</code> dictionary uses conventional single slack bus</li><li><strong>Distributed Slack</strong>: Dictionary maps bus numbers to participation factors</li><li><strong>Normalization</strong>: Participation factors automatically normalized to sum to 1.0</li><li><strong>Physical Meaning</strong>: Distributed slack better represents generator response to load changes</li></ul><p><strong>Linear Solver Options</strong></p><ul><li><strong>&quot;KLU&quot;</strong>: Sparse LU factorization (default, recommended for most cases)</li><li><strong>&quot;Dense&quot;</strong>: Dense matrix operations (faster for small systems, higher memory usage)</li><li><strong>&quot;MKLPardiso&quot;</strong>: Intel MKL Pardiso solver (requires MKL library, best for very large systems)</li></ul><p><strong>Mathematical Foundation</strong></p><p>The PTDF matrix is computed as:</p><pre><code class="language-julia hljs">PTDF = (A^T × B × A)^(-1) × A^T × B</code></pre><p>where A is the incidence matrix and B is the susceptance matrix.</p><p><strong>Notes</strong></p><ul><li>Results are valid under DC power flow assumptions (linear approximation)</li><li>Reference bus selection affects specific values but not relative sensitivities</li><li>Sparsification with <code>tol &gt; eps()</code> can significantly reduce memory usage</li><li>Network reductions improve computational efficiency for large systems</li><li>Distributed slack provides more realistic representation of system response</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/32a38fe1050b7787d39da4653c300562fee085d9/src/ptdf_calculations.jl#L317">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.RadialReduction"><a class="docstring-binding" href="#PowerNetworkMatrices.RadialReduction"><code>PowerNetworkMatrices.RadialReduction</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RadialReduction &lt;: NetworkReduction</code></pre><p>Network reduction algorithm that eliminates radial (dangling) buses and their associated branches from the power network. Radial buses are leaf nodes with only one connection that do not affect the electrical behavior of the rest of the network.</p><p><strong>Fields</strong></p><ul><li><code>irreducible_buses::Vector{Int}</code>: List of bus numbers that should not be eliminated even if they are radial</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create radial reduction with no protected buses
reduction = RadialReduction()

# Create radial reduction protecting specific buses
reduction = RadialReduction(irreducible_buses=[101, 205])

# Apply to system
ybus = Ybus(system; network_reductions=[reduction])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/32a38fe1050b7787d39da4653c300562fee085d9/src/radial_reduction.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.VirtualLODF"><a class="docstring-binding" href="#PowerNetworkMatrices.VirtualLODF"><code>PowerNetworkMatrices.VirtualLODF</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>The Virtual Line Outage Distribution Factor (VirtualLODF) structure gathers the rows of the LODF matrix as they are evaluated on-the-go. These rows are evaluated independently, cached in the structure and do not require the computation of the whole matrix (therefore significantly reducing the computational requirements).</p><p>The VirtualLODF is initialized with no row stored.</p><p>The VirtualLODF struct is indexed using branch names.</p><p><strong>Arguments</strong></p><ul><li><code>K::KLU.KLUFactorization{Float64, Int}</code>:       LU factorization matrices of the ABA matrix, evaluated by means of KLU.</li><li><code>BA::SparseArrays.SparseMatrixCSC{Float64, Int}</code>:       BA matrix.</li><li><code>A::SparseArrays.SparseMatrixCSC{Int8, Int}</code>:       Incidence matrix.</li><li><code>inv_PTDF_A_diag::Vector{Float64}</code>:       Vector contiaining the element-wise reciprocal of the diagonal elements       coming from multuiplying the PTDF matrix with th Incidence matrix</li><li><code>ref_bus_positions::Set{Int}</code>:       Vector containing the indexes of the rows of the transposed BA matrix       corresponding to the reference buses.</li><li><code>dist_slack::Vector{Float64}</code>:       Vector of weights to be used as distributed slack bus.       The distributed slack vector has to be the same length as the number of buses.</li><li><code>axes&lt;:NTuple{2, Dict}</code>:       Tuple containing two vectors showing the branch names.</li><li><code>lookup&lt;:NTuple{2, Dict}</code>:       Tuple containing two dictionaries, mapping the branches names       the enumerated row indexes indexes.</li><li><code>valid_ix::Vector{Int}</code>:       Vector containing the row/columns indices of matrices related the buses       which are not slack ones.</li><li><code>temp_data::Vector{Float64}</code>:       Temporary vector for internal use.</li><li><code>cache::RowCache</code>:       Cache were LODF rows are stored.</li><li><code>subnetworks::Dict{Int, Set{Int}}</code>:       Dictionary containing the subsets of buses defining the different subnetwork of the system.</li><li><code>tol::Base.RefValue{Float64}</code>:       Tolerance related to scarification and values to drop.</li><li><code>network_reduction::NetworkReduction</code>:       Structure containing the details of the network reduction applied when computing the matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/32a38fe1050b7787d39da4653c300562fee085d9/src/virtual_lodf_calculations.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.VirtualLODF-Tuple{PowerSystems.System}"><a class="docstring-binding" href="#PowerNetworkMatrices.VirtualLODF-Tuple{PowerSystems.System}"><code>PowerNetworkMatrices.VirtualLODF</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">VirtualLODF(
    sys;
    dist_slack,
    tol,
    max_cache_size,
    persistent_arcs,
    network_reductions,
    kwargs...
)
</code></pre><p>Builds the Virtual LODF matrix from a system. The return is a VirtualLODF struct with an empty cache.</p><p><strong>Arguments</strong></p><ul><li><code>sys::PSY.System</code>:       PSY system for which the matrix is constructed</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>network_reduction::NetworkReduction</code>:       Structure containing the details of the network reduction applied when computing the matrix</li><li><code>kwargs...</code>:       other keyword arguments used by VirtualPTDF</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/32a38fe1050b7787d39da4653c300562fee085d9/src/virtual_lodf_calculations.jl#L116">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.VirtualPTDF"><a class="docstring-binding" href="#PowerNetworkMatrices.VirtualPTDF"><code>PowerNetworkMatrices.VirtualPTDF</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>The Virtual Power Transfer Distribution Factor (VirtualPTDF) structure gathers the rows of the PTDF matrix as they are evaluated on-the-go. These rows are evaluated independently, cached in the structure and do not require the computation of the whole matrix (therefore significantly reducing the computational requirements).</p><p>The VirtualPTDF is initialized with no row stored.</p><p>The VirtualPTDF is indexed using branch names and bus numbers as for the PTDF matrix.</p><p><strong>Arguments</strong></p><ul><li><code>K::Union{KLU.KLUFactorization{Float64, Int}, AppleAccelerate.AAFactorization{Float64}}</code>:       LU factorization matrices of the ABA matrix, evaluated by means of KLU or AppleAccelerate</li><li><code>BA::SparseArrays.SparseMatrixCSC{Float64, Int}</code>:       BA matrix</li><li><code>ref_bus_positions::Set{Int}</code>:       Vector containing the indexes of the columns of the BA matrix corresponding       to the reference buses</li><li><code>dist_slack::Vector{Float64}</code>:       Vector of weights to be used as distributed slack bus.       The distributed slack vector has to be the same length as the number of buses.</li><li><code>axes&lt;:NTuple{2, Dict}</code>:       Tuple containing two vectors: the first one showing the branches names,       the second showing the buses numbers. There is no link between the       order of the vector of the branches names and the way the PTDF rows are       stored in the cache.</li><li><code>lookup&lt;:NTuple{2, Dict}</code>:       Tuple containing two dictionaries, mapping the branches       and buses with their enumerated indexes. The branch indexes refer to       the key of the cache dictionary. The bus indexes refer to the position       of the elements in the PTDF row stored.</li><li><code>temp_data::Vector{Float64}</code>:       Temporary vector for internal use.</li><li><code>valid_ix::Vector{Int}</code>:       Vector containing the row/columns indices of matrices related the buses       which are not slack ones.</li><li><code>cache::RowCache</code>:       Cache were PTDF rows are stored.</li><li><code>subnetworks::Dict{Int, Set{Int}}</code>:       Dictionary containing the subsets of buses defining the different subnetwork of the system.</li><li><code>tol::Base.RefValue{Float64}</code>:       Tolerance related to scarification and values to drop.</li><li><code>network_reduction::NetworkReduction</code>:       Structure containing the details of the network reduction applied when computing the matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/32a38fe1050b7787d39da4653c300562fee085d9/src/virtual_ptdf_calculations.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.VirtualPTDF-Tuple{PowerSystems.System}"><a class="docstring-binding" href="#PowerNetworkMatrices.VirtualPTDF-Tuple{PowerSystems.System}"><code>PowerNetworkMatrices.VirtualPTDF</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">VirtualPTDF(
    sys;
    dist_slack,
    linear_solver,
    tol,
    max_cache_size,
    persistent_arcs,
    network_reductions,
    kwargs...
)
</code></pre><p>Builds the Virtual PTDF matrix from a system. The return is a VirtualPTDF struct with an empty cache.</p><p><strong>Arguments</strong></p><ul><li><code>sys::PSY.System</code>:       PSY system for which the matrix is constructed</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>dist_slack::Dict{Int, Float64} = Dict{Int, Float64}()</code>:       Dictionary of weights to be used as distributed slack bus.       The distributed slack dictionary must have the same number of entries as the number of buses.</li><li><code>linear_solver::String = &quot;KLU&quot;</code>:       Linear solver to use for factorization. Options: &quot;KLU&quot;, &quot;AppleAccelerate&quot;</li><li><code>tol::Float64 = eps()</code>:       Tolerance related to sparsification and values to drop.</li><li><code>max_cache_size::Int</code>:       max cache size in MiB (initialized as MAX<em>CACHE</em>SIZE_MiB).</li><li><code>persistent_arcs::Vector{Tuple{Int, Int}} = Vector{Tuple{Int, Int}}()</code>:       arcs to be evaluated as soon as the VirtualPTDF is created (initialized as empty vector of tuples).</li><li><code>network_reduction::NetworkReduction</code>:       Structure containing the details of the network reduction applied when computing the matrix</li><li><code>kwargs...</code>:       other keyword arguments used by VirtualPTDF</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/32a38fe1050b7787d39da4653c300562fee085d9/src/virtual_ptdf_calculations.jl#L82">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.VirtualPTDF-Tuple{Ybus}"><a class="docstring-binding" href="#PowerNetworkMatrices.VirtualPTDF-Tuple{Ybus}"><code>PowerNetworkMatrices.VirtualPTDF</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">VirtualPTDF(
    ybus;
    dist_slack,
    linear_solver,
    tol,
    max_cache_size,
    persistent_arcs
)
</code></pre><p>Builds the Virtual PTDF matrix from a Ybus matrix. This constructor is more efficient when the prerequisite Ybus matrix is already available and provides direct control over the underlying matrix computations (including network reductions).   The return is a VirtualPTDF struct with an empty cache. </p><p><strong>Arguments</strong></p><ul><li><code>ybus::Ybus</code>: Ybus matrix from which the matrix is constructed</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>dist_slack::Dict{Int, Float64} = Dict{Int, Float64}()</code>:       Dictionary of weights to be used as distributed slack bus.       The distributed slack dictionary must have the same number of entries as the number of buses.</li><li><code>linear_solver::String = &quot;KLU&quot;</code>:       Linear solver to use for factorization. Options: &quot;KLU&quot;, &quot;AppleAccelerate&quot;</li><li><code>tol::Float64 = eps()</code>:       Tolerance related to sparsification and values to drop.</li><li><code>max_cache_size::Int</code>:       max cache size in MiB (initialized as MAX<em>CACHE</em>SIZE_MiB).</li><li><code>persistent_arcs::Vector{Tuple{Int, Int}} = Vector{Tuple{Int, Int}}()</code>:       arcs to be evaluated as soon as the VirtualPTDF is created (initialized as empty vector of tuples).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/32a38fe1050b7787d39da4653c300562fee085d9/src/virtual_ptdf_calculations.jl#L133">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.Ybus"><a class="docstring-binding" href="#PowerNetworkMatrices.Ybus"><code>PowerNetworkMatrices.Ybus</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Ybus{Ax, L &lt;: NTuple{2, Dict}} &lt;: PowerNetworkMatrix{ComplexF32}</code></pre><p>Nodal admittance matrix (Y-bus) representing the electrical admittance relationships between buses in a power system. This N×N sparse complex matrix encodes the network topology and electrical parameters needed for power flow calculations and network analysis.</p><p><strong>Fields</strong></p><ul><li><code>data::SparseArrays.SparseMatrixCSC{ComplexF32, Int}</code>: Sparse Y-bus matrix with complex admittance values</li><li><code>adjacency_data::SparseArrays.SparseMatrixCSC{Int8, Int}</code>: Network connectivity information</li><li><code>axes::Ax</code>: Tuple of bus axis vectors for indexing (bus<em>numbers, bus</em>numbers)</li><li><code>lookup::L</code>: Tuple of lookup dictionaries mapping bus numbers to matrix indices</li><li><code>subnetwork_axes::Dict{Int, Ax}</code>: Bus axes for each electrical island/subnetwork</li><li><code>arc_subnetwork_axis::Dict{Int, Vector{Tuple{Int, Int}}}</code>: Arc axes for each subnetwork</li><li><code>network_reduction_data::NetworkReductionData</code>: Metadata from network reduction operations</li><li><code>arc_admittance_from_to::Union{ArcAdmittanceMatrix, Nothing}</code>: From-to arc admittance matrix</li><li><code>arc_admittance_to_from::Union{ArcAdmittanceMatrix, Nothing}</code>: To-from arc admittance matrix</li></ul><p><strong>Key Features</strong></p><ul><li>Indexed by bus numbers (non-sequential numbering supported)</li><li>Supports network reductions (radial, degree-two, Ward)</li><li>Handles multiple electrical islands/subnetworks</li><li>Optional arc admittance matrices for power flow calculations</li><li>Sparse matrix representation for computational efficiency</li></ul><p><strong>Usage</strong></p><p>The Y-bus is fundamental for:</p><ul><li>Power flow analysis: V = Y⁻¹I</li><li>Short circuit calculations</li><li>Network impedance analysis</li><li>Sensitivity analysis (PTDF/LODF)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Basic Y-bus construction
ybus = Ybus(system)

# With arc admittance matrices for power flow
ybus = Ybus(system; make_arc_admittance_matrices=true)

# With network reductions
ybus = Ybus(system; network_reductions=[RadialReduction(), DegreeTwoReduction()])</code></pre><p><strong>See Also</strong></p><ul><li><a href="#PowerNetworkMatrices.PTDF"><code>PTDF</code></a>: Power Transfer Distribution Factors</li><li><a href="#PowerNetworkMatrices.LODF"><code>LODF</code></a>: Line Outage Distribution Factors</li><li><a href="#PowerNetworkMatrices.NetworkReduction"><code>NetworkReduction</code></a>: Network reduction algorithms</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/32a38fe1050b7787d39da4653c300562fee085d9/src/Ybus.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.Ybus-Tuple{PowerSystems.System}"><a class="docstring-binding" href="#PowerNetworkMatrices.Ybus-Tuple{PowerSystems.System}"><code>PowerNetworkMatrices.Ybus</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Ybus(
    sys;
    make_arc_admittance_matrices,
    network_reductions,
    include_constant_impedance_loads,
    subnetwork_algorithm
)
</code></pre><pre><code class="language-julia hljs">Ybus(
    sys::PSY.System;
    make_arc_admittance_matrices::Bool = false,
    network_reductions::Vector{NetworkReduction} = NetworkReduction[],
    include_constant_impedance_loads::Bool = true,
    subnetwork_algorithm = iterative_union_find,
    kwargs...
) -&gt; Ybus</code></pre><p>Construct a nodal admittance matrix (Y-bus) from a power system.</p><p>Builds the sparse complex Y-bus matrix representing the electrical admittance relationships between buses in the power system. Handles AC branches, transformers, shunt elements, and network reductions while maintaining connectivity analysis.</p><p><strong>Arguments</strong></p><ul><li><code>sys::PSY.System</code>: Power system to build Y-bus from</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>make_arc_admittance_matrices::Bool=false</code>: Whether to construct arc admittance matrices for power flow</li><li><code>network_reductions::Vector{NetworkReduction}=[]</code>: Network reduction algorithms to apply</li><li><code>include_constant_impedance_loads::Bool=true</code>: Whether to include constant impedance loads as shunt admittances</li><li><code>subnetwork_algorithm=iterative_union_find</code>: Algorithm for finding electrical islands</li></ul><p><strong>Returns</strong></p><ul><li><code>Ybus</code>: Constructed Y-bus matrix with network topology and electrical parameters</li></ul><p><strong>Features</strong></p><ul><li><strong>Branch Support</strong>: Lines, transformers, phase shifters, three-winding transformers</li><li><strong>Shunt Elements</strong>: Fixed admittances, switched admittances, constant impedance loads</li><li><strong>Network Reductions</strong>: Radial, degree-two, Ward reductions for computational efficiency</li><li><strong>Multiple Islands</strong>: Handles disconnected network components with separate reference buses</li><li><strong>Branch Matrices</strong>: Optional from-to/to-from admittance matrices for power flow calculations</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Basic Y-bus construction
ybus = Ybus(system)

# With arc admittance matrices for power flow
ybus = Ybus(system; make_arc_admittance_matrices=true)

# Apply network reductions for computational efficiency
reductions = [RadialReduction(), DegreeTwoReduction()]
ybus = Ybus(system; network_reductions=reductions)

# Exclude constant impedance loads
ybus = Ybus(system; include_constant_impedance_loads=false)</code></pre><p><strong>See Also</strong></p><ul><li><a href="#PowerNetworkMatrices.NetworkReduction"><code>NetworkReduction</code></a>: Network reduction algorithms</li><li><a href="#PowerNetworkMatrices.PTDF"><code>PTDF</code></a>: Power transfer distribution factors</li><li><a href="#PowerNetworkMatrices.LODF"><code>LODF</code></a>: Line outage distribution factors</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/32a38fe1050b7787d39da4653c300562fee085d9/src/Ybus.jl#L732">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.depth_first_search-Tuple{SparseArrays.SparseMatrixCSC, Vector{Int64}}"><a class="docstring-binding" href="#PowerNetworkMatrices.depth_first_search-Tuple{SparseArrays.SparseMatrixCSC, Vector{Int64}}"><code>PowerNetworkMatrices.depth_first_search</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">depth_first_search(M, bus_numbers)
</code></pre><pre><code class="language-julia hljs">depth_first_search(M::SparseArrays.SparseMatrixCSC, bus_numbers::Vector{Int})</code></pre><p>Find connected subnetworks using depth-first search algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>M::SparseArrays.SparseMatrixCSC</code>: Sparse matrix representing network connectivity</li><li><code>bus_numbers::Vector{Int}</code>: Vector containing the bus numbers of the system</li></ul><p><strong>Returns</strong></p><ul><li><code>Dict{Int, Set{Int}}</code>: Dictionary mapping representative bus numbers to sets of connected buses</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/32a38fe1050b7787d39da4653c300562fee085d9/src/connectivity_checks.jl#L168">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.factorize-Union{Tuple{ABA_Matrix{Ax, L, Nothing}}, Tuple{L}, Tuple{Ax}} where {Ax, L&lt;:Tuple{Dict, Dict}}"><a class="docstring-binding" href="#PowerNetworkMatrices.factorize-Union{Tuple{ABA_Matrix{Ax, L, Nothing}}, Tuple{L}, Tuple{Ax}} where {Ax, L&lt;:Tuple{Dict, Dict}}"><code>PowerNetworkMatrices.factorize</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">factorize(ABA)
</code></pre><p>Evaluates the LU factorization matrices of the ABA matrix, using KLU.</p><p><strong>Arguments</strong></p><ul><li><code>ABA::ABA_Matrix{Ax, L, Nothing} where {Ax, L &lt;: NTuple{2, Dict}}</code>:       container for the ABA matrix, with ABA.K == nothing (LU matrices in K not evaluated)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/32a38fe1050b7787d39da4653c300562fee085d9/src/BA_ABA_matrices.jl#L327">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.find_subnetworks-Tuple{AdjacencyMatrix}"><a class="docstring-binding" href="#PowerNetworkMatrices.find_subnetworks-Tuple{AdjacencyMatrix}"><code>PowerNetworkMatrices.find_subnetworks</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">find_subnetworks(M)
</code></pre><p>Evaluates subnetworks by looking for the subsets of buses connected each other, but not connected with buses of other subsets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/32a38fe1050b7787d39da4653c300562fee085d9/src/AdjacencyMatrix.jl#L254">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.find_subnetworks-Tuple{PowerSystems.System}"><a class="docstring-binding" href="#PowerNetworkMatrices.find_subnetworks-Tuple{PowerSystems.System}"><code>PowerNetworkMatrices.find_subnetworks</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">find_subnetworks(sys)
</code></pre><p>Finds the subnetworks in a system using Depth First Search (DFS). Returns a dictionary keyed by the reference bus of the subnetworks if they exist</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/32a38fe1050b7787d39da4653c300562fee085d9/src/system_utils.jl#L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.find_subnetworks-Tuple{SparseArrays.SparseMatrixCSC, Vector{Int64}}"><a class="docstring-binding" href="#PowerNetworkMatrices.find_subnetworks-Tuple{SparseArrays.SparseMatrixCSC, Vector{Int64}}"><code>PowerNetworkMatrices.find_subnetworks</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">find_subnetworks(M, bus_numbers; subnetwork_algorithm)
</code></pre><p>Finds the subnetworks present in the considered System. This is evaluated by taking a the ABA or Adjacency Matrix.</p><p><strong>Arguments</strong></p><ul><li><code>M::SparseArrays.SparseMatrixCSC</code>:       input sparse matrix.</li><li><code>bus_numbers::Vector{Int}</code>:       vector containing the indices of the system&#39;s buses.</li><li><code>subnetwork_algorithm::Function</code>:       algorithm for computing subnetworks. Valid options are iterative<em>union</em>find (default) and depth<em>first</em>search</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/32a38fe1050b7787d39da4653c300562fee085d9/src/connectivity_checks.jl#L223">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.find_subnetworks-Tuple{Ybus}"><a class="docstring-binding" href="#PowerNetworkMatrices.find_subnetworks-Tuple{Ybus}"><code>PowerNetworkMatrices.find_subnetworks</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">find_subnetworks(M)
</code></pre><pre><code class="language-julia hljs">find_subnetworks(M::Ybus) -&gt; Dict{Int, Set{Int}}</code></pre><p>Identify electrical islands (subnetworks) in the Y-bus matrix.</p><p>Analyzes the network topology to find groups of buses that are electrically connected to each other but isolated from other groups. Each subnetwork represents an electrical island that requires its own reference bus and can be solved independently.</p><p><strong>Arguments</strong></p><ul><li><code>M::Ybus</code>: Y-bus matrix to analyze</li></ul><p><strong>Returns</strong></p><ul><li><code>Dict{Int, Set{Int}}</code>: Dictionary mapping reference bus numbers to sets of bus numbers in each subnetwork</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">ybus = Ybus(system)
subnetworks = find_subnetworks(ybus)
for (ref_bus, buses) in subnetworks
    println(&quot;Island &quot;, ref_bus, &quot;: &quot;, sort(collect(buses)))
end

if length(subnetworks) &gt; 1
    @warn &quot;Network has &quot;, length(subnetworks), &quot; electrical islands&quot;
end</code></pre><p><strong>Implementation Details</strong></p><ul><li>Uses adjacency matrix analysis to find connected components</li><li>Each subnetwork gets assigned a reference bus for voltage angle reference</li><li>Isolated buses or groups require separate power flow analysis</li><li>Critical for power flow initialization and solution</li></ul><p><strong>See Also</strong></p><ul><li><a href="#PowerNetworkMatrices.validate_connectivity-Tuple{AdjacencyMatrix}"><code>validate_connectivity</code></a>: Check for full connectivity</li><li><a href="#PowerNetworkMatrices.depth_first_search-Tuple{SparseArrays.SparseMatrixCSC, Vector{Int64}}"><code>depth_first_search</code></a>: Graph traversal algorithm</li><li><a href="#PowerNetworkMatrices.iterative_union_find-Tuple{SparseArrays.SparseMatrixCSC, Vector{Int64}}"><code>iterative_union_find</code></a>: Alternative connectivity algorithm</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/32a38fe1050b7787d39da4653c300562fee085d9/src/Ybus.jl#L1816">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.from_hdf5-Tuple{Type{PTDF}, AbstractString}"><a class="docstring-binding" href="#PowerNetworkMatrices.from_hdf5-Tuple{Type{PTDF}, AbstractString}"><code>PowerNetworkMatrices.from_hdf5</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">from_hdf5(_, filename)
</code></pre><p>Deserialize a PTDF from an HDF5 file.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{PTDF}</code>:</li><li><code>filename::AbstractString</code>: File containing a serialized PTDF.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/32a38fe1050b7787d39da4653c300562fee085d9/src/serialization.jl#L47">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.get_bus_reduction_map-Tuple{NetworkReductionData}"><a class="docstring-binding" href="#PowerNetworkMatrices.get_bus_reduction_map-Tuple{NetworkReductionData}"><code>PowerNetworkMatrices.get_bus_reduction_map</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_bus_reduction_map(rb)
</code></pre><pre><code class="language-julia hljs">get_bus_reduction_map(rb::NetworkReductionData)</code></pre><p>Get the bus reduction map from NetworkReductionData.</p><p><strong>Arguments</strong></p><ul><li><code>rb::NetworkReductionData</code>: The network reduction data</li></ul><p><strong>Returns</strong></p><ul><li><code>Dict{Int, Set{Int}}</code>: Dictionary mapping retained buses to sets of removed buses</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/32a38fe1050b7787d39da4653c300562fee085d9/src/NetworkReductionData.jl#L313">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.get_lodf_data-Tuple{LODF}"><a class="docstring-binding" href="#PowerNetworkMatrices.get_lodf_data-Tuple{LODF}"><code>PowerNetworkMatrices.get_lodf_data</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_lodf_data(lodf)
</code></pre><pre><code class="language-julia hljs">get_lodf_data(lodf::LODF)</code></pre><p>Extract the LODF matrix data in the standard orientation (non-transposed).</p><p><strong>Arguments</strong></p><ul><li><code>lodf::LODF</code>: The LODF structure from which to extract data</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractArray{Float64, 2}</code>: The LODF matrix data with standard orientation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/32a38fe1050b7787d39da4653c300562fee085d9/src/lodf_calculations.jl#L475">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.get_ptdf_data-Tuple{PTDF}"><a class="docstring-binding" href="#PowerNetworkMatrices.get_ptdf_data-Tuple{PTDF}"><code>PowerNetworkMatrices.get_ptdf_data</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_ptdf_data(ptdf)
</code></pre><pre><code class="language-julia hljs">get_ptdf_data(ptdf::PTDF)</code></pre><p>Extract the PTDF matrix data in the standard orientation (non-transposed).</p><p><strong>Arguments</strong></p><ul><li><code>ptdf::PTDF</code>: The PTDF structure from which to extract data</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractArray{Float64, 2}</code>: The PTDF matrix data with standard orientation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/32a38fe1050b7787d39da4653c300562fee085d9/src/ptdf_calculations.jl#L526">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.get_reductions-Tuple{NetworkReductionData}"><a class="docstring-binding" href="#PowerNetworkMatrices.get_reductions-Tuple{NetworkReductionData}"><code>PowerNetworkMatrices.get_reductions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_reductions(rb)
</code></pre><pre><code class="language-julia hljs">get_reductions(rb::NetworkReductionData)</code></pre><p>Get the reduction container from NetworkReductionData.</p><p><strong>Arguments</strong></p><ul><li><code>rb::NetworkReductionData</code>: The network reduction data</li></ul><p><strong>Returns</strong></p><ul><li><code>ReductionContainer</code>: Container with the applied network reductions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/32a38fe1050b7787d39da4653c300562fee085d9/src/NetworkReductionData.jl#L341">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.get_ward_reduction-Tuple{SparseArrays.SparseMatrixCSC{ComplexF32, Int64}, Dict{Int64, Int64}, Vector{Int64}, Set{Int64}, Set{Int64}, Vector{Int64}}"><a class="docstring-binding" href="#PowerNetworkMatrices.get_ward_reduction-Tuple{SparseArrays.SparseMatrixCSC{ComplexF32, Int64}, Dict{Int64, Int64}, Vector{Int64}, Set{Int64}, Set{Int64}, Vector{Int64}}"><code>PowerNetworkMatrices.get_ward_reduction</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_ward_reduction(
    data,
    bus_lookup,
    bus_axis,
    boundary_buses,
    ref_bus_numbers,
    study_buses
)
</code></pre><pre><code class="language-julia hljs">get_ward_reduction(data, bus_lookup, bus_axis, boundary_buses, ref_bus_numbers, study_buses)</code></pre><p>Perform Ward reduction to create an equivalent network representation.</p><p>Ward reduction is a network reduction technique that eliminates external buses while preserving  the electrical characteristics seen from the study buses. External buses are mapped to boundary  buses based on impedance criteria, and equivalent admittances are computed.</p><p><strong>Arguments</strong></p><ul><li><code>data::SparseArrays.SparseMatrixCSC{ComplexF32, Int}</code>: Admittance matrix of the system</li><li><code>bus_lookup::Dict{Int, Int}</code>: Dictionary mapping bus numbers to matrix indices</li><li><code>bus_axis::Vector{Int}</code>: Vector of all bus numbers in the system</li><li><code>boundary_buses::Set{Int}</code>: Set of boundary bus numbers between study and external areas</li><li><code>ref_bus_numbers::Set{Int}</code>: Set of reference bus numbers</li><li><code>study_buses::Vector{Int}</code>: Vector of study bus numbers to retain</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple</code>: Contains bus reduction map, reverse bus search map, added branch map, and added admittance map</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/32a38fe1050b7787d39da4653c300562fee085d9/src/ward_reduction.jl#L6">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.is_factorized-Union{Tuple{ABA_Matrix{Ax, L, Nothing}}, Tuple{L}, Tuple{Ax}} where {Ax, L&lt;:Tuple{Dict, Dict}}"><a class="docstring-binding" href="#PowerNetworkMatrices.is_factorized-Union{Tuple{ABA_Matrix{Ax, L, Nothing}}, Tuple{L}, Tuple{Ax}} where {Ax, L&lt;:Tuple{Dict, Dict}}"><code>PowerNetworkMatrices.is_factorized</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_factorized(ABA)
</code></pre><pre><code class="language-julia hljs">is_factorized(ABA::ABA_Matrix)</code></pre><p>Check if an ABA_Matrix has been factorized (i.e., contains LU factorization matrices).</p><p><strong>Arguments</strong></p><ul><li><code>ABA::ABA_Matrix</code>: The ABA matrix to check</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: true if the matrix has been factorized, false otherwise</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/32a38fe1050b7787d39da4653c300562fee085d9/src/BA_ABA_matrices.jl#L347">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.iterative_union_find-Tuple{SparseArrays.SparseMatrixCSC, Vector{Int64}}"><a class="docstring-binding" href="#PowerNetworkMatrices.iterative_union_find-Tuple{SparseArrays.SparseMatrixCSC, Vector{Int64}}"><code>PowerNetworkMatrices.iterative_union_find</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">iterative_union_find(M, bus_numbers)
</code></pre><pre><code class="language-julia hljs">iterative_union_find(M::SparseArrays.SparseMatrixCSC, bus_numbers::Vector{Int})</code></pre><p>Find connected subnetworks using iterative union-find algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>M::SparseArrays.SparseMatrixCSC</code>: Sparse matrix representing network connectivity</li><li><code>bus_numbers::Vector{Int}</code>: Vector containing the bus numbers of the system</li></ul><p><strong>Returns</strong></p><ul><li><code>Dict{Int, Set{Int}}</code>: Dictionary mapping representative bus numbers to sets of connected buses</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/32a38fe1050b7787d39da4653c300562fee085d9/src/connectivity_checks.jl#L122">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.to_hdf5-Tuple{PTDF, AbstractString}"><a class="docstring-binding" href="#PowerNetworkMatrices.to_hdf5-Tuple{PTDF, AbstractString}"><code>PowerNetworkMatrices.to_hdf5</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">to_hdf5(ptdf, filename; compress, compression_level, force)
</code></pre><p>Serialize the PTDF to an HDF5 file.</p><p><strong>Arguments</strong></p><ul><li><code>ptdf::PTDF</code>: matrix</li><li><code>filename::AbstractString</code>: File to create</li><li><code>compress::Bool</code>: Whether to enabled compression, defaults to true.</li><li><code>compression_level::Int</code>: Compression level to use if compression is enabled.</li><li><code>force::Bool</code>: Whether to overwrite the file if it already exists, defaults to false.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/32a38fe1050b7787d39da4653c300562fee085d9/src/serialization.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.validate_connectivity-Tuple{AdjacencyMatrix}"><a class="docstring-binding" href="#PowerNetworkMatrices.validate_connectivity-Tuple{AdjacencyMatrix}"><code>PowerNetworkMatrices.validate_connectivity</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">validate_connectivity(M)
</code></pre><p>Validates connectivity by checking that the number of subnetworks is 1 (fully connected network).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/32a38fe1050b7787d39da4653c300562fee085d9/src/AdjacencyMatrix.jl#L246">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.validate_connectivity-Tuple{PowerSystems.System}"><a class="docstring-binding" href="#PowerNetworkMatrices.validate_connectivity-Tuple{PowerSystems.System}"><code>PowerNetworkMatrices.validate_connectivity</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">validate_connectivity(sys)
</code></pre><p>Checks the network connectivity of the system using Depth First Search (DFS)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/32a38fe1050b7787d39da4653c300562fee085d9/src/system_utils.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.validate_connectivity-Tuple{Ybus}"><a class="docstring-binding" href="#PowerNetworkMatrices.validate_connectivity-Tuple{Ybus}"><code>PowerNetworkMatrices.validate_connectivity</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">validate_connectivity(M)
</code></pre><pre><code class="language-julia hljs">validate_connectivity(M::Ybus) -&gt; Bool</code></pre><p>Validate that the Y-bus represents a fully connected electrical network.</p><p>Checks network connectivity by counting the number of electrical islands (subnetworks) in the Y-bus matrix. A fully connected network should have exactly one subnetwork. Multiple subnetworks indicate electrical isolation between parts of the system.</p><p><strong>Arguments</strong></p><ul><li><code>M::Ybus</code>: Y-bus matrix to validate</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if network is fully connected (single subnetwork), <code>false</code> otherwise</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">ybus = Ybus(system)
if validate_connectivity(ybus)
    println(&quot;Network is fully connected&quot;)
else
    println(&quot;Network has isolated islands&quot;)
    islands = find_subnetworks(ybus)
    println(&quot;Number of islands: &quot;, length(islands))
end</code></pre><p><strong>Implementation Details</strong></p><ul><li>Uses <code>find_subnetworks()</code> to identify electrical islands</li><li>Single subnetwork indicates full electrical connectivity</li><li>Multiple subnetworks may require separate power flow solutions</li></ul><p><strong>See Also</strong></p><ul><li><a href="#PowerNetworkMatrices.find_subnetworks-Tuple{AdjacencyMatrix}"><code>find_subnetworks</code></a>: Identify electrical islands</li><li><a href="#PowerNetworkMatrices.validate_connectivity-Tuple{AdjacencyMatrix}"><code>validate_connectivity</code></a>: System-level connectivity validation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/32a38fe1050b7787d39da4653c300562fee085d9/src/Ybus.jl#L1775">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../tutorials/tutorial_DegreeTwoReduction/">« DegreeTwoReduction</a><a class="docs-footer-nextpage" href="../internal/">Internal API Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Monday 9 February 2026 23:12">Monday 9 February 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
