<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>VirtualPTDF matrix · PowerNetworkMatrices.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="PowerNetworkMatrices.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PowerNetworkMatrices.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Welcome Page</a></li><li><a class="tocitem" href="../../quick_start_guide/">Quick Start Guide</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorial_Incidence_BA_ABA_matrices/">Incidence, BA and ABA matrices</a></li><li><a class="tocitem" href="../tutorial_PTDF_matrix/">PTDF matrix</a></li><li class="is-active"><a class="tocitem" href>VirtualPTDF matrix</a><ul class="internal"><li><a class="tocitem" href="#How-the-VirtualPTDF-works"><span>How the <code>VirtualPTDF</code> works</span></a></li><li><a class="tocitem" href="#Initialize-VirtualPTDF-and-compute/access-row/element"><span>Initialize <code>VirtualPTDF</code> and compute/access row/element</span></a></li><li><a class="tocitem" href="#VirtualPTDF-with-distributed-slack-bus"><span><code>VirtualPTDF</code> with distributed slack bus</span></a></li><li><a class="tocitem" href="#&quot;Sparse&quot;-VirtualPTDF"><span>&quot;Sparse&quot; <code>VirtualPTDF</code></span></a></li></ul></li><li><a class="tocitem" href="../tutorial_LODF_matrix/">LODF matrix</a></li><li><a class="tocitem" href="../tutorial_VirtualLODF_matrix/">VirtualLODF matrix</a></li></ul></li><li><a class="tocitem" href="../../api/public/">Public API Reference</a></li><li><a class="tocitem" href="../../api/internal/">Internal API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>VirtualPTDF matrix</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>VirtualPTDF matrix</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/main/docs/src/tutorials/tutorial_VirtualPTDF_matrix.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="VirtualPTDF"><a class="docs-heading-anchor" href="#VirtualPTDF">VirtualPTDF</a><a id="VirtualPTDF-1"></a><a class="docs-heading-anchor-permalink" href="#VirtualPTDF" title="Permalink"></a></h1><p>Contrary to the traditional <code>PTDF</code> matrix, the <code>VirtualPTDF</code> is a stucture contatining rows of the original matrix, related to specific system branches. The different rows of the <code>PTDF</code> matrix are cached in the <code>VirtualPTDF</code> structure as they are evaluated. This allows to keep just the portion of the original matrix which is of interest to the user, avoiding the unecessary computation of the whole matrix.</p><p>Refer to the different arguments of the <code>VirtualPTDF</code> methods by looking at the &quot;Public API Reference&quot; page.</p><h2 id="How-the-VirtualPTDF-works"><a class="docs-heading-anchor" href="#How-the-VirtualPTDF-works">How the <code>VirtualPTDF</code> works</a><a id="How-the-VirtualPTDF-works-1"></a><a class="docs-heading-anchor-permalink" href="#How-the-VirtualPTDF-works" title="Permalink"></a></h2><p>The <code>VirtualPTDF</code> is a structure containing everything needed to compute any row of the PTDF matrix and store it. To do so, the <code>VirtualPTDF</code> must store the BA matrix (coming from the <code>BA_Matrix</code> struct) and the inverse of the ABA matrix (coming from <code>ABA_MAtrix</code> struct). In particular, <code>KLU</code> is used to get the LU factorization matrices of the ABA matrix and these ones are stored, avoid the inversion.</p><p>Once the <code>VirtualPTDF</code> is initialized, each row of the PTDF matrix can be evaluated separately. The algorithmic procedure is the following:</p><ol><li>Define the <code>VirtualPTDF</code> structure</li><li>Call any element of the matrix to define and store the relative row as well as showing the selected element</li></ol><p>Regarding point 2, if the row has been stored previosly then the desired element is just loaded from the cache and shown.</p><p>The flowchart below shows how the <code>VirtualPTDF</code> is structured and how it works. Examples will be presented in the following sections.</p><img src="../../assets/VirtualPTDF_scheme.png"/><h2 id="Initialize-VirtualPTDF-and-compute/access-row/element"><a class="docs-heading-anchor" href="#Initialize-VirtualPTDF-and-compute/access-row/element">Initialize <code>VirtualPTDF</code> and compute/access row/element</a><a id="Initialize-VirtualPTDF-and-compute/access-row/element-1"></a><a class="docs-heading-anchor-permalink" href="#Initialize-VirtualPTDF-and-compute/access-row/element" title="Permalink"></a></h2><p>As for the <code>PTDF</code> matrix, at first the <code>System</code> data must be loaded. The &quot;RTS-GMLC&quot; systems is considered as example:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using PowerNetworkMatrices</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using PowerSystemCaseBuilder</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; const PNM = PowerNetworkMatrices;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; const PSB = PowerSystemCaseBuilder;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sys = PSB.build_system(PSB.PSISystems, &quot;RTS_GMLC_DA_sys&quot;);</code><code class="nohighlight hljs ansi" style="display:block;">[ Info: Loaded time series from storage file existing=/home/runner/.julia/packages/PowerSystemCaseBuilder/8GyJc/data/serialized_system/ForecastOnly/RTS_GMLC_DA_sys_time_series_storage.h5 new=/tmp/jl_F0Vw1j compression=InfrastructureSystems.CompressionSettings(false, InfrastructureSystems.CompressionTypesModule.CompressionTypes.DEFLATE = 1, 3, true)</code></pre><p>At this point the <code>VirtualPTDF</code> is initialized with the following simple command:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; v_ptdf = VirtualPTDF(sys);</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>Now, an element of the matrix can be computed by calling the branch name and bus number:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; el_C31_2_105 = v_ptdf[&quot;C31-2&quot;, 105]</code><code class="nohighlight hljs ansi" style="display:block;">-0.005119964728130656</code></pre><p>Alternatively, the number of the branch and bus (corresponding to the number of the PTDF row and column) can be used. In this case the row and column numbers are mapped by the dictonaries contained in the <code>lookup</code> field. </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; row_number = v_ptdf.lookup[1][&quot;C31-2&quot;]</code><code class="nohighlight hljs ansi" style="display:block;">112</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; col_number = v_ptdf.lookup[2][105]</code><code class="nohighlight hljs ansi" style="display:block;">5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; el_C31_2_105_bis = v_ptdf[row_number, col_number]</code><code class="nohighlight hljs ansi" style="display:block;">-0.005119964728130656</code></pre><p><strong>NOTE</strong>: this example was made for the sake of completeness and considering the actual branch name and bus number is reccomended.</p><p>As previosly mentioned, in order to evaluate a single element of the <code>VirtualPTDF</code>, the entire row related to the selected branch must be considered. For this reason it is cached in the <code>VirtualPTDF</code> structure for later calls. This is evident by looking at the following example:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; sys_2k = PSB.build_system(PSB.PSYTestSystems, &quot;tamu_ACTIVSg2000_sys&quot;);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; v_ptdf_2k = VirtualPTDF(sys_2k);
       
       # evaluate PTDF row related to branch &quot;ODESSA 2 0  -1001-ODESSA 3 0  -1064-i_1&quot;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @time v_ptdf_2k[&quot;ODESSA 2 0  -1001-ODESSA 3 0  -1064-i_1&quot;, 8155]
       
       # call same element after the row has been stored</code><code class="nohighlight hljs ansi" style="display:block;">  0.000085 seconds (11 allocations: 47.906 KiB)
5.0022477285046985e-5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @time v_ptdf_2k[&quot;ODESSA 2 0  -1001-ODESSA 3 0  -1064-i_1&quot;, 8155]</code><code class="nohighlight hljs ansi" style="display:block;">  0.000007 seconds (1 allocation: 16 bytes)
5.0022477285046985e-5</code></pre><h2 id="VirtualPTDF-with-distributed-slack-bus"><a class="docs-heading-anchor" href="#VirtualPTDF-with-distributed-slack-bus"><code>VirtualPTDF</code> with distributed slack bus</a><a id="VirtualPTDF-with-distributed-slack-bus-1"></a><a class="docs-heading-anchor-permalink" href="#VirtualPTDF-with-distributed-slack-bus" title="Permalink"></a></h2><p>As for the <code>PTDF</code> matrix, here too each row can be evaluated considering distibuted slack buses. A vector of type <code>Vector{Float64}</code> is defined, specifying the weights for each bus of the system. </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; # smaller system for the next examples
       sys_2 = PSB.build_system(PSB.PSITestSystems, &quot;c_sys5&quot;);
       
       # consider equal distribution accross each bus for this example</code><code class="nohighlight hljs ansi" style="display:block;">[ Info: Loaded time series from storage file existing=/home/runner/.julia/packages/PowerSystemCaseBuilder/8GyJc/data/serialized_system/ForecastOnly/c_sys5_time_series_storage.h5 new=/tmp/jl_NYyuBi compression=InfrastructureSystems.CompressionSettings(false, InfrastructureSystems.CompressionTypesModule.CompressionTypes.DEFLATE = 1, 3, true)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; buscount = length(PNM.get_buses(sys_2));</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dist_slack = 1 / buscount * ones(buscount);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dist_slack_array = dist_slack / sum(dist_slack);</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>Now initialize the <code>VirtualPTDF</code> by defining the <code>dist_slack</code> field with the vector of weights previosly computed:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; v_ptdf_distr = VirtualPTDF(sys_2, dist_slack=dist_slack_array);</code><code class="nohighlight hljs ansi" style="display:block;">[ Info: Distributed bus</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; v_ptdf_orig = VirtualPTDF(sys_2);</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>Now check the difference with the same row related to the branch <code>&quot;1&quot;</code> evaluated without considering distributed slack bus.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; row_distr = [v_ptdf_distr[&quot;1&quot;, j] for j in v_ptdf_distr.axes[2]]</code><code class="nohighlight hljs ansi" style="display:block;">5-element Vector{Float64}:
  0.28820251124689455
 -0.3816088095078225
 -0.2547035520042974
  0.09428590613039686
  0.25382394413482845</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; row_original = [v_ptdf_orig[&quot;1&quot;, j] for j in v_ptdf_orig.axes[2]]</code><code class="nohighlight hljs ansi" style="display:block;">5-element Vector{Float64}:
  0.19391660511649766
 -0.47589471563821933
 -0.34898945813469423
  0.0
  0.15953803800443161</code></pre><h2 id="&quot;Sparse&quot;-VirtualPTDF"><a class="docs-heading-anchor" href="#&quot;Sparse&quot;-VirtualPTDF">&quot;Sparse&quot; <code>VirtualPTDF</code></a><a id="&quot;Sparse&quot;-VirtualPTDF-1"></a><a class="docs-heading-anchor-permalink" href="#&quot;Sparse&quot;-VirtualPTDF" title="Permalink"></a></h2><p>Sparsification of each row can be achieved in the same fashion as for the <code>PTDF</code> matrix, by removing those elements whose absolute values is below a certain threshold.</p><p>As for the example show for the <code>PTDF</code> matrix, here to a very high values of 0.2 is considered for the <code>tol</code> field. Again, this value is considered just for the sake of this example.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; v_ptdf_dense = VirtualPTDF(sys_2);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; v_ptdf_sparse = VirtualPTDF(sys_2, tol=0.2);</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>Let&#39;s now evaluate the same row as before and compare the results:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; original_row = [v_ptdf_dense[&quot;1&quot;, j] for j in v_ptdf_dense.axes[2]]</code><code class="nohighlight hljs ansi" style="display:block;">5-element Vector{Float64}:
  0.19391660511649766
 -0.47589471563821933
 -0.34898945813469423
  0.0
  0.15953803800443161</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sparse_row = [v_ptdf_sparse[&quot;1&quot;, j] for j in v_ptdf_sparse.axes[2]]</code><code class="nohighlight hljs ansi" style="display:block;">5-element Vector{Float64}:
  0.0
 -0.47589471563821933
 -0.34898945813469423
  0.0
  0.0</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial_PTDF_matrix/">« PTDF matrix</a><a class="docs-footer-nextpage" href="../tutorial_LODF_matrix/">LODF matrix »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 13 February 2024 15:14">Tuesday 13 February 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
