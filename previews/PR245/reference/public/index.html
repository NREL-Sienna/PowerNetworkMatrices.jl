<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Public API · PowerNetworkMatrices.jl</title><meta name="title" content="Public API · PowerNetworkMatrices.jl"/><meta property="og:title" content="Public API · PowerNetworkMatrices.jl"/><meta property="twitter:title" content="Public API · PowerNetworkMatrices.jl"/><meta name="description" content="Documentation for PowerNetworkMatrices.jl."/><meta property="og:description" content="Documentation for PowerNetworkMatrices.jl."/><meta property="twitter:description" content="Documentation for PowerNetworkMatrices.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="PowerNetworkMatrices.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PowerNetworkMatrices.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Welcome Page</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/getting_started/">Getting Started</a></li><li><a class="tocitem" href="../../tutorials/tutorial_Incidence_BA_ABA_matrices/">Incidence, BA and ABA matrices</a></li><li><a class="tocitem" href="../../tutorials/tutorial_PTDF_matrix/">PTDF matrix</a></li><li><a class="tocitem" href="../../tutorials/tutorial_VirtualPTDF_matrix/">VirtualPTDF matrix</a></li><li><a class="tocitem" href="../../tutorials/tutorial_LODF_matrix/">LODF matrix</a></li><li><a class="tocitem" href="../../tutorials/tutorial_VirtualLODF_matrix/">VirtualLODF matrix</a></li><li><a class="tocitem" href="../../tutorials/tutorial_RadialReduction/">Radial Reduction</a></li><li><a class="tocitem" href="../../tutorials/tutorial_DegreeTwoReduction/">Degree Two Reduction</a></li></ul></li><li><span class="tocitem">How-To Guides</span><ul><li><a class="tocitem" href="../../how_to_guides/compute_network_matrices/">Compute Network Matrices</a></li><li><a class="tocitem" href="../../how_to_guides/choose_linear_solver/">Choose a Linear Solver</a></li></ul></li><li><span class="tocitem">Explanation</span><ul><li><a class="tocitem" href="../../explanation/computational_considerations/">Computational Considertaions</a></li><li><a class="tocitem" href="../../explanation/dc_power_flow_approximation/">DC Power Flow Approximation</a></li><li><a class="tocitem" href="../../explanation/network_reduction_theory/">Network Reduction Theory</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../network_matrices_overview/">Matrix Overview</a></li><li class="is-active"><a class="tocitem" href>Public API</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>Public API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Public API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/main/docs/src/reference/public.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Public-API-Reference"><a class="docs-heading-anchor" href="#Public-API-Reference">Public API Reference</a><a id="Public-API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Public-API-Reference" title="Permalink"></a></h1><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.ABA_Matrix"><a class="docstring-binding" href="#PowerNetworkMatrices.ABA_Matrix"><code>PowerNetworkMatrices.ABA_Matrix</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Structure containing the ABA matrix and related power system analysis data.</p><p>The ABA matrix represents the bus susceptance matrix computed as A^T * B * A, where A is the incidence matrix and B is the branch susceptance matrix. This matrix is fundamental for DC power flow analysis, sensitivity calculations, and linear power system studies.</p><p><strong>Fields</strong></p><ul><li><code>data::SparseArrays.SparseMatrixCSC{Float64, Int}</code>:       The ABA matrix data representing the bus susceptance matrix. This square matrix has       dimensions equal to the number of buses excluding reference buses</li><li><code>axes::Ax</code>:       Tuple containing identical bus number vectors for rows and columns, excluding reference buses</li><li><code>lookup::L &lt;: NTuple{2, Dict}</code>:       Tuple of identical dictionaries providing fast lookup from bus numbers to matrix indices</li><li><code>subnetwork_axes::Dict{Int, Ax}</code>:       Mapping from reference bus numbers to their corresponding subnetwork axes</li><li><code>ref_bus_position::Vector{Int}</code>:       Vector containing the original indices of reference buses before matrix reduction</li><li><code>K::F &lt;: Union{Nothing, KLU.KLUFactorization{Float64, Int}}</code>:       Optional KLU factorization object for efficient linear system solving. Nothing if unfactorized</li><li><code>network_reduction_data::NetworkReductionData</code>:       Container for network reduction information applied during matrix construction</li></ul><p><strong>Mathematical Properties</strong></p><ul><li><strong>Matrix Form</strong>: ABA = A^T * B * A (bus susceptance matrix)</li><li><strong>Dimensions</strong>: (n<em>buses - n</em>ref) × (n<em>buses - n</em>ref)</li><li><strong>Symmetry</strong>: Positive definite symmetric matrix (for connected networks)</li><li><strong>Sparsity</strong>: Inherits sparsity pattern from network topology</li></ul><p><strong>Notes</strong></p><ul><li>Reference buses are excluded from the matrix to ensure invertibility</li><li>Factorization enables efficient solving of linear systems Ax = b</li><li>Used primarily for DC power flow analysis and power system sensitivity studies</li><li>Supports various network reduction techniques for computational efficiency</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/BA_ABA_matrices.jl#L142">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.ABA_Matrix-Tuple{PowerSystems.System}"><a class="docstring-binding" href="#PowerNetworkMatrices.ABA_Matrix-Tuple{PowerSystems.System}"><code>PowerNetworkMatrices.ABA_Matrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ABA_Matrix(sys; factorize, network_reductions, kwargs...)
</code></pre><pre><code class="language-julia hljs">ABA_Matrix(sys::PSY.System; factorize::Bool = false, network_reductions::Vector{NetworkReduction} = NetworkReduction[], kwargs...)</code></pre><p>Construct an ABA_Matrix from a PowerSystems.System by computing A^T * B * A where A is the incidence matrix and B is the branch susceptance matrix. The resulting matrix is fundamental for DC power flow analysis and power system sensitivity studies.</p><p><strong>Arguments</strong></p><ul><li><code>sys::PSY.System</code>: The power system from which to construct the ABA matrix</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>factorize::Bool = false</code>:       Whether to perform KLU factorization during construction for efficient linear system solving</li><li><code>network_reductions::Vector{NetworkReduction} = NetworkReduction[]</code>:       Vector of network reduction algorithms to apply before matrix construction</li><li><code>include_constant_impedance_loads::Bool=true</code>:        Whether to include constant impedance loads as shunt admittances in the network model</li><li><code>subnetwork_algorithm=iterative_union_find</code>:       Algorithm used for identifying electrical islands and connected components</li><li>Additional keyword arguments are passed to the underlying <code>Ybus</code> constructor</li></ul><p><strong>Returns</strong></p><ul><li><code>ABA_Matrix</code>: The constructed ABA matrix structure containing:<ul><li>Bus susceptance matrix data (excluding reference buses)</li><li>Network topology information and reference bus positions</li><li>Optional KLU factorization for efficient solving</li></ul></li></ul><p><strong>Mathematical Process</strong></p><ol><li><strong>Ybus Construction</strong>: Creates admittance matrix from system data</li><li><strong>Incidence Matrix</strong>: Computes bus-branch incidence matrix A</li><li><strong>BA Matrix</strong>: Forms branch susceptance weighted incidence matrix</li><li><strong>ABA Computation</strong>: Calculates A^T * B * A (bus susceptance matrix)</li><li><strong>Reference Bus Removal</strong>: Excludes reference buses for invertibility</li><li><strong>Optional Factorization</strong>: Performs KLU decomposition if requested</li></ol><p><strong>Notes</strong></p><ul><li>Reference buses are automatically detected and excluded from the final matrix</li><li>Factorization significantly improves performance for repeated linear system solves</li><li>Network reductions can dramatically improve computational efficiency for large systems</li><li>The resulting matrix supports PTDF, LODF, and other power system analysis calculations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/BA_ABA_matrices.jl#L200">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.AdjacencyMatrix"><a class="docstring-binding" href="#PowerNetworkMatrices.AdjacencyMatrix"><code>PowerNetworkMatrices.AdjacencyMatrix</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AdjacencyMatrix{Ax, L} &lt;: PowerNetworkMatrix{Int8}</code></pre><p>An N × N adjacency matrix representing the connectivity structure of a power system with N buses. This matrix describes the directed connectivity between buses, where non-zero entries indicate electrical connections through transmission lines, transformers, or other network elements.</p><p>The matrix is indexed using bus numbers, which do not need to be sequential. Each element <code>A[i,j]</code> is non-zero if there is a direct electrical connection between bus <code>i</code> and bus <code>j</code>. Diagonal elements are typically zero since self-loops are not meaningful in power network topology.</p><p><strong>Fields</strong></p><ul><li><code>data::SparseArrays.SparseMatrixCSC{Int8, Int}</code>: The sparse adjacency matrix storing connectivity information as Int8 values (zero for no connection, non-zero for connection)</li><li><code>axes::Ax</code>: Tuple containing the axis labels for both dimensions. The first element contains bus identifiers for rows, the second contains bus identifiers for columns (typically identical)</li><li><code>lookup::L</code>: Tuple of dictionaries providing bidirectional mapping between bus numbers and their corresponding matrix indices</li><li><code>subnetwork_axes::Dict{Int, Ax}</code>: Dictionary mapping subnetwork identifiers to their corresponding axis information, used for handling electrical islands</li><li><code>network_reduction_data::NetworkReductionData</code>: Container for network reduction algorithms and their associated data, enabling efficient matrix operations on reduced networks</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create from a PowerSystems.System
sys = System(&quot;case5.m&quot;)
adj = AdjacencyMatrix(sys)

# Create from a Ybus matrix
ybus = Ybus(sys)
adj = AdjacencyMatrix(ybus)

# Check connectivity
is_connected = validate_connectivity(adj)
subnetworks = find_subnetworks(adj)</code></pre><p>See also: <a href="#PowerNetworkMatrices.Ybus"><code>Ybus</code></a>, <a href="../../tutorials/tutorial_Incidence_BA_ABA_matrices/#IncidenceMatrix"><code>IncidenceMatrix</code></a>, <a href="#PowerNetworkMatrices.PowerNetworkMatrix"><code>PowerNetworkMatrix</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/AdjacencyMatrix.jl#L2">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.AdjacencyMatrix-Tuple{PowerSystems.System}"><a class="docstring-binding" href="#PowerNetworkMatrices.AdjacencyMatrix-Tuple{PowerSystems.System}"><code>PowerNetworkMatrices.AdjacencyMatrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">AdjacencyMatrix(sys; kwargs...)
</code></pre><pre><code class="language-julia hljs">AdjacencyMatrix(sys::PSY.System; kwargs...)</code></pre><p>Construct an AdjacencyMatrix from a PowerSystems.System.</p><p><strong>Arguments</strong></p><ul><li><code>sys::PSY.System</code>: The power system from which to construct the adjacency matrix</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>network_reductions::Vector{NetworkReduction}=[]</code>: Network reduction algorithms to apply</li><li><code>include_constant_impedance_loads::Bool=true</code>: Whether to include constant impedance loads as shunt admittances</li><li><code>subnetwork_algorithm=iterative_union_find</code>: Algorithm for finding electrical islands</li></ul><p><strong>Returns</strong></p><ul><li><code>AdjacencyMatrix</code>: An N x N adjacency matrix indexed with bus numbers showing connectivity</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/AdjacencyMatrix.jl#L199">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.AdjacencyMatrix-Tuple{Ybus}"><a class="docstring-binding" href="#PowerNetworkMatrices.AdjacencyMatrix-Tuple{Ybus}"><code>PowerNetworkMatrices.AdjacencyMatrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">AdjacencyMatrix(ybus)
</code></pre><pre><code class="language-julia hljs">AdjacencyMatrix(ybus::Ybus)</code></pre><p>Construct an AdjacencyMatrix from a Ybus matrix.</p><p><strong>Arguments</strong></p><ul><li><code>ybus::Ybus</code>: The Ybus matrix from which to construct the adjacency matrix</li></ul><p><strong>Returns</strong></p><ul><li><code>AdjacencyMatrix</code>: The constructed adjacency matrix showing bus connectivity</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/AdjacencyMatrix.jl#L220">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.ArcAdmittanceMatrix"><a class="docstring-binding" href="#PowerNetworkMatrices.ArcAdmittanceMatrix"><code>PowerNetworkMatrices.ArcAdmittanceMatrix</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Arc admittance matrix</p><p><strong>Arguments</strong></p><ul><li><code>data::SparseArrays.SparseMatrixCSC{ComplexF32, Int}</code>:       The arc admittance matrix in the from-to direction</li><li><code>axes&lt;:NTuple{2, Dict}</code>:       Tuple containing two vectors (the first one showing the arc tuples,       the second showing the buses numbers).</li><li><code>lookup&lt;:NTuple{2, Dict}</code>:       Tuple containing two dictionaries, the first mapping the arc tuples       and the second the buses with their enumerated indexes.</li><li><code>network_reduction::NetworkReduction</code>:       Structure containing the details of the network reduction applied when computing the matrix</li><li><code>direction::Symbol</code>:       Direction of admittance (:FromTo or :ToFrom)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/ArcAdmittanceMatrix.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.BA_Matrix"><a class="docstring-binding" href="#PowerNetworkMatrices.BA_Matrix"><code>PowerNetworkMatrices.BA_Matrix</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Structure containing the BA matrix and related network topology data.</p><p>The BA matrix represents the branch-bus incidence matrix weighted by branch susceptances, computed as the product of the incidence matrix A and the susceptance matrix B.</p><p><strong>Fields</strong></p><ul><li><code>data::SparseArrays.SparseMatrixCSC{Float64, Int}</code>:       The transposed BA matrix data. Each row corresponds to a bus and each column       corresponds to a branch, with values representing weighted branch susceptances</li><li><code>axes::Ax</code>:       Tuple containing two vectors: bus numbers (rows) and branch identifiers (columns)</li><li><code>lookup::L &lt;: NTuple{2, Dict}</code>:       Tuple of dictionaries providing fast lookup from bus/branch names to matrix indices</li><li><code>subnetwork_axes::Dict{Int, Ax}</code>:       Mapping from reference bus numbers to their corresponding subnetwork axes</li><li><code>network_reduction_data::NetworkReductionData</code>:       Container for network reduction information applied during matrix construction</li></ul><p><strong>Notes</strong></p><ul><li>The matrix is stored in transposed form for computational efficiency</li><li>Reference buses are identified through <code>subnetwork_axes</code> keys</li><li>Supports various network reduction techniques for computational efficiency</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/BA_ABA_matrices.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.BA_Matrix-Tuple{PowerSystems.System}"><a class="docstring-binding" href="#PowerNetworkMatrices.BA_Matrix-Tuple{PowerSystems.System}"><code>PowerNetworkMatrices.BA_Matrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">BA_Matrix(sys; network_reductions, kwargs...)
</code></pre><pre><code class="language-julia hljs">BA_Matrix(sys::PSY.System; network_reductions::Vector{NetworkReduction} = Vector{NetworkReduction}(), kwargs...)</code></pre><p>Construct a BA_Matrix from a PowerSystems.System by first building the underlying Ybus matrix and then computing the branch-bus incidence matrix weighted by branch susceptances.</p><p><strong>Arguments</strong></p><ul><li><code>sys::PSY.System</code>: The power system from which to construct the BA matrix</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>network_reductions::Vector{NetworkReduction} = Vector{NetworkReduction}()</code>:       Vector of network reduction algorithms to apply before matrix construction</li><li><code>include_constant_impedance_loads::Bool=true</code>:       Whether to include constant impedance loads as shunt admittances in the network model</li><li><code>subnetwork_algorithm=iterative_union_find</code>:       Algorithm used for identifying electrical islands and connected components</li><li>Additional keyword arguments are passed to the underlying <code>Ybus</code> constructor</li></ul><p><strong>Returns</strong></p><ul><li><code>BA_Matrix</code>: The constructed BA matrix structure containing the transposed branch-bus incidence             matrix weighted by susceptances, along with network topology information</li></ul><p><strong>Notes</strong></p><ul><li>This constructor creates a <code>Ybus</code> matrix internally and then converts it to a <code>BA_Matrix</code></li><li>Network reductions can significantly improve computational efficiency for large systems</li><li>The resulting matrix supports DC power flow calculations and sensitivity analysis</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/BA_ABA_matrices.jl#L44">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.BA_Matrix-Tuple{Ybus}"><a class="docstring-binding" href="#PowerNetworkMatrices.BA_Matrix-Tuple{Ybus}"><code>PowerNetworkMatrices.BA_Matrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">BA_Matrix(ybus)
</code></pre><pre><code class="language-julia hljs">BA_Matrix(ybus::Ybus)</code></pre><p>Construct a BA_Matrix from a Ybus matrix.</p><p><strong>Arguments</strong></p><ul><li><code>ybus::Ybus</code>: The Ybus matrix from which to construct the BA matrix</li></ul><p><strong>Returns</strong></p><ul><li><code>BA_Matrix</code>: The constructed BA matrix structure containing the transposed BA matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/BA_ABA_matrices.jl#L84">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.DegreeTwoReduction"><a class="docstring-binding" href="#PowerNetworkMatrices.DegreeTwoReduction"><code>PowerNetworkMatrices.DegreeTwoReduction</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DegreeTwoReduction &lt;: NetworkReduction</code></pre><p>Network reduction algorithm that eliminates buses with exactly two connections by combining the incident branches into a single equivalent branch. This reduction preserves the electrical characteristics of the network while simplifying its topology.</p><p><strong>Fields</strong></p><ul><li><code>irreducible_buses::Vector{Int}</code>: List of bus numbers that should not be eliminated even if they have degree two</li><li><code>reduce_reactive_power_injectors::Bool</code>: Whether to reduce buses with reactive power injections (default: true)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create degree-two reduction with default settings
reduction = DegreeTwoReduction()

# Create degree-two reduction protecting specific buses
reduction = DegreeTwoReduction(irreducible_buses=[101, 205])

# Create reduction that preserves buses with reactive power injections
reduction = DegreeTwoReduction(reduce_reactive_power_injectors=false)

# Apply to system
ybus = Ybus(system; network_reductions=[reduction])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/degree_two_reduction.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.EquivalentBranch"><a class="docstring-binding" href="#PowerNetworkMatrices.EquivalentBranch"><code>PowerNetworkMatrices.EquivalentBranch</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">EquivalentBranch</code></pre><p>Represents the equivalent parameters of a network branch for power flow calculations.</p><p><strong>Fields</strong></p><ul><li><code>equivalent_r::Float64</code>: Equivalent series resistance (p.u.)</li><li><code>equivalent_x::Float64</code>: Equivalent series reactance (p.u.)</li><li><code>equivalent_g_from::Float64</code>: Equivalent shunt conductance at the &quot;from&quot; bus (p.u.)</li><li><code>equivalent_b_from::Float64</code>: Equivalent shunt susceptance at the &quot;from&quot; bus (p.u.)</li><li><code>equivalent_g_to::Float64</code>: Equivalent shunt conductance at the &quot;to&quot; bus (p.u.)</li><li><code>equivalent_b_to::Float64</code>: Equivalent shunt susceptance at the &quot;to&quot; bus (p.u.)</li><li><code>equivalent_tap::Float64</code>: Equivalent transformer tap ratio</li><li><code>equivalent_shift::Float64</code>: Equivalent phase shift angle (radians)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/EquivalentBranch.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.IncidenceMatrix"><a class="docstring-binding" href="#PowerNetworkMatrices.IncidenceMatrix"><code>PowerNetworkMatrices.IncidenceMatrix</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Structure containing the network incidence matrix and related topology data.</p><p>The incidence matrix A represents the bus-branch connectivity of the power network, where each row corresponds to a branch and each column corresponds to a bus. Elements are:</p><ul><li>+1 for the &quot;from&quot; bus of a branch</li><li>-1 for the &quot;to&quot; bus of a branch  </li><li>0 for buses not connected to the branch</li></ul><p><strong>Fields</strong></p><ul><li><code>data::SparseArrays.SparseMatrixCSC{Int8, Int}</code>:       The incidence matrix data with dimensions (n<em>branches × n</em>buses). Values are {-1, 0, +1}       representing the directed connectivity between branches and buses</li><li><code>axes::Ax</code>:       Tuple containing (arc<em>identifiers, bus</em>numbers) where arcs are branch endpoint pairs       and buses are the network bus numbers</li><li><code>lookup::L &lt;: NTuple{2, Dict}</code>:       Tuple of dictionaries providing fast lookup from arc/bus identifiers to matrix indices</li><li><code>subnetwork_axes::Dict{Int, Ax}</code>:       Mapping from reference bus numbers to their corresponding subnetwork axes</li><li><code>network_reduction_data::NetworkReductionData</code>:       Container for network reduction information applied during matrix construction</li></ul><p><strong>Mathematical Properties</strong></p><ul><li><strong>Matrix Dimensions</strong>: (n<em>branches × n</em>buses)</li><li><strong>Element Values</strong>: {-1, 0, +1} representing directed branch-bus connectivity</li><li><strong>Row Sum</strong>: Each row sums to zero (conservation at branch level)</li><li><strong>Rank</strong>: Rank is (n<em>buses - n</em>islands) for connected networks</li><li><strong>Sparsity</strong>: Very sparse with exactly 2 non-zero elements per branch row</li></ul><p><strong>Applications</strong></p><ul><li><strong>Power Flow</strong>: Forms the basis for DC power flow equations: P = A^T * f</li><li><strong>Sensitivity Analysis</strong>: Used in PTDF and LODF calculations</li><li><strong>Network Analysis</strong>: Identifies connected components and network structure</li><li><strong>Topology Processing</strong>: Enables network reduction and equivalencing algorithms</li></ul><p><strong>Notes</strong></p><ul><li>Each branch contributes exactly one row with two non-zero entries (+1, -1)</li><li>Reference buses are preserved in the matrix but identified separately</li><li>Supports various network reduction techniques for computational efficiency</li><li>Essential building block for BA<em>Matrix and ABA</em>Matrix constructions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/IncidenceMatrix.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.IncidenceMatrix-Tuple{PowerSystems.System}"><a class="docstring-binding" href="#PowerNetworkMatrices.IncidenceMatrix-Tuple{PowerSystems.System}"><code>PowerNetworkMatrices.IncidenceMatrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">IncidenceMatrix(sys; network_reductions, kwargs...)
</code></pre><pre><code class="language-julia hljs">IncidenceMatrix(sys::PSY.System; network_reductions::Vector{NetworkReduction} = NetworkReduction[], kwargs...)</code></pre><p>Construct an IncidenceMatrix from a PowerSystems.System by extracting the network topology and creating the bus-branch connectivity matrix fundamental to power system analysis.</p><p><strong>Arguments</strong></p><ul><li><code>sys::PSY.System</code>: The power system from which to construct the incidence matrix</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>network_reductions::Vector{NetworkReduction} = NetworkReduction[]</code>:        Vector of network reduction algorithms to apply before matrix construction</li><li><code>include_constant_impedance_loads::Bool=true</code>:        Whether to include constant impedance loads as shunt admittances in the network model</li><li><code>subnetwork_algorithm=iterative_union_find</code>:        Algorithm used for identifying electrical islands and connected components</li><li>Additional keyword arguments are passed to the underlying <code>Ybus</code> constructor</li></ul><p><strong>Returns</strong></p><ul><li><code>IncidenceMatrix</code>: The constructed incidence matrix structure containing:<ul><li>Bus-branch connectivity matrix with {-1, 0, +1} elements</li><li>Network topology information and reference bus identification</li><li>Support for network reductions and connected component analysis</li></ul></li></ul><p><strong>Mathematical Construction</strong></p><ol><li><strong>Network Extraction</strong>: Identifies all branches and buses from the power system</li><li><strong>Connectivity Mapping</strong>: Creates directed branch-bus relationships  </li><li><strong>Matrix Assembly</strong>: Constructs sparse matrix with +1/-1 entries for branch endpoints</li><li><strong>Topology Analysis</strong>: Identifies reference buses and connected components</li><li><strong>Network Reductions</strong>: Applies specified reduction algorithms if provided</li></ol><p><strong>Applications</strong></p><ul><li><strong>Foundation Matrix</strong>: Essential for constructing BA<em>Matrix and ABA</em>Matrix</li><li><strong>DC Power Flow</strong>: Enables linearized power flow analysis through P = A^T * f</li><li><strong>Sensitivity Analysis</strong>: Required for PTDF, LODF, and other sensitivity calculations</li><li><strong>Network Analysis</strong>: Supports topology processing and network equivalencing</li></ul><p><strong>Notes</strong></p><ul><li>Each branch creates exactly one matrix row with two non-zero entries</li><li>Network reductions can significantly improve computational efficiency</li><li>Reference buses are automatically identified for later matrix operations</li><li>The matrix preserves full network topology for comprehensive power system analysis</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/IncidenceMatrix.jl#L84">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.IncidenceMatrix-Tuple{Ybus}"><a class="docstring-binding" href="#PowerNetworkMatrices.IncidenceMatrix-Tuple{Ybus}"><code>PowerNetworkMatrices.IncidenceMatrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">IncidenceMatrix(ybus)
</code></pre><pre><code class="language-julia hljs">IncidenceMatrix(ybus::Ybus)</code></pre><p>Construct an IncidenceMatrix from an existing Ybus matrix by extracting the network topology and creating the bus-branch connectivity matrix. This constructor leverages the network  structure already captured in the Ybus matrix.</p><p><strong>Arguments</strong></p><ul><li><code>ybus::Ybus</code>: The Ybus matrix containing network topology and admittance data</li></ul><p><strong>Returns</strong></p><ul><li><code>IncidenceMatrix</code>: The constructed incidence matrix structure containing:<ul><li>Bus-branch connectivity matrix with {-1, 0, +1} elements representing directed connections</li><li>Network topology information extracted from the Ybus structure</li><li>Reference bus identification and subnetwork axes from the source matrix</li><li>Network reduction data inherited from the Ybus matrix</li></ul></li></ul><p><strong>Construction Process</strong></p><ol><li><strong>Topology Extraction</strong>: Retrieves bus and branch information from the Ybus matrix</li><li><strong>Arc Processing</strong>: Creates directed arc representations from branch connectivity</li><li><strong>Matrix Assembly</strong>: Constructs sparse incidence matrix with +1 (from bus) and -1 (to bus) entries</li><li><strong>Isolated Bus Handling</strong>: Includes isolated buses with zero entries for completeness</li><li><strong>Metadata Transfer</strong>: Preserves reference bus positions and network reduction information</li></ol><p><strong>Mathematical Properties</strong></p><ul><li><strong>Matrix Form</strong>: A[i,j] = +1 if branch i originates at bus j, -1 if it terminates at bus j, 0 otherwise</li><li><strong>Dimensions</strong>: (n<em>branches × n</em>buses) including all network branches and buses</li><li><strong>Sparsity</strong>: Exactly 2 non-zero entries per branch row (except for isolated buses)</li><li><strong>Consistency</strong>: Maintains the same network topology and reduction state as the source Ybus</li></ul><p><strong>Notes</strong></p><ul><li>This constructor is more efficient when a Ybus matrix is already available</li><li>Preserves all network reduction information from the source matrix</li><li>Isolated buses are handled explicitly to maintain network completeness</li><li>Essential for creating downstream matrices like BA<em>Matrix and ABA</em>Matrix from existing Ybus</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/IncidenceMatrix.jl#L140">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.LODF"><a class="docstring-binding" href="#PowerNetworkMatrices.LODF"><code>PowerNetworkMatrices.LODF</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Structure containing the Line Outage Distribution Factor (LODF) matrix and related power system data.</p><p>The LODF matrix contains sensitivity coefficients that quantify how the outage of one transmission  line affects the power flows on all other lines in the system. Each element LODF[i,j] represents  the change in flow on line i when line j is taken out of service, normalized by the pre-outage  flow on line j.</p><p><strong>Fields</strong></p><ul><li><code>data::M &lt;: AbstractArray{Float64, 2}</code>:       The LODF matrix data stored in transposed form for computational efficiency.        Element (i,j) represents the sensitivity of line j flow to line i outage</li><li><code>axes::Ax</code>:       Tuple of identical branch/arc identifier vectors for both matrix dimensions</li><li><code>lookup::L &lt;: NTuple{2, Dict}</code>:       Tuple of identical dictionaries providing fast lookup from branch identifiers to matrix indices</li><li><code>subnetwork_axes::Dict{Int, Ax}</code>:       Mapping from reference bus numbers to their corresponding subnetwork branch axes</li><li><code>tol::Base.RefValue{Float64}</code>:       Tolerance threshold used for matrix sparsification (elements below this value are dropped)</li><li><code>network_reduction_data::NetworkReductionData</code>:       Container for network reduction information applied during matrix construction</li></ul><p><strong>Mathematical Properties</strong></p><ul><li><strong>Matrix Form</strong>: LODF[i,j] = ∂f<em>i/∂P</em>j where f<em>i is flow on line i, P</em>j is injection change due to line j outage</li><li><strong>Dimensions</strong>: (n<em>branches × n</em>branches) for all transmission lines in the system</li><li><strong>Diagonal Elements</strong>: Always -1 (100% flow reduction on the outaged line itself)</li><li><strong>Symmetry</strong>: Generally non-symmetric matrix reflecting directional flow sensitivities</li><li><strong>Physical Meaning</strong>: Values represent fraction of pre-outage flow that redistributes to other lines</li></ul><p><strong>Applications</strong></p><ul><li><strong>Contingency Analysis</strong>: Evaluate impact of single line outages on system flows</li><li><strong>Security Assessment</strong>: Identify critical transmission bottlenecks and vulnerable lines</li><li><strong>System Planning</strong>: Analyze network robustness and redundancy requirements</li><li><strong>Real-time Operations</strong>: Support operator decision-making for preventive/corrective actions</li></ul><p><strong>Computational Notes</strong></p><ul><li><strong>Storage</strong>: Matrix stored in transposed form for efficient column-wise access patterns</li><li><strong>Sparsification</strong>: Small elements removed based on tolerance to reduce memory usage</li><li><strong>Linear Approximation</strong>: Based on DC power flow assumptions (neglects voltage magnitudes and reactive power)</li><li><strong>Single Contingencies</strong>: Designed for single line outage analysis (N-1 contingencies)</li></ul><p><strong>Usage Notes</strong></p><ul><li>Access via <code>lodf[monitored_line, outaged_line]</code> returns sensitivity coefficient</li><li>Diagonal elements are always -1.0 representing complete flow loss on outaged line</li><li>Matrix sparsification improves performance but may introduce small numerical errors</li><li>Results valid under DC power flow assumptions and normal operating conditions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/lodf_calculations.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.LODF-Tuple{IncidenceMatrix, ABA_Matrix, BA_Matrix}"><a class="docstring-binding" href="#PowerNetworkMatrices.LODF-Tuple{IncidenceMatrix, ABA_Matrix, BA_Matrix}"><code>PowerNetworkMatrices.LODF</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">LODF(A, ABA, BA; linear_solver, tol)
</code></pre><pre><code class="language-julia hljs">LODF(A::IncidenceMatrix, ABA::ABA_Matrix, BA::BA_Matrix; linear_solver::String = &quot;KLU&quot;, tol::Float64 = eps())</code></pre><p>Construct a Line Outage Distribution Factor (LODF) matrix from incidence, ABA, and BA matrices. This constructor provides direct control over the underlying matrix computations and is most efficient when the prerequisite matrices with factorization are already available.</p><p><strong>Arguments</strong></p><ul><li><code>A::IncidenceMatrix</code>: The incidence matrix containing bus-branch connectivity information</li><li><code>ABA::ABA_Matrix</code>: The bus susceptance matrix (A^T * B * A), preferably with KLU factorization</li><li><code>BA::BA_Matrix</code>: The branch susceptance weighted incidence matrix (B * A)</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>linear_solver::String = &quot;KLU&quot;</code>:        Linear solver algorithm for matrix computations. Currently only &quot;KLU&quot; is supported</li><li><code>tol::Float64 = eps()</code>:        Sparsification tolerance for dropping small matrix elements</li></ul><p><strong>Returns</strong></p><ul><li><code>LODF</code>: The constructed LODF matrix structure with line outage sensitivity coefficients</li></ul><p><strong>Mathematical Computation</strong></p><p>This method computes LODF using the factorized form:</p><pre><code class="language-julia hljs">LODF = (A * ABA^(-1) * BA) / (1 - diag(A * ABA^(-1) * BA))</code></pre><p>where:</p><ul><li>A is the incidence matrix</li><li>ABA^(-1) uses the factorized form from the ABA matrix (requires <code>ABA.K</code> to be factorized)</li><li>BA is the susceptance-weighted incidence matrix</li></ul><p><strong>Requirements and Limitations</strong></p><ul><li><strong>Factorization Required</strong>: The ABA matrix should be pre-factorized (contains KLU factorization) for efficiency</li><li><strong>Single Slack Bus</strong>: This method does not support distributed slack bus configurations</li><li><strong>Network Consistency</strong>: All three input matrices must have equivalent network reduction states</li><li><strong>Solver Limitation</strong>: Currently only supports &quot;KLU&quot; linear solver</li></ul><p><strong>Performance Advantages</strong></p><ul><li><strong>Pre-factorization</strong>: Leverages existing KLU factorization in ABA matrix for maximum efficiency</li><li><strong>Direct Computation</strong>: Avoids intermediate PTDF calculation, reducing computational steps</li><li><strong>Memory Efficient</strong>: Works directly with sparse matrix structures throughout computation</li><li><strong>Numerical Stability</strong>: Uses numerically stable KLU solver for matrix operations</li></ul><p><strong>Error Handling</strong></p><ul><li>Validates network reduction consistency across all three input matrices</li><li>Raises error if matrices have mismatched reduction states</li><li>Validates linear solver selection (currently only &quot;KLU&quot; supported)</li></ul><p><strong>Usage Recommendations</strong></p><ul><li>Use this constructor when you have pre-computed and factorized matrices available</li><li>Ensure ABA matrix is factorized using <code>factorize(ABA)</code> or constructed with <code>factorize=true</code></li><li>For systems with distributed slack, use the PTDF-based constructor instead</li><li>Most efficient option for repeated LODF computations on the same network topology</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/lodf_calculations.jl#L355">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.LODF-Tuple{IncidenceMatrix, PTDF}"><a class="docstring-binding" href="#PowerNetworkMatrices.LODF-Tuple{IncidenceMatrix, PTDF}"><code>PowerNetworkMatrices.LODF</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">LODF(A, PTDFm; linear_solver, tol)
</code></pre><pre><code class="language-julia hljs">LODF(A::IncidenceMatrix, PTDFm::PTDF; linear_solver::String = &quot;KLU&quot;, tol::Float64 = eps())</code></pre><p>Construct a Line Outage Distribution Factor (LODF) matrix from existing incidence and PTDF matrices. This constructor is more efficient when the prerequisite matrices are already available.</p><p><strong>Arguments</strong></p><ul><li><code>A::IncidenceMatrix</code>: The incidence matrix containing bus-branch connectivity information</li><li><code>PTDFm::PTDF</code>: The power transfer distribution factor matrix (should be non-sparsified for accuracy)</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>linear_solver::String = &quot;KLU&quot;</code>:        Linear solver algorithm for matrix computations. Options: &quot;KLU&quot;, &quot;Dense&quot;, &quot;MKLPardiso&quot;</li><li><code>tol::Float64 = eps()</code>:        Sparsification tolerance for the LODF matrix (not applied to input PTDF)</li></ul><p><strong>Returns</strong></p><ul><li><code>LODF</code>: The constructed LODF matrix structure with line outage sensitivity coefficients</li></ul><p><strong>Mathematical Computation</strong></p><p>The LODF matrix is computed using the formula:</p><pre><code class="language-julia hljs">LODF = (A * PTDF) / (1 - diag(A * PTDF))</code></pre><p>where:</p><ul><li>A is the incidence matrix representing bus-branch connectivity</li><li>PTDF contains power transfer distribution factors</li><li>The denominator (1 - diagonal terms) accounts for the outaged line&#39;s own flow</li></ul><p><strong>Important Notes</strong></p><ul><li><strong>PTDF Sparsification</strong>: The input PTDF matrix should be non-sparsified (constructed with default tolerance) to avoid accuracy issues</li><li><strong>Tolerance Application</strong>: The <code>tol</code> parameter only affects LODF sparsification, not the input PTDF</li><li><strong>Network Consistency</strong>: Both input matrices must have equivalent network reduction states</li><li><strong>Diagonal Elements</strong>: Automatically set to -1.0 representing complete flow loss on outaged lines</li></ul><p><strong>Performance Considerations</strong></p><ul><li><strong>Matrix Validation</strong>: Warns if input PTDF was sparsified and converts to dense format for accuracy</li><li><strong>Memory Usage</strong>: Sparsification with <code>tol &gt; eps()</code> can significantly reduce memory requirements</li><li><strong>Computational Efficiency</strong>: More efficient than system-based constructor when matrices exist</li></ul><p><strong>Error Handling</strong></p><ul><li>Validates that incidence and PTDF matrices have consistent network reduction data</li><li>Issues warnings if sparsified PTDF matrices are used (potential accuracy issues)</li><li>Supports automatic conversion of sparse PTDF to dense format when necessary</li></ul><p><strong>Linear Solver Selection</strong></p><ul><li><strong>&quot;KLU&quot;</strong>: Recommended for most applications (sparse, numerically stable)</li><li><strong>&quot;Dense&quot;</strong>: Faster for smaller systems but higher memory usage</li><li><strong>&quot;MKLPardiso&quot;</strong>: Best performance for very large systems (requires MKL library)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/lodf_calculations.jl#L259">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.LODF-Tuple{PowerSystems.System}"><a class="docstring-binding" href="#PowerNetworkMatrices.LODF-Tuple{PowerSystems.System}"><code>PowerNetworkMatrices.LODF</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">LODF(sys; linear_solver, tol, network_reductions, kwargs...)
</code></pre><pre><code class="language-julia hljs">LODF(sys::PSY.System; linear_solver::String = &quot;KLU&quot;, tol::Float64 = eps(), network_reductions::Vector{NetworkReduction} = NetworkReduction[], kwargs...)</code></pre><p>Construct a Line Outage Distribution Factor (LODF) matrix from a PowerSystems.System by computing  the sensitivity of line flows to single line outages. This is the primary constructor for LODF  analysis starting from system data.</p><p><strong>Arguments</strong></p><ul><li><code>sys::PSY.System</code>: The power system from which to construct the LODF matrix</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>linear_solver::String = &quot;KLU&quot;</code>:        Linear solver algorithm for matrix computations. Options: &quot;KLU&quot;, &quot;Dense&quot;, &quot;MKLPardiso&quot;</li><li><code>tol::Float64 = eps()</code>:        Sparsification tolerance for dropping small matrix elements to reduce memory usage</li><li><code>network_reductions::Vector{NetworkReduction} = NetworkReduction[]</code>:        Vector of network reduction algorithms to apply before matrix construction</li><li><code>include_constant_impedance_loads::Bool=true</code>:        Whether to include constant impedance loads as shunt admittances in the network model</li><li><code>subnetwork_algorithm=iterative_union_find</code>:        Algorithm used for identifying electrical islands and connected components</li><li>Additional keyword arguments are passed to the underlying matrix constructors</li></ul><p><strong>Returns</strong></p><ul><li><code>LODF</code>: The constructed LODF matrix structure containing:<ul><li>Line-to-line outage sensitivity coefficients</li><li>Network topology information and branch identifiers</li><li>Sparsification tolerance and computational metadata</li></ul></li></ul><p><strong>Construction Process</strong></p><ol><li><strong>Ybus Construction</strong>: Creates system admittance matrix with specified reductions</li><li><strong>Incidence Matrix</strong>: Builds bus-branch connectivity matrix A</li><li><strong>BA Matrix</strong>: Computes branch susceptance weighted incidence matrix</li><li><strong>PTDF Calculation</strong>: Derives power transfer distribution factors</li><li><strong>LODF Computation</strong>: Calculates line outage distribution factors from PTDF</li><li><strong>Sparsification</strong>: Applies tolerance threshold to reduce matrix density</li></ol><p><strong>Linear Solver Options</strong></p><ul><li><strong>&quot;KLU&quot;</strong>: Sparse LU factorization (default, recommended for most cases)</li><li><strong>&quot;Dense&quot;</strong>: Dense matrix operations (faster for small systems)</li><li><strong>&quot;MKLPardiso&quot;</strong>: Intel MKL Pardiso solver (requires MKL, best for very large systems)</li></ul><p><strong>Mathematical Foundation</strong></p><p>The LODF matrix is computed using the relationship:</p><pre><code class="language-julia hljs">LODF = (A * PTDF) / (1 - diag(A * PTDF))</code></pre><p>where A is the incidence matrix and PTDF is the power transfer distribution factor matrix.</p><p><strong>Notes</strong></p><ul><li>Sparsification with <code>tol &gt; eps()</code> can significantly reduce memory usage</li><li>Network reductions can improve computational efficiency for large systems</li><li>Results are valid under DC power flow assumptions (linear approximation)</li><li>Diagonal elements are always -1.0 representing complete flow loss on outaged lines</li><li>For very large systems, consider using &quot;MKLPardiso&quot; solver with appropriate chunk size</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/lodf_calculations.jl#L185">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.NetworkReduction"><a class="docstring-binding" href="#PowerNetworkMatrices.NetworkReduction"><code>PowerNetworkMatrices.NetworkReduction</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NetworkReduction</code></pre><p>Abstract base type for all network reduction algorithms used in power network analysis. Network reductions are mathematical transformations that eliminate buses and branches  while preserving the electrical behavior of the remaining network elements.</p><p>Concrete implementations include:</p><ul><li><a href="../../tutorials/tutorial_RadialReduction/#RadialReduction"><code>RadialReduction</code></a>: Eliminates radial (dangling) buses and branches</li><li><a href="../../tutorials/tutorial_DegreeTwoReduction/#DegreeTwoReduction"><code>DegreeTwoReduction</code></a>: Eliminates buses with exactly two connections</li><li><a href="#PowerNetworkMatrices.WardReduction"><code>WardReduction</code></a>: Reduces external buses while preserving study bus behavior</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/NetworkReduction.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.NetworkReductionData"><a class="docstring-binding" href="#PowerNetworkMatrices.NetworkReductionData"><code>PowerNetworkMatrices.NetworkReductionData</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NetworkReductionData</code></pre><p>Mutable struct containing all data mappings and metadata for network reduction operations. This structure tracks how buses and branches are mapped, combined, or eliminated during network reduction algorithms.</p><p><strong>Fields</strong></p><ul><li><code>irreducible_buses::Set{Int}</code>: Buses that cannot be reduced</li><li><code>bus_reduction_map::Dict{Int, Set{Int}}</code>: Maps retained buses to sets of eliminated buses</li><li><code>reverse_bus_search_map::Dict{Int, Int}</code>: Maps eliminated buses to their parent buses</li><li><code>direct_branch_map::Dict{Tuple{Int, Int}, PSY.ACTransmission}</code>: One-to-one branch mappings</li><li><code>reverse_direct_branch_map::Dict{PSY.ACTransmission, Tuple{Int, Int}}</code>: Reverse direct mappings</li><li><code>parallel_branch_map::Dict{Tuple{Int, Int}, BranchesParallel}</code>: Parallel branch combinations</li><li><code>reverse_parallel_branch_map::Dict{PSY.ACTransmission, Tuple{Int, Int}}</code>: Reverse parallel mappings</li><li><code>series_branch_map::Dict{Tuple{Int, Int}, BranchesSeries}</code>: Series branch combinations</li><li><code>reverse_series_branch_map::Dict{Any, Tuple{Int, Int}}</code>: Reverse series mappings</li><li><code>transformer3W_map::Dict{Tuple{Int, Int}, ThreeWindingTransformerWinding}</code>: Three-winding transformer mappings</li><li><code>reverse_transformer3W_map::Dict{ThreeWindingTransformerWinding, Tuple{Int, Int}}</code>: Reverse transformer mappings</li><li><code>removed_buses::Set{Int}</code>: Set of buses eliminated from the network</li><li><code>removed_arcs::Set{Tuple{Int, Int}}</code>: Set of arcs eliminated from the network</li><li><code>radial_arc_to_surviving_bus::Dict{Tuple{Int, Int}, Int}</code>: Maps final arcs in radial reduction chains to their surviving bus numbers</li><li><code>added_admittance_map::Dict{Int, Complex{Float32}}</code>: Admittances added to buses during reduction</li><li><code>added_branch_map::Dict{Tuple{Int, Int}, Complex{Float32}}</code>: New branches created during reduction</li><li><code>all_branch_maps_by_type::Dict{String, Any}</code>: Branch mappings organized by component type</li><li><code>reductions::ReductionContainer</code>: Container tracking applied reduction algorithms</li><li><code>name_to_arc_map::Dict{Type, DataStructures.SortedDict{String, Tuple{Tuple{Int, Int}, String}}}</code>: Lazily filled with the call to <a href="#PowerNetworkMatrices.populate_branch_maps_by_type!"><code>populate_branch_maps_by_type!</code></a>, maps string names to their corresponding arcs and the map where the arc can be found. Used in optimization models or power flow reporting after reductions are applied. It is possible to have repeated arcs for some names if case of serial or parallel combinations.</li><li><code>component_to_reduction_name_map::Dict{Type, Dict{String, String}}</code>: Lazily filled with the call to <a href="#PowerNetworkMatrices.populate_branch_maps_by_type!"><code>populate_branch_maps_by_type!</code></a>, maps component names to the names of the reduction entries used in name<em>to</em>arc_map. Used in optimization models for connecting component attributes (e.g. outages) to network reduction entries.</li><li><code>filters_applied::Dict{Type, Function}</code>: Filters applied when populating branch maps by type</li><li><code>direct_branch_name_map::Dict{String, Tuple{Int, Int}}</code>: Lazily filled, maps branch names to their corresponding arc tuples for direct branches</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/NetworkReductionData.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.PTDF"><a class="docstring-binding" href="#PowerNetworkMatrices.PTDF"><code>PowerNetworkMatrices.PTDF</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Structure containing the Power Transfer Distribution Factor (PTDF) matrix and related power system data.</p><p>The PTDF matrix contains sensitivity coefficients that quantify how power injections at buses affect the power flows on transmission lines. Each element PTDF[i,j] represents the incremental change in flow on line i due to a unit power injection at bus j, under DC power flow assumptions.</p><p><strong>Fields</strong></p><ul><li><code>data::M &lt;: AbstractArray{Float64, 2}</code>:       The PTDF matrix data stored in transposed form for computational efficiency.       Element (i,j) represents the sensitivity of line j flow to bus i injection</li><li><code>axes::Ax</code>:       Tuple containing (bus<em>numbers, branch</em>identifiers) for matrix dimensions</li><li><code>lookup::L &lt;: NTuple{2, Dict}</code>:       Tuple of dictionaries providing fast lookup from bus/branch identifiers to matrix indices</li><li><code>subnetwork_axes::Dict{Int, Ax}</code>:       Mapping from reference bus numbers to their corresponding subnetwork axes</li><li><code>tol::Base.RefValue{Float64}</code>:       Tolerance threshold used for matrix sparsification (elements below this value are dropped)</li><li><code>network_reduction_data::NetworkReductionData</code>:       Container for network reduction information applied during matrix construction</li></ul><p><strong>Mathematical Properties</strong></p><ul><li><strong>Matrix Form</strong>: PTDF[i,j] = ∂f<em>i/∂P</em>j where f<em>i is flow on line i, P</em>j is injection at bus j</li><li><strong>Dimensions</strong>: (n<em>buses × n</em>arcs) for all buses and impedance arcs</li><li><strong>Linear Superposition</strong>: Total flow = Σ(PTDF[i,j] × P<em>j) for all injections P</em>j</li><li><strong>Physical Meaning</strong>: Values represent the fraction of bus injection that flows through each line</li><li><strong>Reference Bus</strong>: Rows corresponding to reference buses are typically zero</li></ul><p><strong>Applications</strong></p><ul><li><strong>Power Flow Analysis</strong>: Rapid calculation of line flows for given injection patterns</li><li><strong>Sensitivity Studies</strong>: Evaluate impact of generation/load changes on transmission flows</li><li><strong>Congestion Management</strong>: Identify lines affected by specific injection changes</li><li><strong>Market Analysis</strong>: Support nodal pricing and transmission rights calculations</li><li><strong>Planning Studies</strong>: Assess transmission utilization under various scenarios</li></ul><p><strong>Computational Features</strong></p><ul><li><strong>Matrix Storage</strong>: Stored in transposed form (bus × branch) for efficient computation</li><li><strong>Sparsification</strong>: Small elements removed based on tolerance to reduce memory usage</li><li><strong>Reference Bus Handling</strong>: Reference bus injections automatically handled in calculations</li><li><strong>Distributed Slack</strong>: Supports distributed slack bus configurations for improved realism</li></ul><p><strong>Usage Notes</strong></p><ul><li>Access via <code>ptdf[bus, line]</code> returns the sensitivity coefficient</li><li>Matrix indexing uses bus numbers and branch identifiers</li><li>Sparsification improves memory efficiency but may introduce small numerical errors</li><li>Results valid under DC power flow assumptions (neglects voltage magnitudes and reactive power)</li><li>Reference bus choice affects the specific values but not the relative sensitivities</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/ptdf_calculations.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.PTDF-Tuple{AbstractString}"><a class="docstring-binding" href="#PowerNetworkMatrices.PTDF-Tuple{AbstractString}"><code>PowerNetworkMatrices.PTDF</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">PTDF(filename)
</code></pre><p>Deserialize a PTDF from an HDF5 file.</p><p><strong>Arguments</strong></p><ul><li><code>filename::AbstractString</code>: File containing a serialized PTDF.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/ptdf_calculations.jl#L72">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.PTDF-Tuple{IncidenceMatrix, BA_Matrix}"><a class="docstring-binding" href="#PowerNetworkMatrices.PTDF-Tuple{IncidenceMatrix, BA_Matrix}"><code>PowerNetworkMatrices.PTDF</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">PTDF(A, BA; dist_slack, linear_solver, tol)
</code></pre><pre><code class="language-julia hljs">PTDF(A::IncidenceMatrix, BA::BA_Matrix; dist_slack::Dict{Int, Float64} = Dict{Int, Float64}(), linear_solver = &quot;KLU&quot;, tol::Float64 = eps())</code></pre><p>Construct a Power Transfer Distribution Factor (PTDF) matrix from existing incidence and BA matrices. This constructor is more efficient when the prerequisite matrices are already available and provides direct control over the underlying matrix computations.</p><p><strong>Arguments</strong></p><ul><li><code>A::IncidenceMatrix</code>: The incidence matrix containing bus-branch connectivity information</li><li><code>BA::BA_Matrix</code>: The branch susceptance weighted incidence matrix (B × A)</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>dist_slack::Dict{Int, Float64} = Dict{Int, Float64}()</code>:       Dictionary mapping bus numbers to distributed slack participation factors.       Empty dictionary uses single slack bus (reference bus from matrices)</li><li><code>linear_solver::String = &quot;KLU&quot;</code>:       Linear solver algorithm for matrix computations. Options: &quot;KLU&quot;, &quot;Dense&quot;, &quot;MKLPardiso&quot;</li><li><code>tol::Float64 = eps()</code>:       Sparsification tolerance for dropping small matrix elements to reduce memory usage</li></ul><p><strong>Returns</strong></p><ul><li><code>PTDF</code>: The constructed PTDF matrix structure with injection-to-flow sensitivity coefficients</li></ul><p><strong>Mathematical Computation</strong></p><p>The PTDF matrix is computed using the relationship:</p><pre><code class="language-julia hljs">PTDF = (A^T × B × A)^(-1) × A^T × B</code></pre><p>where:</p><ul><li>A is the incidence matrix representing bus-branch connectivity</li><li>B is the diagonal susceptance matrix (embedded in BA matrix)</li><li>The computation involves solving the ABA linear system for efficiency</li></ul><p><strong>Distributed Slack Handling</strong></p><ul><li><strong>Single Slack</strong>: Uses reference bus identified from input matrices</li><li><strong>Distributed Slack</strong>: Applies participation factor corrections to final PTDF</li><li><strong>Automatic Processing</strong>: Dictionary converted to vector form matching matrix dimensions</li><li><strong>Validation</strong>: Ensures distributed slack bus numbers exist in the network</li><li><strong>Normalization</strong>: Participation factors automatically normalized to maintain power balance</li></ul><p><strong>Network Consistency Requirements</strong></p><ul><li><strong>Reduction Compatibility</strong>: Both input matrices must have equivalent network reduction states</li><li><strong>Reference Alignment</strong>: BA matrix reference buses determine the PTDF reference framework</li><li><strong>Topology Consistency</strong>: Matrices must represent the same network topology</li></ul><p><strong>Performance Considerations</strong></p><ul><li><strong>Matrix Reuse</strong>: More efficient when A and BA matrices are already computed</li><li><strong>Memory Management</strong>: Sparsification reduces storage requirements significantly</li><li><strong>Solver Selection</strong>: KLU recommended for sparse systems, Dense for small networks</li><li><strong>Computational Efficiency</strong>: Avoids redundant system matrix construction</li></ul><p><strong>Error Handling and Validation</strong></p><ul><li><strong>Matrix Compatibility</strong>: Validates that A and BA have consistent network reductions</li><li><strong>Slack Validation</strong>: Checks that distributed slack buses exist in the matrix structure</li><li><strong>Solver Validation</strong>: Ensures selected linear solver is supported and available</li><li><strong>Numerical Stability</strong>: Handles singular systems and provides informative error messages</li></ul><p><strong>Usage Recommendations</strong></p><ul><li><strong>Preferred Method</strong>: Use when incidence and BA matrices are already available</li><li><strong>Repeated Calculations</strong>: Ideal for multiple PTDF computations with different slack configurations</li><li><strong>Large Systems</strong>: Consider sparsification for memory efficiency</li><li><strong>Distributed Slack</strong>: Provides more realistic modeling of generator response to load changes</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/ptdf_calculations.jl#L325">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.PTDF-Tuple{PowerSystems.System}"><a class="docstring-binding" href="#PowerNetworkMatrices.PTDF-Tuple{PowerSystems.System}"><code>PowerNetworkMatrices.PTDF</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">PTDF(sys; dist_slack, linear_solver, tol, kwargs...)
</code></pre><pre><code class="language-julia hljs">PTDF(sys::PSY.System; dist_slack::Dict{Int, Float64} = Dict{Int, Float64}(), linear_solver = &quot;KLU&quot;, tol::Float64 = eps(), network_reductions::Vector{NetworkReduction} = NetworkReduction[], kwargs...)</code></pre><p>Construct a Power Transfer Distribution Factor (PTDF) matrix from a PowerSystems.System by computing the sensitivity of transmission line flows to bus power injections. This is the primary constructor for PTDF analysis starting from system data.</p><p><strong>Arguments</strong></p><ul><li><code>sys::PSY.System</code>: The power system from which to construct the PTDF matrix</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>dist_slack::Dict{Int, Float64} = Dict{Int, Float64}()</code>:       Dictionary mapping bus numbers to distributed slack weights for realistic slack modeling.       Empty dictionary uses single slack bus (default behavior)</li><li><code>linear_solver::String = &quot;KLU&quot;</code>:       Linear solver algorithm for matrix computations. Options: &quot;KLU&quot;, &quot;Dense&quot;, &quot;MKLPardiso&quot;</li><li><code>tol::Float64 = eps()</code>:       Sparsification tolerance for dropping small matrix elements to reduce memory usage</li><li><code>network_reductions::Vector{NetworkReduction} = NetworkReduction[]</code>:       Vector of network reduction algorithms to apply before matrix construction</li><li><code>include_constant_impedance_loads::Bool=true</code>:       Whether to include constant impedance loads as shunt admittances in the network model</li><li><code>subnetwork_algorithm=iterative_union_find</code>:       Algorithm used for identifying electrical islands and connected components</li><li>Additional keyword arguments are passed to the underlying matrix constructors</li></ul><p><strong>Returns</strong></p><ul><li><code>PTDF</code>: The constructed PTDF matrix structure containing:<ul><li>Bus-to-impedance-arc injection sensitivity coefficients</li><li>Network topology information and reference bus identification</li><li>Sparsification tolerance and computational metadata</li></ul></li></ul><p><strong>Construction Process</strong></p><ol><li><strong>Ybus Construction</strong>: Creates system admittance matrix with specified reductions</li><li><strong>Incidence Matrix</strong>: Builds bus-branch connectivity matrix A</li><li><strong>BA Matrix</strong>: Computes branch susceptance weighted incidence matrix</li><li><strong>PTDF Computation</strong>: Calculates power transfer distribution factors using A^T × B^(-1) × A</li><li><strong>Distributed Slack</strong>: Applies distributed slack correction if specified</li><li><strong>Sparsification</strong>: Removes small elements based on tolerance threshold</li></ol><p><strong>Distributed Slack Configuration</strong></p><ul><li><strong>Single Slack</strong>: Empty <code>dist_slack</code> dictionary uses conventional single slack bus</li><li><strong>Distributed Slack</strong>: Dictionary maps bus numbers to participation factors</li><li><strong>Normalization</strong>: Participation factors automatically normalized to sum to 1.0</li><li><strong>Physical Meaning</strong>: Distributed slack better represents generator response to load changes</li></ul><p><strong>Linear Solver Options</strong></p><ul><li><strong>&quot;KLU&quot;</strong>: Sparse LU factorization (default, recommended for most cases)</li><li><strong>&quot;Dense&quot;</strong>: Dense matrix operations (faster for small systems, higher memory usage)</li><li><strong>&quot;MKLPardiso&quot;</strong>: Intel MKL Pardiso solver (requires MKL library, best for very large systems)</li></ul><p><strong>Mathematical Foundation</strong></p><p>The PTDF matrix is computed as:</p><pre><code class="language-julia hljs">PTDF = A^T × (A^T × B × A)^(-1) × A^T × B</code></pre><p>where A is the incidence matrix and B is the susceptance matrix.</p><p><strong>Notes</strong></p><ul><li>Results are valid under DC power flow assumptions (linear approximation)</li><li>Reference bus selection affects specific values but not relative sensitivities</li><li>Sparsification with <code>tol &gt; eps()</code> can significantly reduce memory usage</li><li>Network reductions improve computational efficiency for large systems</li><li>Distributed slack provides more realistic representation of system response</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/ptdf_calculations.jl#L239">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.PowerNetworkMatrix"><a class="docstring-binding" href="#PowerNetworkMatrices.PowerNetworkMatrix"><code>PowerNetworkMatrices.PowerNetworkMatrix</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Type PowerNetworkMatrix gathers all the different types of Matrices considered in this package </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/PowerNetworkMatrix.jl#L10">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.PowerNetworkMatrixKey"><a class="docstring-binding" href="#PowerNetworkMatrices.PowerNetworkMatrixKey"><code>PowerNetworkMatrices.PowerNetworkMatrixKey</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Structure to store the keys of a power network matrix</p><p><strong>Arguments</strong></p><ul><li><code>I&lt;:Tuple</code>:       tuple containing the indices of the matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/PowerNetworkMatrix.jl#L141">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.PowerNetworkMatrixKeys"><a class="docstring-binding" href="#PowerNetworkMatrices.PowerNetworkMatrixKeys"><code>PowerNetworkMatrices.PowerNetworkMatrixKeys</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Structure to store the keys of a power network matrix</p><p><strong>Arguments</strong></p><ul><li><code>product_iter::Base.Iterators.ProductIterator{T} where T &lt;: Tuple</code>:       iterator of the indices of the network power matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/PowerNetworkMatrix.jl#L154">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.RadialReduction"><a class="docstring-binding" href="#PowerNetworkMatrices.RadialReduction"><code>PowerNetworkMatrices.RadialReduction</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RadialReduction &lt;: NetworkReduction</code></pre><p>Network reduction algorithm that eliminates radial (dangling) buses and their associated branches from the power network. Radial buses are leaf nodes with only one connection that do not affect the electrical behavior of the rest of the network.</p><p><strong>Fields</strong></p><ul><li><code>irreducible_buses::Vector{Int}</code>: List of bus numbers that should not be eliminated even if they are radial</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create radial reduction with no protected buses
reduction = RadialReduction()

# Create radial reduction protecting specific buses
reduction = RadialReduction(irreducible_buses=[101, 205])

# Apply to system
ybus = Ybus(system; network_reductions=[reduction])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/radial_reduction.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.RowCache"><a class="docstring-binding" href="#PowerNetworkMatrices.RowCache"><code>PowerNetworkMatrices.RowCache</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Structure used for saving the rows of the Virtual PTDF and LODF matrix.</p><p><strong>Arguments</strong></p><ul><li><code>temp_cache::Dict{Int, Union{Vector{Float64}, SparseArrays.SparseVector{Float64}}}</code>:       Dictionary saving the row of the PTDF/LODF matrix</li><li><code>persistent_cache_keys::Set{Int}</code>:       Set listing the rows to keep in <code>temp_cache</code></li><li><code>max_cache_size::Int</code>       Defines the maximum allowed cache size (rows*row_size)</li><li><code>max_num_keys::Int</code>       Defines the maximum number of keys saved (rows of the matrix)</li><li><code>access_order::Vector{Int}</code>:       Vector tracking access order for LRU eviction (most recent at end)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/row_cache.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.RowCache-Tuple{Int64, Set{Int64}, Any}"><a class="docstring-binding" href="#PowerNetworkMatrices.RowCache-Tuple{Int64, Set{Int64}, Any}"><code>PowerNetworkMatrices.RowCache</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">RowCache(max_cache_size, persistent_rows, row_size)
</code></pre><p>Structure used for saving the rows of the Virtual PTDF and LODF matrix.</p><p><strong>Arguments</strong></p><ul><li><code>max_cache_size::Int</code>       Defines the maximum allowed cache size (rows*row_size).</li><li><code>persistent_rows::Set{Int}</code>:       Set listing the rows to keep in <code>temp_cache</code>.</li><li><code>row_size</code>       Defines the size of the single row to store.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/row_cache.jl#L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.ThreeWindingTransformerWinding"><a class="docstring-binding" href="#PowerNetworkMatrices.ThreeWindingTransformerWinding"><code>PowerNetworkMatrices.ThreeWindingTransformerWinding</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ThreeWindingTransformerWinding{T&lt;:PSY.ThreeWindingTransformer} &lt;: PSY.ACTransmission</code></pre><p>Internal object representing a single winding of a three-winding transformer. Do not export.</p><p>This structure is used internally to decompose three-winding transformers into individual winding components for network matrix construction and analysis purposes.</p><p><strong>Fields</strong></p><ul><li><code>transformer::T</code>: The parent three-winding transformer object</li><li><code>winding_number::Int</code>: The winding number (1, 2, or 3) that this object represents</li></ul><p><strong>Note</strong></p><p>This is an internal object and should not be constructed directly by users or added to a system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/ThreeWindingTransformerWinding.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.VirtualLODF"><a class="docstring-binding" href="#PowerNetworkMatrices.VirtualLODF"><code>PowerNetworkMatrices.VirtualLODF</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>The Virtual Line Outage Distribution Factor (VirtualLODF) structure gathers the rows of the LODF matrix as they are evaluated on-the-go. These rows are evaluated independently, cached in the structure and do not require the computation of the whole matrix (therefore significantly reducing the computational requirements).</p><p>The VirtualLODF is initialized with no row stored.</p><p>The VirtualLODF struct is indexed using branch names.</p><p><strong>Arguments</strong></p><ul><li><code>K::KLU.KLUFactorization{Float64, Int}</code>:       LU factorization matrices of the ABA matrix, evaluated by means of KLU.</li><li><code>BA::SparseArrays.SparseMatrixCSC{Float64, Int}</code>:       BA matrix.</li><li><code>A::SparseArrays.SparseMatrixCSC{Int8, Int}</code>:       Incidence matrix.</li><li><code>inv_PTDF_A_diag::Vector{Float64}</code>:       Vector contiaining the element-wise reciprocal of the diagonal elements       coming from multuiplying the PTDF matrix with th Incidence matrix</li><li><code>ref_bus_positions::Set{Int}</code>:       Vector containing the indexes of the rows of the transposed BA matrix       corresponding to the reference buses.</li><li><code>dist_slack::Vector{Float64}</code>:       Vector of weights to be used as distributed slack bus.       The distributed slack vector has to be the same length as the number of buses.</li><li><code>axes&lt;:NTuple{2, Dict}</code>:       Tuple containing two vectors showing the branch names.</li><li><code>lookup&lt;:NTuple{2, Dict}</code>:       Tuple containing two dictionaries, mapping the branches names       the enumerated row indexes indexes.</li><li><code>valid_ix::Vector{Int}</code>:       Vector containing the row/columns indices of matrices related the buses       which are not slack ones.</li><li><code>temp_data::Vector{Float64}</code>:       Temporary vector for internal use.</li><li><code>cache::RowCache</code>:       Cache were LODF rows are stored.</li><li><code>subnetworks::Dict{Int, Set{Int}}</code>:       Dictionary containing the subsets of buses defining the different subnetwork of the system.</li><li><code>tol::Base.RefValue{Float64}</code>:       Tolerance related to scarification and values to drop.</li><li><code>network_reduction::NetworkReduction</code>:       Structure containing the details of the network reduction applied when computing the matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/virtual_lodf_calculations.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.VirtualLODF-Tuple{PowerSystems.System}"><a class="docstring-binding" href="#PowerNetworkMatrices.VirtualLODF-Tuple{PowerSystems.System}"><code>PowerNetworkMatrices.VirtualLODF</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">VirtualLODF(
    sys;
    dist_slack,
    tol,
    max_cache_size,
    persistent_arcs,
    network_reductions,
    kwargs...
)
</code></pre><p>Builds the Virtual LODF matrix from a system. The return is a VirtualLODF struct with an empty cache.</p><p><strong>Arguments</strong></p><ul><li><code>sys::PSY.System</code>:       PSY system for which the matrix is constructed</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>network_reduction::NetworkReduction</code>:       Structure containing the details of the network reduction applied when computing the matrix</li><li><code>kwargs...</code>:       other keyword arguments used by VirtualPTDF</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/virtual_lodf_calculations.jl#L116">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.VirtualPTDF"><a class="docstring-binding" href="#PowerNetworkMatrices.VirtualPTDF"><code>PowerNetworkMatrices.VirtualPTDF</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>The Virtual Power Transfer Distribution Factor (VirtualPTDF) structure gathers the rows of the PTDF matrix as they are evaluated on-the-go. These rows are evaluated independently, cached in the structure and do not require the computation of the whole matrix (therefore significantly reducing the computational requirements).</p><p>The VirtualPTDF is initialized with no row stored.</p><p>The VirtualPTDF is indexed using branch names and bus numbers as for the PTDF matrix.</p><p><strong>Arguments</strong></p><ul><li><code>K::Union{KLU.KLUFactorization{Float64, Int}, AppleAccelerate.AAFactorization{Float64}}</code>:       LU factorization matrices of the ABA matrix, evaluated by means of KLU or AppleAccelerate</li><li><code>BA::SparseArrays.SparseMatrixCSC{Float64, Int}</code>:       BA matrix</li><li><code>ref_bus_positions::Set{Int}</code>:       Vector containing the indexes of the columns of the BA matrix corresponding       to the reference buses</li><li><code>dist_slack::Vector{Float64}</code>:       Vector of weights to be used as distributed slack bus.       The distributed slack vector has to be the same length as the number of buses.</li><li><code>axes&lt;:NTuple{2, Dict}</code>:       Tuple containing two vectors: the first one showing the branches names,       the second showing the buses numbers. There is no link between the       order of the vector of the branches names and the way the PTDF rows are       stored in the cache.</li><li><code>lookup&lt;:NTuple{2, Dict}</code>:       Tuple containing two dictionaries, mapping the branches       and buses with their enumerated indexes. The branch indexes refer to       the key of the cache dictionary. The bus indexes refer to the position       of the elements in the PTDF row stored.</li><li><code>temp_data::Vector{Float64}</code>:       Temporary vector for internal use.</li><li><code>valid_ix::Vector{Int}</code>:       Vector containing the row/columns indices of matrices related the buses       which are not slack ones.</li><li><code>cache::RowCache</code>:       Cache were PTDF rows are stored.</li><li><code>subnetworks::Dict{Int, Set{Int}}</code>:       Dictionary containing the subsets of buses defining the different subnetwork of the system.</li><li><code>tol::Base.RefValue{Float64}</code>:       Tolerance related to scarification and values to drop.</li><li><code>network_reduction::NetworkReduction</code>:       Structure containing the details of the network reduction applied when computing the matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/virtual_ptdf_calculations.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.VirtualPTDF-Tuple{PowerSystems.System}"><a class="docstring-binding" href="#PowerNetworkMatrices.VirtualPTDF-Tuple{PowerSystems.System}"><code>PowerNetworkMatrices.VirtualPTDF</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">VirtualPTDF(
    sys;
    dist_slack,
    linear_solver,
    tol,
    max_cache_size,
    persistent_arcs,
    network_reductions,
    kwargs...
)
</code></pre><p>Builds the Virtual PTDF matrix from a system. The return is a VirtualPTDF struct with an empty cache.</p><p><strong>Arguments</strong></p><ul><li><code>sys::PSY.System</code>:       PSY system for which the matrix is constructed</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>dist_slack::Vector{Float64} = Float64[]</code>:       Vector of weights to be used as distributed slack bus.       The distributed slack vector has to be the same length as the number of buses.</li><li><code>linear_solver::String = &quot;KLU&quot;</code>:       Linear solver to use for factorization. Options: &quot;KLU&quot;, &quot;AppleAccelerate&quot;</li><li><code>tol::Float64 = eps()</code>:       Tolerance related to sparsification and values to drop.</li><li><code>max_cache_size::Int</code>:       max cache size in MiB (initialized as MAX<em>CACHE</em>SIZE_MiB).</li><li><code>persistent_lines::Vector{String}</code>:       line to be evaluated as soon as the VirtualPTDF is created (initialized as empty vector of strings).</li><li><code>network_reduction::NetworkReduction</code>:       Structure containing the details of the network reduction applied when computing the matrix</li><li><code>kwargs...</code>:       other keyword arguments used by VirtualPTDF</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/virtual_ptdf_calculations.jl#L82">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.WardReduction"><a class="docstring-binding" href="#PowerNetworkMatrices.WardReduction"><code>PowerNetworkMatrices.WardReduction</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">WardReduction &lt;: NetworkReduction</code></pre><p>Perform Ward reduction to create an equivalent network representation.</p><p>Ward reduction is a network reduction technique that eliminates external buses while preserving  the electrical characteristics seen from the study buses. External buses are mapped to boundary  buses based on impedance criteria, and equivalent admittances are computed.</p><p><strong>Fields</strong></p><ul><li><code>study_buses::Vector{Int}</code>: List of internal bus numbers that are retained in the equivalent representation.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create ward reduction with internal bus numbers 101, 102, and 103
reduction = WardReduction([101, 102, 103])

# Apply to system
ybus = Ybus(system; network_reductions=[reduction])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/ward_reduction.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.Ybus"><a class="docstring-binding" href="#PowerNetworkMatrices.Ybus"><code>PowerNetworkMatrices.Ybus</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Ybus{Ax, L &lt;: NTuple{2, Dict}} &lt;: PowerNetworkMatrix{ComplexF32}</code></pre><p>Nodal admittance matrix (Y-bus) representing the electrical admittance relationships between buses in a power system. This N×N sparse complex matrix encodes the network topology and electrical parameters needed for power flow calculations and network analysis.</p><p><strong>Fields</strong></p><ul><li><code>data::SparseArrays.SparseMatrixCSC{ComplexF32, Int}</code>: Sparse Y-bus matrix with complex admittance values</li><li><code>adjacency_data::SparseArrays.SparseMatrixCSC{Int8, Int}</code>: Network connectivity information</li><li><code>axes::Ax</code>: Tuple of bus axis vectors for indexing (bus<em>numbers, bus</em>numbers)</li><li><code>lookup::L</code>: Tuple of lookup dictionaries mapping bus numbers to matrix indices</li><li><code>subnetwork_axes::Dict{Int, Ax}</code>: Bus axes for each electrical island/subnetwork</li><li><code>arc_subnetwork_axis::Dict{Int, Vector{Tuple{Int, Int}}}</code>: Arc axes for each subnetwork</li><li><code>network_reduction_data::NetworkReductionData</code>: Metadata from network reduction operations</li><li><code>arc_admittance_from_to::Union{ArcAdmittanceMatrix, Nothing}</code>: From-to arc admittance matrix</li><li><code>arc_admittance_to_from::Union{ArcAdmittanceMatrix, Nothing}</code>: To-from arc admittance matrix</li></ul><p><strong>Key Features</strong></p><ul><li>Indexed by bus numbers (non-sequential numbering supported)</li><li>Supports network reductions (radial, degree-two, Ward)</li><li>Handles multiple electrical islands/subnetworks</li><li>Optional arc admittance matrices for power flow calculations</li><li>Sparse matrix representation for computational efficiency</li></ul><p><strong>Usage</strong></p><p>The Y-bus is fundamental for:</p><ul><li>Power flow analysis: V = Y⁻¹I</li><li>Short circuit calculations</li><li>Network impedance analysis</li><li>Sensitivity analysis (PTDF/LODF)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Basic Y-bus construction
ybus = Ybus(system)

# With arc admittance matrices for power flow
ybus = Ybus(system; make_arc_admittance_matrices=true)

# With network reductions
ybus = Ybus(system; network_reductions=[RadialReduction(), DegreeTwoReduction()])</code></pre><p><strong>See Also</strong></p><ul><li><a href="#PowerNetworkMatrices.PTDF"><code>PTDF</code></a>: Power Transfer Distribution Factors</li><li><a href="#PowerNetworkMatrices.LODF"><code>LODF</code></a>: Line Outage Distribution Factors</li><li><a href="#PowerNetworkMatrices.NetworkReduction"><code>NetworkReduction</code></a>: Network reduction algorithms</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/Ybus.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.Ybus-Tuple{PowerSystems.System}"><a class="docstring-binding" href="#PowerNetworkMatrices.Ybus-Tuple{PowerSystems.System}"><code>PowerNetworkMatrices.Ybus</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Ybus(
    sys;
    make_arc_admittance_matrices,
    network_reductions,
    include_constant_impedance_loads,
    subnetwork_algorithm
)
</code></pre><pre><code class="language-julia hljs">Ybus(
    sys::PSY.System;
    make_arc_admittance_matrices::Bool = false,
    network_reductions::Vector{NetworkReduction} = NetworkReduction[],
    include_constant_impedance_loads::Bool = true,
    subnetwork_algorithm = iterative_union_find,
    kwargs...
) -&gt; Ybus</code></pre><p>Construct a nodal admittance matrix (Y-bus) from a power system.</p><p>Builds the sparse complex Y-bus matrix representing the electrical admittance relationships between buses in the power system. Handles AC branches, transformers, shunt elements, and network reductions while maintaining connectivity analysis.</p><p><strong>Arguments</strong></p><ul><li><code>sys::PSY.System</code>: Power system to build Y-bus from</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>make_arc_admittance_matrices::Bool=false</code>: Whether to construct arc admittance matrices for power flow</li><li><code>network_reductions::Vector{NetworkReduction}=[]</code>: Network reduction algorithms to apply</li><li><code>include_constant_impedance_loads::Bool=true</code>: Whether to include constant impedance loads as shunt admittances</li><li><code>subnetwork_algorithm=iterative_union_find</code>: Algorithm for finding electrical islands</li></ul><p><strong>Returns</strong></p><ul><li><code>Ybus</code>: Constructed Y-bus matrix with network topology and electrical parameters</li></ul><p><strong>Features</strong></p><ul><li><strong>Branch Support</strong>: Lines, transformers, phase shifters, three-winding transformers</li><li><strong>Shunt Elements</strong>: Fixed admittances, switched admittances, constant impedance loads</li><li><strong>Network Reductions</strong>: Radial, degree-two, Ward reductions for computational efficiency</li><li><strong>Multiple Islands</strong>: Handles disconnected network components with separate reference buses</li><li><strong>Branch Matrices</strong>: Optional from-to/to-from admittance matrices for power flow calculations</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Basic Y-bus construction
ybus = Ybus(system)

# With arc admittance matrices for power flow
ybus = Ybus(system; make_arc_admittance_matrices=true)

# Apply network reductions for computational efficiency
reductions = [RadialReduction(), DegreeTwoReduction()]
ybus = Ybus(system; network_reductions=reductions)

# Exclude constant impedance loads
ybus = Ybus(system; include_constant_impedance_loads=false)</code></pre><p><strong>See Also</strong></p><ul><li><a href="#PowerNetworkMatrices.NetworkReduction"><code>NetworkReduction</code></a>: Network reduction algorithms</li><li><a href="#PowerNetworkMatrices.PTDF"><code>PTDF</code></a>: Power transfer distribution factors</li><li><a href="#PowerNetworkMatrices.LODF"><code>LODF</code></a>: Line outage distribution factors</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/Ybus.jl#L732">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.eachindex-Tuple{VirtualLODF}"><a class="docstring-binding" href="#Base.eachindex-Tuple{VirtualLODF}"><code>Base.eachindex</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">eachindex(vlodf)
</code></pre><p>Gives the cartesian indexes of the LODF matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/virtual_lodf_calculations.jl#L224">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.eachindex-Tuple{VirtualPTDF}"><a class="docstring-binding" href="#Base.eachindex-Tuple{VirtualPTDF}"><code>Base.eachindex</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">eachindex(vptdf)
</code></pre><p>Gives the cartesian indexes of the PTDF matrix (same as the BA one).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/virtual_ptdf_calculations.jl#L221">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.empty!-Tuple{PowerNetworkMatrices.RowCache}"><a class="docstring-binding" href="#Base.empty!-Tuple{PowerNetworkMatrices.RowCache}"><code>Base.empty!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">empty!(cache)
</code></pre><p>Erases the cache.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/row_cache.jl#L64">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.getindex-Tuple{PowerNetworkMatrices.RowCache, Int64}"><a class="docstring-binding" href="#Base.getindex-Tuple{PowerNetworkMatrices.RowCache, Int64}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getindex(cache, key)
</code></pre><p>Gets the row of the stored matrix in cache.</p><p><strong>Arguments</strong></p><ul><li><code>cache::RowCache</code>:       cache where the row vector is going to be saved</li><li><code>key::Int</code>:       row number (corresponding to the enumerated branch index) related to the row vector.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/row_cache.jl#L115">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.getindex-Tuple{VirtualLODF, Any, Any}"><a class="docstring-binding" href="#Base.getindex-Tuple{VirtualLODF, Any, Any}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getindex(vlodf, row, column)
</code></pre><p>Gets the value of the element of the LODF matrix given the row and column indices corresponding to the selected and outage branch respectively. If <code>column</code> is a Colon then the entire row is returned.</p><p><strong>Arguments</strong></p><ul><li><code>vlodf::VirtualLODF</code>:       VirtualLODF struct where to evaluate and store the row values.</li><li><code>row</code>:       selected line name</li><li><code>column</code>:       outage line name. If <code>Colon</code> then get the values of the whole row.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/virtual_lodf_calculations.jl#L267">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.getindex-Tuple{VirtualPTDF, Any, Any}"><a class="docstring-binding" href="#Base.getindex-Tuple{VirtualPTDF, Any, Any}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getindex(vptdf, row, column)
</code></pre><p>Gets the value of the element of the PTDF matrix given the row and column indices corresponding to the branch and buses one respectively. If <code>column</code> is a Colon then the entire row is returned.</p><p><strong>Arguments</strong></p><ul><li><code>vptdf::VirtualPTDF</code>:       VirtualPTDF struct where to evaluate and store the row values.</li><li><code>row</code>:       Branch index.</li><li><code>column</code>:       Bus index. If Colon then get the values of the whole row.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/virtual_ptdf_calculations.jl#L292">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.haskey-Tuple{PowerNetworkMatrices.RowCache, Int64}"><a class="docstring-binding" href="#Base.haskey-Tuple{PowerNetworkMatrices.RowCache, Int64}"><code>Base.haskey</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">haskey(cache, key)
</code></pre><p>Checks if <code>key</code> is present as a key of the dictionary in <code>cache</code></p><p><strong>Arguments</strong></p><ul><li><code>cache::RowCache</code>:       cache where data is stored.</li><li><code>key::Int</code>:       row number (corresponds to the enumerated branch index).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/row_cache.jl#L77">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.isempty-Tuple{PowerNetworkMatrices.RowCache}"><a class="docstring-binding" href="#Base.isempty-Tuple{PowerNetworkMatrices.RowCache}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">isempty(cache)
</code></pre><p>Check if cache is empty.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/row_cache.jl#L57">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.isempty-Tuple{VirtualLODF}"><a class="docstring-binding" href="#Base.isempty-Tuple{VirtualLODF}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">isempty(vlodf)
</code></pre><p>Checks if the any of the fields of VirtualLODF is empty.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/virtual_lodf_calculations.jl#L205">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.isempty-Tuple{VirtualPTDF}"><a class="docstring-binding" href="#Base.isempty-Tuple{VirtualPTDF}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">isempty(vptdf)
</code></pre><p>Checks if the any of the fields of VirtualPTDF is empty.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/virtual_ptdf_calculations.jl#L199">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.length-Tuple{PowerNetworkMatrices.RowCache}"><a class="docstring-binding" href="#Base.length-Tuple{PowerNetworkMatrices.RowCache}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">length(cache)
</code></pre><p>Shows the number of rows stored in cache</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/row_cache.jl#L131">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.setindex!-Tuple{VirtualLODF, Any, CartesianIndex}"><a class="docstring-binding" href="#Base.setindex!-Tuple{VirtualLODF, Any, CartesianIndex}"><code>Base.setindex!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">setindex!(_, _, _)
</code></pre><p>!!! STILL TO IMPLEMENT !!!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/virtual_lodf_calculations.jl#L295">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.setindex!-Tuple{VirtualLODF, Any, Vararg{Any}}"><a class="docstring-binding" href="#Base.setindex!-Tuple{VirtualLODF, Any, Vararg{Any}}"><code>Base.setindex!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">setindex!(_, _, idx)
</code></pre><p>!!! STILL TO IMPLEMENT !!!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/virtual_lodf_calculations.jl#L290">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.setindex!-Tuple{VirtualPTDF, Any, CartesianIndex}"><a class="docstring-binding" href="#Base.setindex!-Tuple{VirtualPTDF, Any, CartesianIndex}"><code>Base.setindex!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">setindex!(_, _, _)
</code></pre><p>!!! STILL TO IMPLEMENT !!!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/virtual_ptdf_calculations.jl#L320">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.setindex!-Tuple{VirtualPTDF, Any, Vararg{Any}}"><a class="docstring-binding" href="#Base.setindex!-Tuple{VirtualPTDF, Any, Vararg{Any}}"><code>Base.setindex!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">setindex!(_, _, idx)
</code></pre><p>!!! STILL TO IMPLEMENT !!!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/virtual_ptdf_calculations.jl#L315">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.setindex!-Union{Tuple{T}, Tuple{PowerNetworkMatrices.RowCache{T}, T, Int64}} where T&lt;:Union{SparseArrays.SparseVector{Float64}, Vector{Float64}}"><a class="docstring-binding" href="#Base.setindex!-Union{Tuple{T}, Tuple{PowerNetworkMatrices.RowCache{T}, T, Int64}} where T&lt;:Union{SparseArrays.SparseVector{Float64}, Vector{Float64}}"><code>Base.setindex!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">setindex!(cache, val, key)
</code></pre><p>Allocates vector as row of the matrix saved in cache.</p><p><strong>Arguments</strong></p><ul><li><code>cache::RowCache</code>:       cache where the row vector is going to be saved</li><li><code>val::Union{Vector{Float64}, SparseArrays.SparseVector{Float64}}</code>:       vector to be saved</li><li><code>key::Int</code>:       row number (corresponding to the enumerated branch index) related to the input row vector</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/row_cache.jl#L90">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.size-Tuple{VirtualLODF}"><a class="docstring-binding" href="#Base.size-Tuple{VirtualLODF}"><code>Base.size</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">size(vlodf)
</code></pre><p>Shows the size of the whole LODF matrix, not the number of rows stored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/virtual_lodf_calculations.jl#L219">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.size-Tuple{VirtualPTDF}"><a class="docstring-binding" href="#Base.size-Tuple{VirtualPTDF}"><code>Base.size</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">size(vptdf)
</code></pre><p>Gives the size of the whole PTDF matrix, not the number of rows stored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/virtual_ptdf_calculations.jl#L216">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices._calculate_PTDF_matrix_DENSE-Tuple{SparseArrays.SparseMatrixCSC{Int8, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Set{Int64}, Vector{Float64}}"><a class="docstring-binding" href="#PowerNetworkMatrices._calculate_PTDF_matrix_DENSE-Tuple{SparseArrays.SparseMatrixCSC{Int8, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Set{Int64}, Vector{Float64}}"><code>PowerNetworkMatrices._calculate_PTDF_matrix_DENSE</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_calculate_PTDF_matrix_DENSE(
    A,
    BA,
    ref_bus_positions,
    dist_slack
)
</code></pre><p>Function for internal use only.</p><p>Computes the PTDF matrix by means of the LAPACK and BLAS functions for dense matrices.</p><p><strong>Arguments</strong></p><ul><li><code>A::Matrix{Int8}</code>:       Incidence Matrix</li><li><code>BA::Matrix{T} where {T &lt;: Union{Float32, Float64}}</code>:       BA matrix</li><li><code>ref_bus_positions::Set{Int}</code>:       vector containing the indexes of the reference slack buses.</li><li><code>dist_slack::Vector{Float64})</code>:       vector containing the weights for the distributed slacks.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/ptdf_calculations.jl#L181">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices._calculate_PTDF_matrix_KLU-Tuple{SparseArrays.SparseMatrixCSC{Int8, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Set{Int64}, Vector{Float64}}"><a class="docstring-binding" href="#PowerNetworkMatrices._calculate_PTDF_matrix_KLU-Tuple{SparseArrays.SparseMatrixCSC{Int8, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Set{Int64}, Vector{Float64}}"><code>PowerNetworkMatrices._calculate_PTDF_matrix_KLU</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_calculate_PTDF_matrix_KLU(
    A,
    BA,
    ref_bus_positions,
    dist_slack
)
</code></pre><p>Function for internal use only.</p><p>Computes the PTDF matrix by means of the KLU.LU factorization for sparse matrices.</p><p><strong>Arguments</strong></p><ul><li><code>A::SparseArrays.SparseMatrixCSC{Int8, Int}</code>:       Incidence Matrix</li><li><code>BA::SparseArrays.SparseMatrixCSC{Float64, Int}</code>:       BA matrix</li><li><code>ref_bus_positions::Set{Int}</code>:       vector containing the indexes of the reference slack buses.</li><li><code>dist_slack::Vector{Float64}</code>:       vector containing the weights for the distributed slacks.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/ptdf_calculations.jl#L117">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices._get_complete_chain-Tuple{SparseArrays.SparseMatrixCSC, Int64, Set{Int64}, Set{Int64}}"><a class="docstring-binding" href="#PowerNetworkMatrices._get_complete_chain-Tuple{SparseArrays.SparseMatrixCSC, Int64, Set{Int64}, Set{Int64}}"><code>PowerNetworkMatrices._get_complete_chain</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_get_complete_chain(
    adj_matrix,
    start_node,
    reduced_indices,
    irreducible_indices
)
</code></pre><pre><code class="language-julia hljs">_get_complete_chain(adj_matrix::SparseArrays.SparseMatrixCSC, start_node::Int, reduced_indices::Set{Int}, irreducible_indices::Set{Int})</code></pre><p>Build a complete chain of degree-2 nodes starting from a given node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/degree_two_reduction.jl#L226">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices._get_degree2_nodes-Tuple{SparseArrays.SparseMatrixCSC, Set{Int64}}"><a class="docstring-binding" href="#PowerNetworkMatrices._get_degree2_nodes-Tuple{SparseArrays.SparseMatrixCSC, Set{Int64}}"><code>PowerNetworkMatrices._get_degree2_nodes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_get_degree2_nodes(adj_matrix, irreducible_indices)
</code></pre><pre><code class="language-julia hljs">_get_degree2_nodes(adj_matrix::SparseArrays.SparseMatrixCSC, irreducible_indices::Set{Int})</code></pre><p>Return all degree-2 nodes in the adjacency matrix, excluding irreducible indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/degree_two_reduction.jl#L305">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices._get_equivalent_physical_branch_parameters-Tuple{Matrix{ComplexF32}}"><a class="docstring-binding" href="#PowerNetworkMatrices._get_equivalent_physical_branch_parameters-Tuple{Matrix{ComplexF32}}"><code>PowerNetworkMatrices._get_equivalent_physical_branch_parameters</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_get_equivalent_physical_branch_parameters(equivalent_ybus)
</code></pre><pre><code class="language-julia hljs">get_equivalent_physical_branch_parameters(equivalent_ybus::Matrix{ComplexF32})</code></pre><p>Takes as input a 2x2 Matrix{ComplexF32} representing the Ybus contribution of either a BranchesParallel or BranchesSeries object. Returns a dictionary of equivalent parameters, matching the PowerModels data format.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/common.jl#L300">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices._get_neighbors-Tuple{SparseArrays.SparseMatrixCSC, Int64}"><a class="docstring-binding" href="#PowerNetworkMatrices._get_neighbors-Tuple{SparseArrays.SparseMatrixCSC, Int64}"><code>PowerNetworkMatrices._get_neighbors</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_get_neighbors(adj_matrix, node)
</code></pre><pre><code class="language-julia hljs">_get_neighbors(adj_matrix::SparseArrays.SparseMatrixCSC, node::Int)</code></pre><p>Get all neighbors of a given node from the adjacency matrix. For undirected graphs, checks both directions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/degree_two_reduction.jl#L214">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices._get_partial_chain_recursive!-Tuple{Vector{Int64}, SparseArrays.SparseMatrixCSC, Int64, Int64, Set{Int64}, Set{Int64}}"><a class="docstring-binding" href="#PowerNetworkMatrices._get_partial_chain_recursive!-Tuple{Vector{Int64}, SparseArrays.SparseMatrixCSC, Int64, Int64, Set{Int64}, Set{Int64}}"><code>PowerNetworkMatrices._get_partial_chain_recursive!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_get_partial_chain_recursive!(
    current_chain,
    adj_matrix,
    current_node,
    prev_node,
    reduced_indices,
    irreducible_indices
)
</code></pre><pre><code class="language-julia hljs">_get_partial_chain(adj_matrix::SparseArrays.SparseMatrixCSC,
                  current_node::Int,
                  prev_node::Int,
                  reduced_indices::Set{Int},
                  irreducible_indices::Set{Int})</code></pre><p>Recursively build a chain in one direction from current<em>node, avoiding prev</em>node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/degree_two_reduction.jl#L260">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices._is_2degree_node-Tuple{SparseArrays.SparseMatrixCSC, Int64}"><a class="docstring-binding" href="#PowerNetworkMatrices._is_2degree_node-Tuple{SparseArrays.SparseMatrixCSC, Int64}"><code>PowerNetworkMatrices._is_2degree_node</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_is_2degree_node(adj_matrix, node)
</code></pre><pre><code class="language-julia hljs">_is_2degree_node(adj_matrix::SparseArrays.SparseMatrixCSC, node::Int)</code></pre><p>Checks if a node has exactly two connections in the network.</p><p><strong>Arguments</strong></p><ul><li><code>adj_matrix::SparseArrays.SparseMatrixCSC</code>: The adjacency matrix of the network.</li><li><code>node::Int</code>: The index of the node to check.</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if the node has exactly two neighbors, <code>false</code> otherwise.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/degree_two_reduction.jl#L197">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices._is_final_node-Tuple{Int64, SparseArrays.SparseMatrixCSC, Set{Int64}, Set{Int64}}"><a class="docstring-binding" href="#PowerNetworkMatrices._is_final_node-Tuple{Int64, SparseArrays.SparseMatrixCSC, Set{Int64}, Set{Int64}}"><code>PowerNetworkMatrices._is_final_node</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_is_final_node(
    node,
    adj_matrix,
    reduced_indices,
    irreducible_indices
)
</code></pre><pre><code class="language-julia hljs">_is_final_node(node::Int, adj_matrix::SparseArrays.SparseMatrixCSC, reduced_indices::Set{Int})</code></pre><p>Determines if a node is a final node in a path traversal.</p><p><strong>Arguments</strong></p><ul><li><code>node::Int</code>: The index of the node to check.</li><li><code>adj_matrix::SparseArrays.SparseMatrixCSC</code>: The adjacency matrix of the network.</li><li><code>reduced_indices::Set{Int}</code>: Set of indices that have already been reduced.</li><li><code>irreducible_indices::Set{Int}</code>: Set of indices that should not be reduced.</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if the node is a final node, <code>false</code> otherwise.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/degree_two_reduction.jl#L165">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices._should_visit_node-Tuple{Int64, Set{Int64}, Set{Int64}}"><a class="docstring-binding" href="#PowerNetworkMatrices._should_visit_node-Tuple{Int64, Set{Int64}, Set{Int64}}"><code>PowerNetworkMatrices._should_visit_node</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_should_visit_node(
    node,
    reduced_indices,
    irreducible_indices
)
</code></pre><pre><code class="language-julia hljs">_should_visit_node(node::Int, reduced_indices::Set{Int}, irreducible_indices::Set{Int})</code></pre><p>Determines whether a node should be visited during network traversal.</p><p><strong>Arguments</strong></p><ul><li><code>node::Int</code>: The index of the node to check.</li><li><code>reduced_indices::Set{Int}</code>: Set of indices that have already been reduced.</li><li><code>irreducible_indices::Set{Int}</code>: Set of indices that cannot be reduced.</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if the node should be visited, <code>false</code> otherwise.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/degree_two_reduction.jl#L138">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices._ybus!-Tuple{Vector{ComplexF32}, Vector{ComplexF32}, Vector{ComplexF32}, Vector{ComplexF32}, PowerSystems.ACTransmission, Dict{Int64, Int64}, Int64, Vector{Int64}, Vector{Int64}, NetworkReductionData, SparseArrays.SparseMatrixCSC{Int8, Int64}}"><a class="docstring-binding" href="#PowerNetworkMatrices._ybus!-Tuple{Vector{ComplexF32}, Vector{ComplexF32}, Vector{ComplexF32}, Vector{ComplexF32}, PowerSystems.ACTransmission, Dict{Int64, Int64}, Int64, Vector{Int64}, Vector{Int64}, NetworkReductionData, SparseArrays.SparseMatrixCSC{Int8, Int64}}"><code>PowerNetworkMatrices._ybus!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_ybus!(
    y11,
    y12,
    y21,
    y22,
    br,
    num_bus,
    branch_ix,
    fb,
    tb,
    nr,
    adj
)
</code></pre><p>Handles ybus entries for most 2-node AC branches. The types handled here are: <code>Line</code>, <code>DiscreteControlledACBranch</code>, <code>Transformer2W</code>, <code>TapTransformer</code>, and <code>PhaseShiftingTransformer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/Ybus.jl#L487">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.add_branch_entries_to_indexing_maps!-Tuple{Dict{Int64, Int64}, Int64, NetworkReductionData, Vector{Int64}, Vector{Int64}, SparseArrays.SparseMatrixCSC{Int8, Int64}, PowerSystems.ACTransmission}"><a class="docstring-binding" href="#PowerNetworkMatrices.add_branch_entries_to_indexing_maps!-Tuple{Dict{Int64, Int64}, Int64, NetworkReductionData, Vector{Int64}, Vector{Int64}, SparseArrays.SparseMatrixCSC{Int8, Int64}, PowerSystems.ACTransmission}"><code>PowerNetworkMatrices.add_branch_entries_to_indexing_maps!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_branch_entries_to_indexing_maps!(
    num_bus,
    branch_ix,
    nr,
    fb,
    tb,
    adj,
    br
)
</code></pre><pre><code class="language-julia hljs">add_branch_entries_to_indexing_maps!(
    num_bus::Dict{Int, Int},
    branch_ix::Int,
    nr::NetworkReductionData,
    fb::Vector{Int},
    tb::Vector{Int},
    adj::SparseArrays.SparseMatrixCSC{Int8, Int},
    br::PSY.ACTransmission
)</code></pre><p>Update indexing structures when adding an AC transmission branch to the Y-bus.</p><p>This function handles the bookkeeping required when adding a branch: updates network reduction mappings, sets adjacency matrix entries, and records from/to bus indices for the branch in the Y-bus construction vectors.</p><p><strong>Arguments</strong></p><ul><li><code>num_bus::Dict{Int, Int}</code>: Mapping from bus numbers to matrix indices</li><li><code>branch_ix::Int</code>: Branch index in the vectors</li><li><code>nr::NetworkReductionData</code>: Network reduction data to update</li><li><code>fb::Vector{Int}</code>: Vector of from-bus indices</li><li><code>tb::Vector{Int}</code>: Vector of to-bus indices</li><li><code>adj::SparseArrays.SparseMatrixCSC{Int8, Int}</code>: Adjacency matrix</li><li><code>br::PSY.ACTransmission</code>: AC transmission branch to add</li></ul><p><strong>Implementation Details</strong></p><ul><li>Calls <code>add_to_branch_maps!()</code> to update reduction mappings</li><li>Updates adjacency matrix with branch connectivity</li><li>Records bus indices in from/to vectors for sparse matrix construction</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/Ybus.jl#L330">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.add_branch_entries_to_ybus!-Tuple{Vector{ComplexF32}, Vector{ComplexF32}, Vector{ComplexF32}, Vector{ComplexF32}, Int64, PowerSystems.ACTransmission}"><a class="docstring-binding" href="#PowerNetworkMatrices.add_branch_entries_to_ybus!-Tuple{Vector{ComplexF32}, Vector{ComplexF32}, Vector{ComplexF32}, Vector{ComplexF32}, Int64, PowerSystems.ACTransmission}"><code>PowerNetworkMatrices.add_branch_entries_to_ybus!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_branch_entries_to_ybus!(
    y11,
    y12,
    y21,
    y22,
    branch_ix,
    br
)
</code></pre><pre><code class="language-julia hljs">add_branch_entries_to_ybus!(
    y11::Vector{ComplexF32},
    y12::Vector{ComplexF32},
    y21::Vector{ComplexF32},
    y22::Vector{ComplexF32},
    branch_ix::Int,
    br::PSY.ACTransmission
)</code></pre><p>Add Y-bus matrix entries for an AC transmission branch to the admittance vectors.</p><p>This function calculates the 2×2 Y-bus entries for a branch using <code>ybus_branch_entries()</code> and stores them in the provided vectors at the specified index. The entries represent the Pi-model admittances: Y11 (from-bus self), Y12 (from-to mutual), Y21 (to-from mutual), and Y22 (to-bus self).</p><p><strong>Arguments</strong></p><ul><li><code>y11::Vector{ComplexF32}</code>: Vector for from-bus self admittances</li><li><code>y12::Vector{ComplexF32}</code>: Vector for from-to mutual admittances</li><li><code>y21::Vector{ComplexF32}</code>: Vector for to-from mutual admittances</li><li><code>y22::Vector{ComplexF32}</code>: Vector for to-bus self admittances</li><li><code>branch_ix::Int</code>: Index where to store the branch entries</li><li><code>br::PSY.ACTransmission</code>: AC transmission branch</li></ul><p><strong>Implementation Details</strong></p><ul><li>Calls <code>ybus_branch_entries()</code> to compute Pi-model parameters</li><li>Stores results directly in the provided vectors</li><li>Used during Y-bus matrix assembly process</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/Ybus.jl#L284">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.add_segment_to_ybus!-Tuple{PowerNetworkMatrices.BranchesParallel, Vector{ComplexF32}, Vector{ComplexF32}, Vector{ComplexF32}, Vector{ComplexF32}, Vector{Int64}, Vector{Int64}, Int64, Symbol}"><a class="docstring-binding" href="#PowerNetworkMatrices.add_segment_to_ybus!-Tuple{PowerNetworkMatrices.BranchesParallel, Vector{ComplexF32}, Vector{ComplexF32}, Vector{ComplexF32}, Vector{ComplexF32}, Vector{Int64}, Vector{Int64}, Int64, Symbol}"><code>PowerNetworkMatrices.add_segment_to_ybus!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_segment_to_ybus!(
    segment,
    y11,
    y12,
    y21,
    y22,
    fb,
    tb,
    ix,
    segment_orientation
)
</code></pre><pre><code class="language-julia hljs">add_segment_to_ybus!(
    segment::BranchesParallel,
    y11::Vector{ComplexF32},
    y12::Vector{ComplexF32},
    y21::Vector{ComplexF32},
    y22::Vector{ComplexF32},
    fb::Vector{Int},
    tb::Vector{Int},
    ix::Int,
    segment_orientation::Symbol
)</code></pre><p>Add multiple parallel branches as a single segment to Y-bus vectors.</p><p>Handles the case where a segment in a series chain consists of multiple parallel branches between the same pair of buses. Each branch in the set is added to the same Y-bus position, effectively combining their admittances.</p><p><strong>Arguments</strong></p><ul><li><code>segment::BranchesParallel</code>: Set of parallel AC transmission branches</li><li><code>y11::Vector{ComplexF32}</code>: Vector for from-bus self admittances</li><li><code>y12::Vector{ComplexF32}</code>: Vector for from-to mutual admittances</li><li><code>y21::Vector{ComplexF32}</code>: Vector for to-from mutual admittances</li><li><code>y22::Vector{ComplexF32}</code>: Vector for to-bus self admittances</li><li><code>fb::Vector{Int}</code>: Vector for from-bus indices</li><li><code>tb::Vector{Int}</code>: Vector for to-bus indices</li><li><code>ix::Int</code>: Index position for the segment</li><li><code>segment_orientation::Symbol</code>: <code>:FromTo</code> or <code>:ToFrom</code> orientation</li></ul><p><strong>Implementation Details</strong></p><ul><li>Iterates through all branches in the parallel set</li><li>Calls single-branch <code>add_segment_to_ybus!()</code> for each branch</li><li>Y-bus entries are accumulated at the same index position</li><li>Results in equivalent admittance of parallel combination</li></ul><p><strong>See Also</strong></p><ul><li><a href="#PowerNetworkMatrices.add_segment_to_ybus!-Tuple{PowerNetworkMatrices.BranchesParallel, Vector{ComplexF32}, Vector{ComplexF32}, Vector{ComplexF32}, Vector{ComplexF32}, Vector{Int64}, Vector{Int64}, Int64, Symbol}"><code>add_segment_to_ybus!</code></a>: Single branch variant</li><li><a href="../../tutorials/tutorial_DegreeTwoReduction/#DegreeTwoReduction"><code>DegreeTwoReduction</code></a>: Series chain elimination</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/Ybus.jl#L1643">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.add_segment_to_ybus!-Tuple{PowerSystems.ACTransmission, Vector{ComplexF32}, Vector{ComplexF32}, Vector{ComplexF32}, Vector{ComplexF32}, Vector{Int64}, Vector{Int64}, Int64, Symbol}"><a class="docstring-binding" href="#PowerNetworkMatrices.add_segment_to_ybus!-Tuple{PowerSystems.ACTransmission, Vector{ComplexF32}, Vector{ComplexF32}, Vector{ComplexF32}, Vector{ComplexF32}, Vector{Int64}, Vector{Int64}, Int64, Symbol}"><code>PowerNetworkMatrices.add_segment_to_ybus!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_segment_to_ybus!(
    segment,
    y11,
    y12,
    y21,
    y22,
    fb,
    tb,
    ix,
    segment_orientation
)
</code></pre><pre><code class="language-julia hljs">add_segment_to_ybus!(
    segment::PSY.ACTransmission
    y11::Vector{ComplexF32},
    y12::Vector{ComplexF32},
    y21::Vector{ComplexF32},
    y22::Vector{ComplexF32},
    fb::Vector{Int},
    tb::Vector{Int},
    ix::Int,
    segment_orientation::Symbol
)</code></pre><p>Add a branch segment to Y-bus vectors during series chain reduction.</p><p>Adds the Y-bus entries for a single segment (branch or transformer winding) to the admittance vectors, handling the proper orientation. Used when building equivalent Y-bus entries for series chains of degree-two buses.</p><p><strong>Arguments</strong></p><ul><li><code>segment::Union{PSY.ACTransmission, Tuple{PSY.ThreeWindingTransformer, Int}}</code>: Branch segment to add</li><li><code>y11::Vector{ComplexF32}</code>: Vector for from-bus self admittances</li><li><code>y12::Vector{ComplexF32}</code>: Vector for from-to mutual admittances</li><li><code>y21::Vector{ComplexF32}</code>: Vector for to-from mutual admittances</li><li><code>y22::Vector{ComplexF32}</code>: Vector for to-bus self admittances</li><li><code>fb::Vector{Int}</code>: Vector for from-bus indices</li><li><code>tb::Vector{Int}</code>: Vector for to-bus indices</li><li><code>ix::Int</code>: Index position for the segment</li><li><code>segment_orientation::Symbol</code>: <code>:FromTo</code> or <code>:ToFrom</code> orientation</li></ul><p><strong>Implementation Details</strong></p><ul><li>Computes Pi-model entries using <code>ybus_branch_entries()</code></li><li>Handles orientation by swapping entries for <code>:ToFrom</code></li><li>Sets bus indices to consecutive values (ix, ix+1) for chain building</li><li>Used in degree-two network reduction algorithms</li></ul><p><strong>See Also</strong></p><ul><li><a href="../../tutorials/tutorial_DegreeTwoReduction/#DegreeTwoReduction"><code>DegreeTwoReduction</code></a>: Degree-two bus elimination</li><li><a href="#PowerNetworkMatrices.ybus_branch_entries-Tuple{PowerNetworkMatrices.ThreeWindingTransformerWinding}"><code>ybus_branch_entries</code></a>: Pi-model computation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/Ybus.jl#L1574">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.add_to_branch_maps!-Tuple{NetworkReductionData, PowerSystems.Arc, PowerSystems.Arc, PowerSystems.Arc, PowerSystems.ThreeWindingTransformer}"><a class="docstring-binding" href="#PowerNetworkMatrices.add_to_branch_maps!-Tuple{NetworkReductionData, PowerSystems.Arc, PowerSystems.Arc, PowerSystems.Arc, PowerSystems.ThreeWindingTransformer}"><code>PowerNetworkMatrices.add_to_branch_maps!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_to_branch_maps!(
    nr,
    primary_star_arc,
    secondary_star_arc,
    tertiary_star_arc,
    br
)
</code></pre><pre><code class="language-julia hljs">add_to_branch_maps!(
    nr::NetworkReductionData,
    primary_star_arc::PSY.Arc,
    secondary_star_arc::PSY.Arc,
    tertiary_star_arc::PSY.Arc,
    br::PSY.ThreeWindingTransformer
)</code></pre><p>Add a three-winding transformer to the transformer mapping in NetworkReductionData.</p><p>Three-winding transformers are modeled using a star (wye) configuration with three arcs connecting to a virtual star bus. Each available winding is mapped separately.</p><p><strong>Arguments</strong></p><ul><li><code>nr::NetworkReductionData</code>: Network reduction data to modify</li><li><code>primary_star_arc::PSY.Arc</code>: Arc for primary winding</li><li><code>secondary_star_arc::PSY.Arc</code>: Arc for secondary winding</li><li><code>tertiary_star_arc::PSY.Arc</code>: Arc for tertiary winding</li><li><code>br::PSY.ThreeWindingTransformer</code>: Three-winding transformer to add</li></ul><p><strong>Implementation Details</strong></p><ul><li>Only adds arcs for available windings (checked via PSY.get<em>available</em>*)</li><li>Maintains transformer3W<em>map and reverse</em>transformer3W_map</li><li>Each winding is numbered (1=primary, 2=secondary, 3=tertiary)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/Ybus.jl#L228">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.add_to_branch_maps!-Union{Tuple{T}, Tuple{NetworkReductionData, PowerSystems.Arc, T}} where T&lt;:PowerSystems.ACTransmission"><a class="docstring-binding" href="#PowerNetworkMatrices.add_to_branch_maps!-Union{Tuple{T}, Tuple{NetworkReductionData, PowerSystems.Arc, T}} where T&lt;:PowerSystems.ACTransmission"><code>PowerNetworkMatrices.add_to_branch_maps!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_to_branch_maps!(nr, arc, br)
</code></pre><pre><code class="language-julia hljs">add_to_branch_maps!(nr::NetworkReductionData, arc::PSY.Arc, br::PSY.ACTransmission)</code></pre><p>Add an AC transmission branch to the appropriate branch mapping in NetworkReductionData.</p><p>This function categorizes branches as direct (one-to-one), parallel (multiple branches between same buses), or creates new mappings as needed. It maintains both forward and reverse lookup dictionaries for efficient access.</p><p><strong>Arguments</strong></p><ul><li><code>nr::NetworkReductionData</code>: Network reduction data to modify</li><li><code>arc::PSY.Arc</code>: Arc representing the branch connection</li><li><code>br::PSY.ACTransmission</code>: AC transmission branch to add</li></ul><p><strong>Implementation Details</strong></p><ul><li>If arc already has a direct branch, converts to parallel mapping</li><li>If arc already has parallel branches, adds to existing set</li><li>Otherwise creates new direct mapping</li><li>Maintains reverse lookup consistency</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/Ybus.jl#L179">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.assign_reference_buses!-Tuple{Dict{Int64, Set{Int64}}, Set{Int64}}"><a class="docstring-binding" href="#PowerNetworkMatrices.assign_reference_buses!-Tuple{Dict{Int64, Set{Int64}}, Set{Int64}}"><code>PowerNetworkMatrices.assign_reference_buses!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">assign_reference_buses!(subnetworks, ref_buses)
</code></pre><p>Takes the reference bus numbers and re-assigns the keys in the subnetwork dictionaries to use the reference bus withing each subnetwork.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/subnetworks.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.build_reduced_ybus-Tuple{Ybus, PowerSystems.System, NetworkReduction}"><a class="docstring-binding" href="#PowerNetworkMatrices.build_reduced_ybus-Tuple{Ybus, PowerSystems.System, NetworkReduction}"><code>PowerNetworkMatrices.build_reduced_ybus</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">build_reduced_ybus(ybus, sys, network_reduction)
</code></pre><pre><code class="language-julia hljs">build_reduced_ybus(
    ybus::Ybus,
    sys::PSY.System,
    network_reduction::NetworkReduction
) -&gt; Ybus</code></pre><p>Apply a network reduction algorithm to a Y-bus matrix.</p><p>Computes the network reduction data using the specified reduction algorithm and then applies the reduction to create a new Y-bus matrix with eliminated buses and branches. The electrical behavior of the remaining network is preserved.</p><p><strong>Arguments</strong></p><ul><li><code>ybus::Ybus</code>: Original Y-bus matrix to reduce</li><li><code>sys::PSY.System</code>: Power system for validation and data access</li><li><code>network_reduction::NetworkReduction</code>: Reduction algorithm to apply</li></ul><p><strong>Returns</strong></p><ul><li><code>Ybus</code>: New reduced Y-bus matrix with eliminated elements</li></ul><p><strong>Implementation Details</strong></p><ul><li>Calls <code>get_reduction()</code> to compute elimination data</li><li>Applies reduction via <code>_apply_reduction()</code></li><li>Preserves electrical equivalence of remaining network</li><li>Updates all indexing and mapping structures</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">ybus = Ybus(system)
reduction = RadialReduction()
reduced_ybus = build_reduced_ybus(ybus, system, reduction)
println(&quot;Original buses: &quot;, length(get_bus_axis(ybus)))
println(&quot;Reduced buses: &quot;, length(get_bus_axis(reduced_ybus)))</code></pre><p><strong>See Also</strong></p><ul><li><a href="#PowerNetworkMatrices.NetworkReduction"><code>NetworkReduction</code></a>: Reduction algorithm types</li><li><a href="#PowerNetworkMatrices.get_reduction-Tuple{Ybus, PowerSystems.System, RadialReduction}"><code>get_reduction</code></a>: Reduction data computation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/Ybus.jl#L1145">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.calculate_ABA_matrix-Tuple{SparseArrays.SparseMatrixCSC{Int8, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Set{Int64}}"><a class="docstring-binding" href="#PowerNetworkMatrices.calculate_ABA_matrix-Tuple{SparseArrays.SparseMatrixCSC{Int8, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Set{Int64}}"><code>PowerNetworkMatrices.calculate_ABA_matrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calculate_ABA_matrix(A, BA, ref_bus_positions)
</code></pre><p>Evaluates the ABA matrix given the System&#39;s Incidence matrix (A), BA matrix and reference bus positions.</p><p><strong>Arguments</strong></p><ul><li><code>A::SparseArrays.SparseMatrixCSC{Int8, Int}</code>:       Incidence matrix.</li><li><code>BA::SparseArrays.SparseMatrixCSC{Float64, Int}</code>       BA matrix.</li></ul><p>NOTE:</p><ul><li>evaluates A with &quot;calculate<em>A</em>matrix&quot;, or extract A.data (if A::IncidenceMatrix)</li><li>evaluates BA with &quot;calculate<em>BA</em>matrix&quot;, or extract BA.data (if A::BA_Matrix)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/common.jl#L241">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.calculate_radial_arcs-Tuple{SparseArrays.SparseMatrixCSC{Int8, Int64}, Dict{Tuple{Int64, Int64}, Int64}, Dict{Int64, Int64}, Set{Int64}}"><a class="docstring-binding" href="#PowerNetworkMatrices.calculate_radial_arcs-Tuple{SparseArrays.SparseMatrixCSC{Int8, Int64}, Dict{Tuple{Int64, Int64}, Int64}, Dict{Int64, Int64}, Set{Int64}}"><code>PowerNetworkMatrices.calculate_radial_arcs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calculate_radial_arcs(
    A,
    arc_map,
    bus_map,
    ref_bus_positions
)
</code></pre><pre><code class="language-julia hljs">calculate_radial_arcs(A::SparseArrays.SparseMatrixCSC{Int8, Int}, arc_map::Dict{Tuple{Int, Int}, Int}, bus_map::Dict{Int, Int}, ref_bus_positions::Set{Int})</code></pre><p>Identify and calculate radial branches and buses that can be eliminated from the network model by analyzing the topological structure of the incidence matrix. Radial elements are leaf nodes with only one connection that do not affect the electrical behavior of the core network.</p><p><strong>Arguments</strong></p><ul><li><code>A::SparseArrays.SparseMatrixCSC{Int8, Int}</code>:       The incidence matrix data representing bus-branch connectivity structure</li><li><code>arc_map::Dict{Tuple{Int, Int}, Int}</code>:       Dictionary mapping branch endpoint pairs (from<em>bus, to</em>bus) to matrix row indices</li><li><code>bus_map::Dict{Int, Int}</code>:       Dictionary mapping bus numbers to matrix column indices</li><li><code>ref_bus_positions::Set{Int}</code>:       Set of matrix column indices corresponding to reference (slack) buses that cannot be eliminated</li></ul><p><strong>Returns</strong></p><ul><li><code>bus_reduction_map::Dict{Int, Set{Int}}</code>:       Dictionary mapping parent bus numbers to sets of child buses that can be reduced to the parent</li><li><code>reverse_bus_search_map::Dict{Int, Int}</code>:       Dictionary mapping each bus number to its ultimate parent bus after all reductions</li><li><code>radial_arcs::Set{Tuple{Int, Int}}</code>:       Set of branch endpoint pairs representing radial branches that can be eliminated</li><li><code>final_arc_map::Dict{Tuple{Int, Int}, Int}</code>:       Dictionary mapping each final arc to the surviving bus number it connects to       (the arc whose admittance must be subtracted from the surviving bus&#39;s diagonal)</li></ul><p><strong>Algorithm Overview</strong></p><ol><li><strong>Leaf Detection</strong>: Identifies buses with exactly one connection (radial buses)</li><li><strong>Reference Protection</strong>: Preserves reference buses from elimination regardless of connectivity</li><li><strong>Upstream Tracing</strong>: Traces from radial buses toward the core network to find parent buses</li><li><strong>Cascading Reduction</strong>: Recursively eliminates buses that become radial after initial reductions</li><li><strong>Parallel Processing</strong>: Uses multithreading for efficient analysis of large networks</li></ol><p><strong>Network Topology Preservation</strong></p><ul><li><strong>Electrical Equivalence</strong>: Ensures reduced network maintains same electrical behavior</li><li><strong>Connectivity Integrity</strong>: Preserves essential network connectivity and reference structure</li><li><strong>Reduction Validity</strong>: Only eliminates elements that truly don&#39;t affect network analysis</li><li><strong>Reversibility</strong>: Maintains mapping information for potential reconstruction if needed</li></ul><p><strong>Use Cases</strong></p><ul><li><strong>Network Simplification</strong>: Reduces computational burden by eliminating unnecessary elements</li><li><strong>Matrix Conditioning</strong>: Improves numerical properties of network matrices</li><li><strong>Analysis Acceleration</strong>: Speeds up power flow and other network computations</li><li><strong>Memory Optimization</strong>: Reduces storage requirements for large network models</li></ul><p><strong>Implementation Notes</strong></p><ul><li>Uses sparse matrix operations for efficiency with large, sparse networks</li><li>Handles edge cases like fully radial networks and isolated islands</li><li>Maintains thread safety for concurrent processing of network analysis</li><li>Provides comprehensive mapping for traceability and debugging</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/radial_reduction.jl#L151">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.check_cache_size!-Tuple{PowerNetworkMatrices.RowCache}"><a class="docstring-binding" href="#PowerNetworkMatrices.check_cache_size!-Tuple{PowerNetworkMatrices.RowCache}"><code>PowerNetworkMatrices.check_cache_size!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">check_cache_size!(cache; new_add)
</code></pre><p>Check saved rows in cache and delete one not belonging to <code>persistent_cache_keys</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/row_cache.jl#L163">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.depth_first_search-Tuple{SparseArrays.SparseMatrixCSC, Vector{Int64}}"><a class="docstring-binding" href="#PowerNetworkMatrices.depth_first_search-Tuple{SparseArrays.SparseMatrixCSC, Vector{Int64}}"><code>PowerNetworkMatrices.depth_first_search</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">depth_first_search(M, bus_numbers)
</code></pre><pre><code class="language-julia hljs">depth_first_search(M::SparseArrays.SparseMatrixCSC, bus_numbers::Vector{Int})</code></pre><p>Find connected subnetworks using depth-first search algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>M::SparseArrays.SparseMatrixCSC</code>: Sparse matrix representing network connectivity</li><li><code>bus_numbers::Vector{Int}</code>: Vector containing the bus numbers of the system</li></ul><p><strong>Returns</strong></p><ul><li><code>Dict{Int, Set{Int}}</code>: Dictionary mapping representative bus numbers to sets of connected buses</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/connectivity_checks.jl#L168">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.factorize-Union{Tuple{ABA_Matrix{Ax, L, Nothing}}, Tuple{L}, Tuple{Ax}} where {Ax, L&lt;:Tuple{Dict, Dict}}"><a class="docstring-binding" href="#PowerNetworkMatrices.factorize-Union{Tuple{ABA_Matrix{Ax, L, Nothing}}, Tuple{L}, Tuple{Ax}} where {Ax, L&lt;:Tuple{Dict, Dict}}"><code>PowerNetworkMatrices.factorize</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">factorize(ABA)
</code></pre><p>Evaluates the LU factorization matrices of the ABA matrix, using KLU.</p><p><strong>Arguments</strong></p><ul><li><code>ABA::ABA_Matrix{Ax, L, Nothing} where {Ax, L &lt;: NTuple{2, Dict}}</code>:       container for the ABA matrix, with ABA.K == nothing (LU matrices in K not evaluated)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/BA_ABA_matrices.jl#L289">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.find_degree2_chains-Tuple{SparseArrays.SparseMatrixCSC, Set{Int64}}"><a class="docstring-binding" href="#PowerNetworkMatrices.find_degree2_chains-Tuple{SparseArrays.SparseMatrixCSC, Set{Int64}}"><code>PowerNetworkMatrices.find_degree2_chains</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">find_degree2_chains(adj_matrix, irreducible_indices)
</code></pre><pre><code class="language-julia hljs">find_degree2_chains(adj_matrix::SparseArrays.SparseMatrixCSC, irreducible_indices::Set{Int})</code></pre><p>Find all chains of degree-2 nodes in a graph represented by a CSC adjacency matrix. A chain is a sequence of connected degree-2 nodes.</p><p>Returns a dictionary mapping each starting node to its chain of node indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/degree_two_reduction.jl#L327">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.find_slack_positions-Tuple{Any}"><a class="docstring-binding" href="#PowerNetworkMatrices.find_slack_positions-Tuple{Any}"><code>PowerNetworkMatrices.find_slack_positions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">find_slack_positions(buses)
</code></pre><p>Gets the indices  of the reference (slack) buses. NOTE:</p><ul><li>the indices  corresponds to the columns of zeros belonging to the PTDF matrix.</li><li>BA and ABA matrix miss the columns related to the reference buses.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/common.jl#L172">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.find_subnetworks-Tuple{AdjacencyMatrix}"><a class="docstring-binding" href="#PowerNetworkMatrices.find_subnetworks-Tuple{AdjacencyMatrix}"><code>PowerNetworkMatrices.find_subnetworks</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">find_subnetworks(M)
</code></pre><p>Evaluates subnetworks by looking for the subsets of buses connected each other, but not connected with buses of other subsets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/AdjacencyMatrix.jl#L254">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.find_subnetworks-Tuple{PowerSystems.System}"><a class="docstring-binding" href="#PowerNetworkMatrices.find_subnetworks-Tuple{PowerSystems.System}"><code>PowerNetworkMatrices.find_subnetworks</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">find_subnetworks(sys)
</code></pre><p>Finds the subnetworks in a system using Depth First Search (DFS). Returns a dictionary keyed by the reference bus of the subnetworks if they exist</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/system_utils.jl#L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.find_subnetworks-Tuple{SparseArrays.SparseMatrixCSC, Vector{Int64}}"><a class="docstring-binding" href="#PowerNetworkMatrices.find_subnetworks-Tuple{SparseArrays.SparseMatrixCSC, Vector{Int64}}"><code>PowerNetworkMatrices.find_subnetworks</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">find_subnetworks(M, bus_numbers; subnetwork_algorithm)
</code></pre><p>Finds the subnetworks present in the considered System. This is evaluated by taking a the ABA or Adjacency Matrix.</p><p><strong>Arguments</strong></p><ul><li><code>M::SparseArrays.SparseMatrixCSC</code>:       input sparse matrix.</li><li><code>bus_numbers::Vector{Int}</code>:       vector containing the indices of the system&#39;s buses.</li><li><code>subnetwork_algorithm::Function</code>:       algorithm for computing subnetworks. Valid options are iterative<em>union</em>find (default) and depth<em>first</em>search</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/connectivity_checks.jl#L223">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.find_subnetworks-Tuple{Ybus}"><a class="docstring-binding" href="#PowerNetworkMatrices.find_subnetworks-Tuple{Ybus}"><code>PowerNetworkMatrices.find_subnetworks</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">find_subnetworks(M)
</code></pre><pre><code class="language-julia hljs">find_subnetworks(M::Ybus) -&gt; Dict{Int, Set{Int}}</code></pre><p>Identify electrical islands (subnetworks) in the Y-bus matrix.</p><p>Analyzes the network topology to find groups of buses that are electrically connected to each other but isolated from other groups. Each subnetwork represents an electrical island that requires its own reference bus and can be solved independently.</p><p><strong>Arguments</strong></p><ul><li><code>M::Ybus</code>: Y-bus matrix to analyze</li></ul><p><strong>Returns</strong></p><ul><li><code>Dict{Int, Set{Int}}</code>: Dictionary mapping reference bus numbers to sets of bus numbers in each subnetwork</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">ybus = Ybus(system)
subnetworks = find_subnetworks(ybus)
for (ref_bus, buses) in subnetworks
    println(&quot;Island &quot;, ref_bus, &quot;: &quot;, sort(collect(buses)))
end

if length(subnetworks) &gt; 1
    @warn &quot;Network has &quot;, length(subnetworks), &quot; electrical islands&quot;
end</code></pre><p><strong>Implementation Details</strong></p><ul><li>Uses adjacency matrix analysis to find connected components</li><li>Each subnetwork gets assigned a reference bus for voltage angle reference</li><li>Isolated buses or groups require separate power flow analysis</li><li>Critical for power flow initialization and solution</li></ul><p><strong>See Also</strong></p><ul><li><a href="#PowerNetworkMatrices.validate_connectivity-Tuple{AdjacencyMatrix}"><code>validate_connectivity</code></a>: Check for full connectivity</li><li><a href="#PowerNetworkMatrices.depth_first_search-Tuple{SparseArrays.SparseMatrixCSC, Vector{Int64}}"><code>depth_first_search</code></a>: Graph traversal algorithm</li><li><a href="#PowerNetworkMatrices.iterative_union_find-Tuple{SparseArrays.SparseMatrixCSC, Vector{Int64}}"><code>iterative_union_find</code></a>: Alternative connectivity algorithm</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/Ybus.jl#L1816">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.from_hdf5-Tuple{Type{PTDF}, AbstractString}"><a class="docstring-binding" href="#PowerNetworkMatrices.from_hdf5-Tuple{Type{PTDF}, AbstractString}"><code>PowerNetworkMatrices.from_hdf5</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">from_hdf5(_, filename)
</code></pre><p>Deserialize a PTDF from an HDF5 file.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{PTDF}</code>:</li><li><code>filename::AbstractString</code>: File containing a serialized PTDF.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/serialization.jl#L47">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.get_ac_transmission_types-Tuple{NetworkReductionData}"><a class="docstring-binding" href="#PowerNetworkMatrices.get_ac_transmission_types-Tuple{NetworkReductionData}"><code>PowerNetworkMatrices.get_ac_transmission_types</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_ac_transmission_types(network_reduction_data)
</code></pre><p>get<em>ac</em>transmission<em>types(network</em>reduction_data::NetworkReductionData)</p><p>Gets the concrete types of all AC transmission branches included in an instance of NetworkReductionData</p><p><strong>Arguments</strong></p><ul><li><code>network_reduction_data::NetworkReductionData</code></li></ul><p><strong>Returns</strong></p><ul><li><code>Set{DataType}</code>: Vector of the retained branch types.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/NetworkReductionData.jl#L418">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.get_arc_axis-Tuple{NetworkReductionData}"><a class="docstring-binding" href="#PowerNetworkMatrices.get_arc_axis-Tuple{NetworkReductionData}"><code>PowerNetworkMatrices.get_arc_axis</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_arc_axis(nr)
</code></pre><p>Interface to obtain the arc axis based on the network reduction data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/NetworkReductionData.jl#L484">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.get_arc_axis-Tuple{Vector{Int64}, Vector{Int64}, Vector{Int64}}"><a class="docstring-binding" href="#PowerNetworkMatrices.get_arc_axis-Tuple{Vector{Int64}, Vector{Int64}, Vector{Int64}}"><code>PowerNetworkMatrices.get_arc_axis</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_arc_axis(fb, tb, bus_axis)
</code></pre><pre><code class="language-julia hljs">get_arc_axis(fb::Vector{Int}, tb::Vector{Int}, bus_axis::Vector{Int}) -&gt; Vector{Tuple{Int, Int}}</code></pre><p>Generate unique arc axis from from-bus and to-bus index vectors.</p><p>Creates a vector of unique (from<em>bus, to</em>bus) tuples representing the arcs (branches) in the system. Used for constructing arc admittance matrices and organizing network topology data.</p><p><strong>Arguments</strong></p><ul><li><code>fb::Vector{Int}</code>: Vector of from-bus indices into bus_axis</li><li><code>tb::Vector{Int}</code>: Vector of to-bus indices into bus_axis</li><li><code>bus_axis::Vector{Int}</code>: Vector of bus numbers</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Tuple{Int, Int}}</code>: Unique arcs as (from<em>bus</em>number, to<em>bus</em>number) tuples</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">fb = [1, 2, 1]  # indices into bus_axis
tb = [2, 3, 3]  # indices into bus_axis
bus_axis = [101, 102, 103]  # bus numbers
arcs = get_arc_axis(fb, tb, bus_axis)
# Returns: [(101, 102), (102, 103), (101, 103)]</code></pre><p><strong>Implementation Details</strong></p><ul><li>Maps indices to actual bus numbers using bus_axis</li><li>Removes duplicates with unique()</li><li>Preserves arc direction (from → to)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/Ybus.jl#L1012">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.get_bus_reduction_map-Tuple{NetworkReductionData}"><a class="docstring-binding" href="#PowerNetworkMatrices.get_bus_reduction_map-Tuple{NetworkReductionData}"><code>PowerNetworkMatrices.get_bus_reduction_map</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_bus_reduction_map(rb)
</code></pre><pre><code class="language-julia hljs">get_bus_reduction_map(rb::NetworkReductionData)</code></pre><p>Get the bus reduction map from NetworkReductionData.</p><p><strong>Arguments</strong></p><ul><li><code>rb::NetworkReductionData</code>: The network reduction data</li></ul><p><strong>Returns</strong></p><ul><li><code>Dict{Int, Set{Int}}</code>: Dictionary mapping retained buses to sets of removed buses</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/NetworkReductionData.jl#L313">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.get_data-Tuple{PowerNetworkMatrices.PowerNetworkMatrix}"><a class="docstring-binding" href="#PowerNetworkMatrices.get_data-Tuple{PowerNetworkMatrices.PowerNetworkMatrix}"><code>PowerNetworkMatrices.get_data</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_data(mat)
</code></pre><p>returns the raw array data of the <code>PowerNetworkMatrix</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/PowerNetworkMatrix.jl#L310">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.get_default_reduction-Tuple{PowerSystems.System}"><a class="docstring-binding" href="#PowerNetworkMatrices.get_default_reduction-Tuple{PowerSystems.System}"><code>PowerNetworkMatrices.get_default_reduction</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_default_reduction(sys)
</code></pre><pre><code class="language-julia hljs">get_default_reduction(sys::PSY.System) -&gt; NetworkReductionData</code></pre><p>Build a Y-bus matrix from the system and return its default network reduction data.</p><p>This function constructs a Y-bus matrix with no network reductions applied and returns the resulting <code>NetworkReductionData</code>, which contains the basic bus and branch mappings for the system without any reduction algorithms.</p><p><strong>Arguments</strong></p><ul><li><code>sys::PSY.System</code>: Power system to analyze</li></ul><p><strong>Returns</strong></p><ul><li><code>NetworkReductionData</code>: Default network reduction data with basic system mappings</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">system = System(&quot;system.json&quot;)
reduction_data = get_default_reduction(system)
println(&quot;Number of buses: &quot;, length(get_bus_reduction_map(reduction_data)))</code></pre><p><strong>See Also</strong></p><ul><li><a href="#PowerNetworkMatrices.Ybus"><code>Ybus</code></a>: Y-bus matrix construction</li><li><a href="#PowerNetworkMatrices.NetworkReductionData"><code>NetworkReductionData</code></a>: Network reduction data structure</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/Ybus.jl#L96">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.get_equivalent_available-Tuple{PowerNetworkMatrices.BranchesParallel}"><a class="docstring-binding" href="#PowerNetworkMatrices.get_equivalent_available-Tuple{PowerNetworkMatrices.BranchesParallel}"><code>PowerNetworkMatrices.get_equivalent_available</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_equivalent_available(bp)
</code></pre><pre><code class="language-julia hljs">get_equivalent_available(bp::BranchesParallel)</code></pre><p>Get the availability status for parallel branches. All branches in parallel must be available for the parallel circuit to be available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/BranchesParallel.jl#L107">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.get_equivalent_available-Tuple{PowerNetworkMatrices.BranchesSeries}"><a class="docstring-binding" href="#PowerNetworkMatrices.get_equivalent_available-Tuple{PowerNetworkMatrices.BranchesSeries}"><code>PowerNetworkMatrices.get_equivalent_available</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_equivalent_available(bs)
</code></pre><pre><code class="language-julia hljs">get_equivalent_available(bs::BranchesSeries)</code></pre><p>Get the availability status for series branches. All branches in series must be available for the series circuit to be available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/BranchesSeries.jl#L174">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.get_equivalent_available-Tuple{PowerNetworkMatrices.ThreeWindingTransformerWinding}"><a class="docstring-binding" href="#PowerNetworkMatrices.get_equivalent_available-Tuple{PowerNetworkMatrices.ThreeWindingTransformerWinding}"><code>PowerNetworkMatrices.get_equivalent_available</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_equivalent_available(tw)
</code></pre><pre><code class="language-julia hljs">get_equivalent_available(tw::ThreeWindingTransformerWinding)</code></pre><p>Get the availability status for a specific winding of a three-winding transformer. Returns the availability status of the parent transformer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/ThreeWindingTransformerWinding.jl#L143">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.get_equivalent_b-Tuple{PowerNetworkMatrices.ThreeWindingTransformerWinding}"><a class="docstring-binding" href="#PowerNetworkMatrices.get_equivalent_b-Tuple{PowerNetworkMatrices.ThreeWindingTransformerWinding}"><code>PowerNetworkMatrices.get_equivalent_b</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_equivalent_b(tw)
</code></pre><pre><code class="language-julia hljs">get_equivalent_b(tw::ThreeWindingTransformerWinding)</code></pre><p>Get the susceptance for a specific winding of a three-winding transformer. For the primary winding (winding 1), returns the shunt susceptance from the transformer. For secondary and tertiary windings, returns 0.0 as the shunt is only on the primary side.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/ThreeWindingTransformerWinding.jl#L82">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.get_equivalent_emergency_rating-Tuple{PowerNetworkMatrices.BranchesParallel}"><a class="docstring-binding" href="#PowerNetworkMatrices.get_equivalent_emergency_rating-Tuple{PowerNetworkMatrices.BranchesParallel}"><code>PowerNetworkMatrices.get_equivalent_emergency_rating</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_equivalent_emergency_rating(bp)
</code></pre><pre><code class="language-julia hljs">get_equivalent_emergency_rating(bp::BranchesParallel)</code></pre><p>Calculate the total emergency rating for branches in parallel. For parallel circuits, the emergency rating is the sum of individual emergency ratings divided by the number of circuits. This provides a conservative estimate that accounts for potential overestimation of total capacity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/BranchesParallel.jl#L91">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.get_equivalent_emergency_rating-Tuple{PowerNetworkMatrices.BranchesSeries}"><a class="docstring-binding" href="#PowerNetworkMatrices.get_equivalent_emergency_rating-Tuple{PowerNetworkMatrices.BranchesSeries}"><code>PowerNetworkMatrices.get_equivalent_emergency_rating</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_equivalent_emergency_rating(bs)
</code></pre><pre><code class="language-julia hljs">get_equivalent_emergency_rating(bs::BranchesSeries)</code></pre><p>Calculate the emergency rating for branches in series. For series circuits, the emergency rating is limited by the weakest link: Rating_total = min(Rating1, Rating2, ..., Ratingn)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/BranchesSeries.jl#L149">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.get_equivalent_emergency_rating-Tuple{PowerNetworkMatrices.ThreeWindingTransformerWinding}"><a class="docstring-binding" href="#PowerNetworkMatrices.get_equivalent_emergency_rating-Tuple{PowerNetworkMatrices.ThreeWindingTransformerWinding}"><code>PowerNetworkMatrices.get_equivalent_emergency_rating</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_equivalent_emergency_rating(tw)
</code></pre><pre><code class="language-julia hljs">get_equivalent_emergency_rating(tw::ThreeWindingTransformerWinding)</code></pre><p>Get the rating for a specific winding of a three-winding transformer. Returns the winding-specific rating if non-zero, otherwise returns the parent transformer rating.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/ThreeWindingTransformerWinding.jl#L132">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.get_equivalent_emergency_rating-Tuple{PowerSystems.ACTransmission}"><a class="docstring-binding" href="#PowerNetworkMatrices.get_equivalent_emergency_rating-Tuple{PowerSystems.ACTransmission}"><code>PowerNetworkMatrices.get_equivalent_emergency_rating</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_equivalent_emergency_rating(branch)
</code></pre><pre><code class="language-julia hljs">get_equivalent_emergency_rating(bs&lt;:PSY.ACTransmission)</code></pre><p>Return the emergency rating for PSY.ACTransmission branches.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/BranchesSeries.jl#L160">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.get_equivalent_r-Tuple{PowerNetworkMatrices.ThreeWindingTransformerWinding}"><a class="docstring-binding" href="#PowerNetworkMatrices.get_equivalent_r-Tuple{PowerNetworkMatrices.ThreeWindingTransformerWinding}"><code>PowerNetworkMatrices.get_equivalent_r</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_equivalent_r(tw)
</code></pre><pre><code class="language-julia hljs">get_equivalent_r(tw::ThreeWindingTransformerWinding)</code></pre><p>Get the resistance for a specific winding of a three-winding transformer. Returns the winding-specific series resistance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/ThreeWindingTransformerWinding.jl#L40">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.get_equivalent_rating-Tuple{PowerNetworkMatrices.BranchesParallel}"><a class="docstring-binding" href="#PowerNetworkMatrices.get_equivalent_rating-Tuple{PowerNetworkMatrices.BranchesParallel}"><code>PowerNetworkMatrices.get_equivalent_rating</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_equivalent_rating(bp)
</code></pre><pre><code class="language-julia hljs">get_equivalent_rating(bp::BranchesParallel)</code></pre><p>Calculate the total rating for branches in parallel. For parallel circuits, the rating is the sum of individual ratings divided by the number of circuits. This provides a conservative estimate that accounts for potential overestimation of total capacity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/BranchesParallel.jl#L79">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.get_equivalent_rating-Tuple{PowerNetworkMatrices.BranchesSeries}"><a class="docstring-binding" href="#PowerNetworkMatrices.get_equivalent_rating-Tuple{PowerNetworkMatrices.BranchesSeries}"><code>PowerNetworkMatrices.get_equivalent_rating</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_equivalent_rating(bs)
</code></pre><pre><code class="language-julia hljs">get_equivalent_rating(bs::BranchesSeries)</code></pre><p>Calculate the rating for branches in series. Series chains, can be composed of PSY.ACTransmission branches and PNM.BranchesParallel. For series circuits, the rating is limited by the weakest link: Rating_total = min(Rating1, Rating2, ..., Ratingn)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/BranchesSeries.jl#L128">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.get_equivalent_rating-Tuple{PowerNetworkMatrices.ThreeWindingTransformerWinding}"><a class="docstring-binding" href="#PowerNetworkMatrices.get_equivalent_rating-Tuple{PowerNetworkMatrices.ThreeWindingTransformerWinding}"><code>PowerNetworkMatrices.get_equivalent_rating</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_equivalent_rating(tw)
</code></pre><pre><code class="language-julia hljs">get_equivalent_rating(tw::ThreeWindingTransformerWinding)</code></pre><p>Get the rating for a specific winding of a three-winding transformer. Returns the winding-specific rating if non-zero, otherwise returns the parent transformer rating.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/ThreeWindingTransformerWinding.jl#L104">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.get_equivalent_rating-Tuple{PowerSystems.ACTransmission}"><a class="docstring-binding" href="#PowerNetworkMatrices.get_equivalent_rating-Tuple{PowerSystems.ACTransmission}"><code>PowerNetworkMatrices.get_equivalent_rating</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_equivalent_rating(bs)
</code></pre><pre><code class="language-julia hljs">get_equivalent_rating(bs&lt;:PSY.ACTransmission)</code></pre><p>Return the rating for PSY.ACTransmission branches.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/BranchesSeries.jl#L140">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.get_equivalent_tap-Tuple{PowerNetworkMatrices.ThreeWindingTransformerWinding{PowerSystems.PhaseShiftingTransformer3W}}"><a class="docstring-binding" href="#PowerNetworkMatrices.get_equivalent_tap-Tuple{PowerNetworkMatrices.ThreeWindingTransformerWinding{PowerSystems.PhaseShiftingTransformer3W}}"><code>PowerNetworkMatrices.get_equivalent_tap</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_equivalent_tap(tw)
</code></pre><pre><code class="language-julia hljs">get_equivalent_tap(tw::ThreeWindingTransformerWinding)</code></pre><p>Get the tap (turns ratio) for a specific winding of a three-winding transformer. Returns the winding-specific turns ratio for phase shifting transformers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/ThreeWindingTransformerWinding.jl#L188">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.get_equivalent_x-Tuple{PowerNetworkMatrices.ThreeWindingTransformerWinding}"><a class="docstring-binding" href="#PowerNetworkMatrices.get_equivalent_x-Tuple{PowerNetworkMatrices.ThreeWindingTransformerWinding}"><code>PowerNetworkMatrices.get_equivalent_x</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_equivalent_x(tw)
</code></pre><pre><code class="language-julia hljs">get_equivalent_x(tw::ThreeWindingTransformerWinding)</code></pre><p>Get the reactance for a specific winding of a three-winding transformer. Returns the winding-specific series reactance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/ThreeWindingTransformerWinding.jl#L61">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.get_equivalent_α-Tuple{PowerNetworkMatrices.BranchesParallel}"><a class="docstring-binding" href="#PowerNetworkMatrices.get_equivalent_α-Tuple{PowerNetworkMatrices.BranchesParallel}"><code>PowerNetworkMatrices.get_equivalent_α</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_equivalent_α(bp)
</code></pre><pre><code class="language-julia hljs">get_equivalent_α(bp::BranchesParallel)</code></pre><p>Get the phase angle shift for parallel branches. Returns the average phase angle shift across all parallel branches. Returns 0.0 if branches don&#39;t support phase angle shift (e.g., lines).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/BranchesParallel.jl#L118">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.get_equivalent_α-Tuple{PowerNetworkMatrices.BranchesSeries}"><a class="docstring-binding" href="#PowerNetworkMatrices.get_equivalent_α-Tuple{PowerNetworkMatrices.BranchesSeries}"><code>PowerNetworkMatrices.get_equivalent_α</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_equivalent_α(bs)
</code></pre><pre><code class="language-julia hljs">get_equivalent_α(bs::BranchesSeries)</code></pre><p>Get the phase angle shift for series branches. Returns the sum of phase angle shifts across all series branches. Returns 0.0 if branches don&#39;t support phase angle shift (e.g., lines).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/BranchesSeries.jl#L185">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.get_equivalent_α-Tuple{PowerNetworkMatrices.ThreeWindingTransformerWinding{PowerSystems.PhaseShiftingTransformer3W}}"><a class="docstring-binding" href="#PowerNetworkMatrices.get_equivalent_α-Tuple{PowerNetworkMatrices.ThreeWindingTransformerWinding{PowerSystems.PhaseShiftingTransformer3W}}"><code>PowerNetworkMatrices.get_equivalent_α</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_equivalent_α(tw)
</code></pre><pre><code class="language-julia hljs">get_equivalent_α(tw::ThreeWindingTransformerWinding)</code></pre><p>Get the phase angle (α) for a specific winding of a three-winding transformer. Returns the winding-specific phase shift angle for phase shifting transformers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/ThreeWindingTransformerWinding.jl#L211">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.get_irreducible_indices-Tuple{AdjacencyMatrix, Vector{Int64}}"><a class="docstring-binding" href="#PowerNetworkMatrices.get_irreducible_indices-Tuple{AdjacencyMatrix, Vector{Int64}}"><code>PowerNetworkMatrices.get_irreducible_indices</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_irreducible_indices(A, irreducible_buses)
</code></pre><p>Convert the user input for irreducible_buses to a set of indices based on the Ybus lookup and the prior reductions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/common.jl#L228">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.get_isolated_buses-Tuple{Ybus}"><a class="docstring-binding" href="#PowerNetworkMatrices.get_isolated_buses-Tuple{Ybus}"><code>PowerNetworkMatrices.get_isolated_buses</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_isolated_buses(M)
</code></pre><pre><code class="language-julia hljs">get_isolated_buses(M::Ybus) -&gt; Vector{Int}</code></pre><p>Return bus numbers that form isolated single-node subnetworks in the Y-bus matrix.</p><p>Isolated buses are electrical islands containing only one bus with no connections to other parts of the network. These typically represent buses that were disconnected during network reduction operations or buses with no active branches.</p><p><strong>Arguments</strong></p><ul><li><code>M::Ybus</code>: Y-bus matrix to analyze</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Int}</code>: Vector of bus numbers that form isolated single-node subnetworks</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">ybus = Ybus(system)
isolated = get_isolated_buses(ybus)
println(&quot;Isolated buses: &quot;, isolated)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/Ybus.jl#L70">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.get_lodf_data-Tuple{LODF}"><a class="docstring-binding" href="#PowerNetworkMatrices.get_lodf_data-Tuple{LODF}"><code>PowerNetworkMatrices.get_lodf_data</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_lodf_data(lodf)
</code></pre><pre><code class="language-julia hljs">get_lodf_data(lodf::LODF)</code></pre><p>Extract the LODF matrix data in the standard orientation (non-transposed).</p><p><strong>Arguments</strong></p><ul><li><code>lodf::LODF</code>: The LODF structure from which to extract data</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractArray{Float64, 2}</code>: The LODF matrix data with standard orientation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/lodf_calculations.jl#L475">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.get_lookup-Tuple{PowerNetworkMatrices.PowerNetworkMatrix}"><a class="docstring-binding" href="#PowerNetworkMatrices.get_lookup-Tuple{PowerNetworkMatrices.PowerNetworkMatrix}"><code>PowerNetworkMatrices.get_lookup</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_lookup(mat)
</code></pre><pre><code class="language-julia hljs">returns the lookup tuple of the `PowerNetworkMatrix`. The first entry corresponds
to the first dimension and the second entry corresponds to the second dimension. For
instance in Ybus the first dimension is buses and second dimension is buses too, and in
PTDF the first dimension is branches and the second dimension is buses</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/PowerNetworkMatrix.jl#L313">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.get_mapped_bus_number-Tuple{NetworkReductionData, Int64}"><a class="docstring-binding" href="#PowerNetworkMatrices.get_mapped_bus_number-Tuple{NetworkReductionData, Int64}"><code>PowerNetworkMatrices.get_mapped_bus_number</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_mapped_bus_number(rb, bus_number)
</code></pre><p>Interface to obtain the parent bus number of a reduced bus when radial branches are eliminated</p><p><strong>Arguments</strong></p><ul><li><code>rb::NetworkReduction</code>: NetworkReduction object</li><li><code>bus_number::Int</code>: Bus number of the reduced bus</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/NetworkReductionData.jl#L462">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.get_mapped_bus_number-Tuple{NetworkReductionData, PowerSystems.ACBus}"><a class="docstring-binding" href="#PowerNetworkMatrices.get_mapped_bus_number-Tuple{NetworkReductionData, PowerSystems.ACBus}"><code>PowerNetworkMatrices.get_mapped_bus_number</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_mapped_bus_number(rb, bus)
</code></pre><p>Interface to obtain the parent bus number of a reduced bus when radial branches are eliminated</p><p><strong>Arguments</strong></p><ul><li><code>rb::NetworkReduction</code>: NetworkReduction object</li><li><code>bus::ACBus</code>: Reduced bus</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/NetworkReductionData.jl#L473">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.get_ptdf_data-Tuple{PTDF}"><a class="docstring-binding" href="#PowerNetworkMatrices.get_ptdf_data-Tuple{PTDF}"><code>PowerNetworkMatrices.get_ptdf_data</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_ptdf_data(ptdf)
</code></pre><pre><code class="language-julia hljs">get_ptdf_data(ptdf::PTDF)</code></pre><p>Extract the PTDF matrix data in the standard orientation (non-transposed).</p><p><strong>Arguments</strong></p><ul><li><code>ptdf::PTDF</code>: The PTDF structure from which to extract data</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractArray{Float64, 2}</code>: The PTDF matrix data with standard orientation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/ptdf_calculations.jl#L461">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.get_reduction-Tuple{Ybus, PowerSystems.System, RadialReduction}"><a class="docstring-binding" href="#PowerNetworkMatrices.get_reduction-Tuple{Ybus, PowerSystems.System, RadialReduction}"><code>PowerNetworkMatrices.get_reduction</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_reduction(ybus, sys, reduction)
</code></pre><pre><code class="language-julia hljs">get_reduction(ybus::Ybus, sys::PSY.System, reduction::RadialReduction) -&gt; NetworkReductionData</code></pre><p>Apply radial network reduction to a Y-bus matrix.</p><p>Radial reduction eliminates radial (dangling) buses that have only one connection. These buses do not affect power flows in the rest of the network and can be safely removed to reduce computational complexity.</p><p><strong>Arguments</strong></p><ul><li><code>ybus::Ybus</code>: Y-bus matrix to reduce</li><li><code>sys::PSY.System</code>: Power system for validation</li><li><code>reduction::RadialReduction</code>: Radial reduction configuration</li></ul><p><strong>Returns</strong></p><ul><li><code>NetworkReductionData</code>: Reduction data containing eliminated buses and updated mappings</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">ybus = Ybus(system)
reduction = RadialReduction(irreducible_buses=[101, 205])
reduction_data = get_reduction(ybus, system, reduction)</code></pre><p><strong>See Also</strong></p><ul><li><a href="../../tutorials/tutorial_RadialReduction/#RadialReduction"><code>RadialReduction</code></a>: Radial reduction configuration</li><li><a href="#PowerNetworkMatrices.get_reduction-Tuple{Ybus, PowerSystems.System, RadialReduction}"><code>get_reduction</code></a>: Other reduction methods</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/Ybus.jl#L127">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.get_reductions-Tuple{NetworkReductionData}"><a class="docstring-binding" href="#PowerNetworkMatrices.get_reductions-Tuple{NetworkReductionData}"><code>PowerNetworkMatrices.get_reductions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_reductions(rb)
</code></pre><pre><code class="language-julia hljs">get_reductions(rb::NetworkReductionData)</code></pre><p>Get the reduction container from NetworkReductionData.</p><p><strong>Arguments</strong></p><ul><li><code>rb::NetworkReductionData</code>: The network reduction data</li></ul><p><strong>Returns</strong></p><ul><li><code>ReductionContainer</code>: Container with the applied network reductions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/NetworkReductionData.jl#L341">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.get_representative-Tuple{Vector{Int64}, Int64}"><a class="docstring-binding" href="#PowerNetworkMatrices.get_representative-Tuple{Vector{Int64}, Int64}"><code>PowerNetworkMatrices.get_representative</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_representative(uf, x)
</code></pre><p>Find part of the union-find disjoint set data structure. Vector because nodes are 1:n.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/connectivity_checks.jl#L103">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.get_retained_branches_names-Tuple{NetworkReductionData}"><a class="docstring-binding" href="#PowerNetworkMatrices.get_retained_branches_names-Tuple{NetworkReductionData}"><code>PowerNetworkMatrices.get_retained_branches_names</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_retained_branches_names(network_reduction_data)
</code></pre><p>get<em>retained</em>branches<em>names(network</em>reduction_data::NetworkReductionData)</p><p>Gets the branch names that are retained after network reduction. This method only returns the branch names from non-three winding transformer branches that have a one-to-one correspondence with arcs after the reduction. This does not include parallel branches or branches that have been reduced as part of a series chain of degree two nodes.</p><p><strong>Arguments</strong></p><ul><li><code>network_reduction_data::NetworkReductionData</code></li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{String}</code>: Vector of the retained branch names.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/NetworkReductionData.jl#L397">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.get_tol-Tuple{VirtualLODF}"><a class="docstring-binding" href="#PowerNetworkMatrices.get_tol-Tuple{VirtualLODF}"><code>PowerNetworkMatrices.get_tol</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_tol(mat)
</code></pre><p>Gets the tolerance used for sparsifying the rows of the VirtualLODF matrix</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/virtual_lodf_calculations.jl#L307">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.get_tol-Tuple{VirtualPTDF}"><a class="docstring-binding" href="#PowerNetworkMatrices.get_tol-Tuple{VirtualPTDF}"><code>PowerNetworkMatrices.get_tol</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_tol(vptdf)
</code></pre><p>Gets the tolerance used for sparsifying the rows of the VirtualPTDF matrix</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/virtual_ptdf_calculations.jl#L336">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.get_ward_reduction-Tuple{SparseArrays.SparseMatrixCSC{ComplexF32, Int64}, Dict{Int64, Int64}, Vector{Int64}, Set{Int64}, Set{Int64}, Vector{Int64}}"><a class="docstring-binding" href="#PowerNetworkMatrices.get_ward_reduction-Tuple{SparseArrays.SparseMatrixCSC{ComplexF32, Int64}, Dict{Int64, Int64}, Vector{Int64}, Set{Int64}, Set{Int64}, Vector{Int64}}"><code>PowerNetworkMatrices.get_ward_reduction</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_ward_reduction(
    data,
    bus_lookup,
    bus_axis,
    boundary_buses,
    ref_bus_numbers,
    study_buses
)
</code></pre><pre><code class="language-julia hljs">get_ward_reduction(data, bus_lookup, bus_axis, boundary_buses, ref_bus_numbers, study_buses)</code></pre><p>Perform Ward reduction to create an equivalent network representation.</p><p>Ward reduction is a network reduction technique that eliminates external buses while preserving  the electrical characteristics seen from the study buses. External buses are mapped to boundary  buses based on impedance criteria, and equivalent admittances are computed.</p><p><strong>Arguments</strong></p><ul><li><code>data::SparseArrays.SparseMatrixCSC{ComplexF32, Int}</code>: Admittance matrix of the system</li><li><code>bus_lookup::Dict{Int, Int}</code>: Dictionary mapping bus numbers to matrix indices</li><li><code>bus_axis::Vector{Int}</code>: Vector of all bus numbers in the system</li><li><code>boundary_buses::Set{Int}</code>: Set of boundary bus numbers between study and external areas</li><li><code>ref_bus_numbers::Set{Int}</code>: Set of reference bus numbers</li><li><code>study_buses::Vector{Int}</code>: Vector of study bus numbers to retain</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple</code>: Contains bus reduction map, reverse bus search map, added branch map, and added admittance map</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/ward_reduction.jl#L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.is_factorized-Union{Tuple{ABA_Matrix{Ax, L, Nothing}}, Tuple{L}, Tuple{Ax}} where {Ax, L&lt;:Tuple{Dict, Dict}}"><a class="docstring-binding" href="#PowerNetworkMatrices.is_factorized-Union{Tuple{ABA_Matrix{Ax, L, Nothing}}, Tuple{L}, Tuple{Ax}} where {Ax, L&lt;:Tuple{Dict, Dict}}"><code>PowerNetworkMatrices.is_factorized</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_factorized(ABA)
</code></pre><pre><code class="language-julia hljs">is_factorized(ABA::ABA_Matrix)</code></pre><p>Check if an ABA_Matrix has been factorized (i.e., contains LU factorization matrices).</p><p><strong>Arguments</strong></p><ul><li><code>ABA::ABA_Matrix</code>: The ABA matrix to check</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: true if the matrix has been factorized, false otherwise</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/BA_ABA_matrices.jl#L309">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.iterative_union_find-Tuple{SparseArrays.SparseMatrixCSC, Vector{Int64}}"><a class="docstring-binding" href="#PowerNetworkMatrices.iterative_union_find-Tuple{SparseArrays.SparseMatrixCSC, Vector{Int64}}"><code>PowerNetworkMatrices.iterative_union_find</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">iterative_union_find(M, bus_numbers)
</code></pre><pre><code class="language-julia hljs">iterative_union_find(M::SparseArrays.SparseMatrixCSC, bus_numbers::Vector{Int})</code></pre><p>Find connected subnetworks using iterative union-find algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>M::SparseArrays.SparseMatrixCSC</code>: Sparse matrix representing network connectivity</li><li><code>bus_numbers::Vector{Int}</code>: Vector containing the bus numbers of the system</li></ul><p><strong>Returns</strong></p><ul><li><code>Dict{Int, Set{Int}}</code>: Dictionary mapping representative bus numbers to sets of connected buses</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/connectivity_checks.jl#L122">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.lookup_index-Tuple{Any, Dict}"><a class="docstring-binding" href="#PowerNetworkMatrices.lookup_index-Tuple{Any, Dict}"><code>PowerNetworkMatrices.lookup_index</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">lookup_index(i, lookup)
</code></pre><p>Gets bus indices to a certain branch index</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/PowerNetworkMatrix.jl#L56">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.lookup_index-Tuple{PowerSystems.ACBus, Dict}"><a class="docstring-binding" href="#PowerNetworkMatrices.lookup_index-Tuple{PowerSystems.ACBus, Dict}"><code>PowerNetworkMatrices.lookup_index</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">lookup_index(i, lookup)
</code></pre><p>Gets bus indices to a certain branch name</p><p><strong>Arguments</strong></p><ul><li><code>i::PSY.ACBranch</code>:       Power System AC branch</li><li><code>lookup::Dict</code>:       Dictionary mapping branches and buses</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/PowerNetworkMatrix.jl#L76">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.lookup_index-Tuple{PowerSystems.Arc, Dict}"><a class="docstring-binding" href="#PowerNetworkMatrices.lookup_index-Tuple{PowerSystems.Arc, Dict}"><code>PowerNetworkMatrices.lookup_index</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">lookup_index(i, lookup)
</code></pre><p>Gets bus indices to a certain branch name</p><p><strong>Arguments</strong></p><ul><li><code>i::PSY.ACBranch</code>:       Power System AC branch</li><li><code>lookup::Dict</code>:       Dictionary mapping branch and buses</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/PowerNetworkMatrix.jl#L63">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.make_arc_arc_subnetwork_axes-Tuple{IncidenceMatrix}"><a class="docstring-binding" href="#PowerNetworkMatrices.make_arc_arc_subnetwork_axes-Tuple{IncidenceMatrix}"><code>PowerNetworkMatrices.make_arc_arc_subnetwork_axes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">make_arc_arc_subnetwork_axes(A)
</code></pre><p>Make subnetwork axes for LODF and VirtualLODF</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/IncidenceMatrix.jl#L213">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.make_arc_bus_subnetwork_axes-Tuple{Ybus}"><a class="docstring-binding" href="#PowerNetworkMatrices.make_arc_bus_subnetwork_axes-Tuple{Ybus}"><code>PowerNetworkMatrices.make_arc_bus_subnetwork_axes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">make_arc_bus_subnetwork_axes(ybus)
</code></pre><pre><code class="language-julia hljs">make_arc_bus_subnetwork_axes(ybus::Ybus) -&gt; Dict{Int, Tuple{Vector{Tuple{Int, Int}}, Vector{Int}}}</code></pre><p>Create subnetwork axes for IncidenceMatrix construction from a Y-bus matrix.</p><p>Generates subnetwork-specific axes with arc-bus ordering needed for constructing incidence matrices. Each subnetwork gets its own arc list and corresponding bus list for matrix indexing.</p><p><strong>Arguments</strong></p><ul><li><code>ybus::Ybus</code>: Y-bus matrix containing subnetwork information</li></ul><p><strong>Returns</strong></p><ul><li><code>Dict{Int, Tuple{Vector{Tuple{Int, Int}}, Vector{Int}}}</code>: Dictionary mapping reference bus numbers to (arc<em>axis, bus</em>axis) tuples for each subnetwork</li></ul><p><strong>Implementation Details</strong></p><ul><li>Swaps order compared to <code>make_bus_arc_subnetwork_axes</code> (arc first, bus second)</li><li>Uses same underlying data from <code>ybus.subnetwork_axes</code> and <code>ybus.arc_subnetwork_axis</code></li><li>Used for constructing incidence matrices that relate branch connectivity to bus topology</li></ul><p><strong>See Also</strong></p><ul><li><a href="../../tutorials/tutorial_Incidence_BA_ABA_matrices/#IncidenceMatrix"><code>IncidenceMatrix</code></a>: Network incidence matrix</li><li><a href="#PowerNetworkMatrices.make_bus_arc_subnetwork_axes-Tuple{Ybus}"><code>make_bus_arc_subnetwork_axes</code></a>: Bus-Arc variant</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/Ybus.jl#L1084">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.make_ax_ref-Tuple{AbstractVector{PowerSystems.ACBus}}"><a class="docstring-binding" href="#PowerNetworkMatrices.make_ax_ref-Tuple{AbstractVector{PowerSystems.ACBus}}"><code>PowerNetworkMatrices.make_ax_ref</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">make_ax_ref(buses)
</code></pre><p>Evaluates the map linking the system&#39;s buses and branches.</p><p><strong>Arguments</strong></p><ul><li><code>buses::AbstractVector{PSY.ACBus}</code>:       system&#39;s buses</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/PowerNetworkMatrix.jl#L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.make_ax_ref-Tuple{AbstractVector}"><a class="docstring-binding" href="#PowerNetworkMatrices.make_ax_ref-Tuple{AbstractVector}"><code>PowerNetworkMatrices.make_ax_ref</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">make_ax_ref(ax)
</code></pre><p>Checks if repetitions are present in the dictionary mapping buses and branches.</p><p><strong>Arguments</strong></p><ul><li><code>ax::AbstractVector</code>:       generic abstract vector</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/PowerNetworkMatrix.jl#L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.make_bus_arc_subnetwork_axes-Tuple{Ybus}"><a class="docstring-binding" href="#PowerNetworkMatrices.make_bus_arc_subnetwork_axes-Tuple{Ybus}"><code>PowerNetworkMatrices.make_bus_arc_subnetwork_axes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">make_bus_arc_subnetwork_axes(ybus)
</code></pre><pre><code class="language-julia hljs">make_bus_arc_subnetwork_axes(ybus::Ybus) -&gt; Dict{Int, Tuple{Vector{Int}, Vector{Tuple{Int, Int}}}}</code></pre><p>Create subnetwork axes for BA_Matrix construction from a Y-bus matrix.</p><p>Generates subnetwork-specific axes combining bus and arc information needed for constructing Bus-Arc (BA) matrices. Each subnetwork gets its own bus list and corresponding arc list for matrix indexing.</p><p><strong>Arguments</strong></p><ul><li><code>ybus::Ybus</code>: Y-bus matrix containing subnetwork information</li></ul><p><strong>Returns</strong></p><ul><li><code>Dict{Int, Tuple{Vector{Int}, Vector{Tuple{Int, Int}}}}</code>: Dictionary mapping reference bus numbers to (bus<em>axis, arc</em>axis) tuples for each subnetwork</li></ul><p><strong>Implementation Details</strong></p><ul><li>Combines bus axes from <code>ybus.subnetwork_axes</code> with arc axes from <code>ybus.arc_subnetwork_axis</code></li><li>Maintains consistency between bus and arc indexing within each electrical island</li><li>Used for constructing BA matrices that relate bus injections to branch flows</li></ul><p><strong>See Also</strong></p><ul><li><a href="../../tutorials/tutorial_Incidence_BA_ABA_matrices/#BA_Matrix"><code>BA_Matrix</code></a>: Bus-Arc matrix construction</li><li><a href="#PowerNetworkMatrices.make_arc_bus_subnetwork_axes-Tuple{Ybus}"><code>make_arc_bus_subnetwork_axes</code></a>: Arc-Bus variant</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/Ybus.jl#L1048">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.populate_branch_maps_by_type!"><a class="docstring-binding" href="#PowerNetworkMatrices.populate_branch_maps_by_type!"><code>PowerNetworkMatrices.populate_branch_maps_by_type!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">populate_branch_maps_by_type!(nrd)
populate_branch_maps_by_type!(nrd, filters)
</code></pre><pre><code class="language-julia hljs">populate_branch_maps_by_type!(nrd::NetworkReductionData, filters = Dict())</code></pre><p>Populate the branch maps organized by component type within the NetworkReductionData structure.</p><p>This function processes various types of branch mappings (direct, parallel, series, and 3-winding transformers) and organizes them by their component types. It applies optional filters to determine which branches should be included in the type-organized maps.</p><p><strong>Arguments</strong></p><ul><li><code>nrd::NetworkReductionData</code>: The network reduction data structure to populate</li><li><code>filters</code>: Optional dictionary of filters to apply when determining which branches to include (default: empty Dict)</li></ul><p><strong>Details</strong></p><p>The function creates and populates the following map types organized by component type:</p><ul><li><code>direct_branch_map</code>: Direct branch connections between buses</li><li><code>reverse_direct_branch_map</code>: Reverse lookup for direct branches</li><li><code>parallel_branch_map</code>: Parallel branch connections between the same bus pair</li><li><code>reverse_parallel_branch_map</code>: Reverse lookup for parallel branches</li><li><code>series_branch_map</code>: Series branch connections (chains of branches)</li><li><code>reverse_series_branch_map</code>: Reverse lookup for series branches</li><li><code>transformer3W_map</code>: Three-winding transformer connections</li><li><code>reverse_transformer3W_map</code>: Reverse lookup for three-winding transformers</li></ul><p>The function also populates the <code>name_to_arc_map</code> to provide name-based lookups for branches and stores the applied filters in <code>nrd.filters_applied</code>.</p><p><strong>Modifies</strong></p><ul><li><code>nrd.all_branch_maps_by_type</code>: Populated with type-organized branch maps</li><li><code>nrd.name_to_arc_map</code>: Updated with name-to-arc mappings</li><li><code>nrd.filters_applied</code>: Set to the provided filters</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code>: This function modifies the input structure in-place</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/NetworkReductionData.jl#L95">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.purge_one!-Tuple{PowerNetworkMatrices.RowCache}"><a class="docstring-binding" href="#PowerNetworkMatrices.purge_one!-Tuple{PowerNetworkMatrices.RowCache}"><code>PowerNetworkMatrices.purge_one!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">purge_one!(cache)
</code></pre><p>Deletes a row from the stored matrix in cache not belonging to the persistent<em>cache</em>keys set. Uses LRU (Least Recently Used) eviction strategy based on access_order tracking.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/row_cache.jl#L138">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.sparsify-Tuple{Matrix{Float64}, Float64}"><a class="docstring-binding" href="#PowerNetworkMatrices.sparsify-Tuple{Matrix{Float64}, Float64}"><code>PowerNetworkMatrices.sparsify</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">sparsify(dense_array, tol)
</code></pre><p>Return a sparse matrix given a dense one by dropping elements whose absolute value is below a certain tolerance.</p><p>Uses optimized <code>droptol!</code> for better performance compared to element-wise iteration.</p><p><strong>Arguments</strong></p><ul><li><code>dense_array::Matrix{Float64}</code>:       input matrix (e.g., PTDF matrix).</li><li><code>tol::Float64</code>:       tolerance.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/common.jl#L264">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.sparsify-Tuple{Vector{Float64}, Float64}"><a class="docstring-binding" href="#PowerNetworkMatrices.sparsify-Tuple{Vector{Float64}, Float64}"><code>PowerNetworkMatrices.sparsify</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">sparsify(dense_array, tol)
</code></pre><p>Return a sparse vector given a dense one by dropping elements whose absolute value is below a certain tolerance.</p><p>Uses optimized <code>droptol!</code> for better performance compared to element-wise iteration.</p><p><strong>Arguments</strong></p><ul><li><code>dense_array::Vector{Float64}</code>:       input vector (e.g., PTDF row from VirtualPTDF).</li><li><code>tol::Float64</code>:       tolerance.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/common.jl#L282">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.to_hdf5-Tuple{PTDF, AbstractString}"><a class="docstring-binding" href="#PowerNetworkMatrices.to_hdf5-Tuple{PTDF, AbstractString}"><code>PowerNetworkMatrices.to_hdf5</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">to_hdf5(ptdf, filename; compress, compression_level, force)
</code></pre><p>Serialize the PTDF to an HDF5 file.</p><p><strong>Arguments</strong></p><ul><li><code>ptdf::PTDF</code>: matrix</li><li><code>filename::AbstractString</code>: File to create</li><li><code>compress::Bool</code>: Whether to enabled compression, defaults to true.</li><li><code>compression_level::Int</code>: Compression level to use if compression is enabled.</li><li><code>force::Bool</code>: Whether to overwrite the file if it already exists, defaults to false.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/serialization.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.to_index-Tuple{PowerNetworkMatrices.PowerNetworkMatrix, Vararg{Any}}"><a class="docstring-binding" href="#PowerNetworkMatrices.to_index-Tuple{PowerNetworkMatrices.PowerNetworkMatrix, Vararg{Any}}"><code>PowerNetworkMatrices.to_index</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">to_index(A, idx)
</code></pre><p>Given the indices, gets the values of the power network matrix considered</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/PowerNetworkMatrix.jl#L116">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.union_sets!-Tuple{Vector{Int64}, Int64, Int64}"><a class="docstring-binding" href="#PowerNetworkMatrices.union_sets!-Tuple{Vector{Int64}, Int64, Int64}"><code>PowerNetworkMatrices.union_sets!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">union_sets!(uf, x, y)
</code></pre><p>Union part of the union-find disjoint set data structure. Vector because nodes are 1:n.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/connectivity_checks.jl#L112">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.validate_buses-Tuple{AdjacencyMatrix, Vector{Int64}}"><a class="docstring-binding" href="#PowerNetworkMatrices.validate_buses-Tuple{AdjacencyMatrix, Vector{Int64}}"><code>PowerNetworkMatrices.validate_buses</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">validate_buses(A, buses)
</code></pre><p>Validates that the user bus input is consistent with the ybus axes and the prior reductions. Is used to check <code>irreducible_buses</code> for <code>Radial</code> and <code>DegreeTwo</code> reductions and <code>study_buses</code> for <code>WardReduction</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/common.jl#L205">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.validate_connectivity-Tuple{AdjacencyMatrix}"><a class="docstring-binding" href="#PowerNetworkMatrices.validate_connectivity-Tuple{AdjacencyMatrix}"><code>PowerNetworkMatrices.validate_connectivity</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">validate_connectivity(M)
</code></pre><p>Validates connectivity by checking that the number of subnetworks is 1 (fully connected network).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/AdjacencyMatrix.jl#L246">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.validate_connectivity-Tuple{PowerSystems.System}"><a class="docstring-binding" href="#PowerNetworkMatrices.validate_connectivity-Tuple{PowerSystems.System}"><code>PowerNetworkMatrices.validate_connectivity</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">validate_connectivity(sys)
</code></pre><p>Checks the network connectivity of the system using Depth First Search (DFS)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/system_utils.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.validate_connectivity-Tuple{Ybus}"><a class="docstring-binding" href="#PowerNetworkMatrices.validate_connectivity-Tuple{Ybus}"><code>PowerNetworkMatrices.validate_connectivity</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">validate_connectivity(M)
</code></pre><pre><code class="language-julia hljs">validate_connectivity(M::Ybus) -&gt; Bool</code></pre><p>Validate that the Y-bus represents a fully connected electrical network.</p><p>Checks network connectivity by counting the number of electrical islands (subnetworks) in the Y-bus matrix. A fully connected network should have exactly one subnetwork. Multiple subnetworks indicate electrical isolation between parts of the system.</p><p><strong>Arguments</strong></p><ul><li><code>M::Ybus</code>: Y-bus matrix to validate</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if network is fully connected (single subnetwork), <code>false</code> otherwise</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">ybus = Ybus(system)
if validate_connectivity(ybus)
    println(&quot;Network is fully connected&quot;)
else
    println(&quot;Network has isolated islands&quot;)
    islands = find_subnetworks(ybus)
    println(&quot;Number of islands: &quot;, length(islands))
end</code></pre><p><strong>Implementation Details</strong></p><ul><li>Uses <code>find_subnetworks()</code> to identify electrical islands</li><li>Single subnetwork indicates full electrical connectivity</li><li>Multiple subnetworks may require separate power flow solutions</li></ul><p><strong>See Also</strong></p><ul><li><a href="#PowerNetworkMatrices.find_subnetworks-Tuple{AdjacencyMatrix}"><code>find_subnetworks</code></a>: Identify electrical islands</li><li><a href="#PowerNetworkMatrices.validate_connectivity-Tuple{AdjacencyMatrix}"><code>validate_connectivity</code></a>: System-level connectivity validation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/Ybus.jl#L1775">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.validate_linear_solver-Tuple{String}"><a class="docstring-binding" href="#PowerNetworkMatrices.validate_linear_solver-Tuple{String}"><code>PowerNetworkMatrices.validate_linear_solver</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">validate_linear_solver(linear_solver)
</code></pre><p>Validates if the selected linear solver is supported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/common.jl#L193">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.ybus_branch_entries-Tuple{PowerNetworkMatrices.ThreeWindingTransformerWinding}"><a class="docstring-binding" href="#PowerNetworkMatrices.ybus_branch_entries-Tuple{PowerNetworkMatrices.ThreeWindingTransformerWinding}"><code>PowerNetworkMatrices.ybus_branch_entries</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ybus_branch_entries(tp)
</code></pre><p>Ybus branch entries for an arc in the wye model of a <code>ThreeWindingTransformer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/Ybus.jl#L440">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.ybus_branch_entries-Tuple{PowerSystems.ACTransmission}"><a class="docstring-binding" href="#PowerNetworkMatrices.ybus_branch_entries-Tuple{PowerSystems.ACTransmission}"><code>PowerNetworkMatrices.ybus_branch_entries</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ybus_branch_entries(br)
</code></pre><p>Ybus entries for a <code>Line</code> or a <code>DiscreteControlledACBranch</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/Ybus.jl#L384">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerNetworkMatrices.ybus_branch_entries-Tuple{PowerSystems.TwoWindingTransformer}"><a class="docstring-binding" href="#PowerNetworkMatrices.ybus_branch_entries-Tuple{PowerSystems.TwoWindingTransformer}"><code>PowerNetworkMatrices.ybus_branch_entries</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ybus_branch_entries(br)
</code></pre><p>Ybus entries for a <code>Transformer2W</code>, <code>TapTransformer</code>, or <code>PhaseShiftingTransformer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerNetworkMatrices.jl/blob/6f53dc198732de380c9e78b9c12f218440647022/src/Ybus.jl#L422">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../network_matrices_overview/">« Matrix Overview</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Monday 2 February 2026 19:28">Monday 2 February 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
