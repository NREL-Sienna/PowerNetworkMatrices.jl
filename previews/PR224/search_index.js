var documenterSearchIndex = {"docs":
[{"location":"quick_start_guide/#Quick-Start-Guide","page":"Quick Start Guide","title":"Quick Start Guide","text":"note: Note\nPowerSystemCaseBuilder.jl is a helper library that makes it easier to reproduce examples in the documentation and tutorials. Normally you would pass your local files to create the system data instead of calling the function build_system. For more details visit PowerSystemCaseBuilder Documentation\n\nFor more details about loading data and adding more dynamic components check the Creating a System with Dynamic devices section of the documentation in PowerSystems.jl.","category":"section"},{"location":"quick_start_guide/#Loading-data","page":"Quick Start Guide","title":"Loading data","text":"Data can be loaded from a pss/e raw file and a pss/e dyr file.\n\nusing PowerNetworkMatrices\nusing PowerSystemCaseBuilder\n\nconst PNM = PowerNetworkMatrices\nconst PSB = PowerSystemCaseBuilder\n\nsys = PSB.build_system(PSB.PSITestSystems, \"c_sys5\")","category":"section"},{"location":"quick_start_guide/#Computation-of-the-PTDF-matrix","page":"Quick Start Guide","title":"Computation of the PTDF matrix","text":"Once system data is loaded, network matrices can be evaluated. The following example shows how the PTDF matrix is computed.\n\nThe function PTDF is called for the evaluation of the matrix and other data. These are stored in a structure of type PTDF.\n\n# evaluate the PTDF structure containing the matrix and other data.\nptdf_matrix = PNM.PTDF(sys);\n\n# show the PTDF matrix.\nPNM.get_data(ptdf_matrix)\n\nAs it can be seen, PTDF matrix is stored such that the number of rows is equal to the number of buses, number of columns equal to the number of branches.","category":"section"},{"location":"tutorials/tutorial_LODF_matrix/#LODF-matrix","page":"LODF matrix","title":"LODF matrix","text":"In this tutorial the methods for computing the Line Outage Distribution Factor (LODF) are presented. Before diving into this tutorial we encourage the user to load PowerNetworkMatrices, hit the ? key in the REPL terminal and look for the documentation of the different LODF methods available.","category":"section"},{"location":"tutorials/tutorial_LODF_matrix/#Evaluation-of-the-LODF-matrix","page":"LODF matrix","title":"Evaluation of the LODF matrix","text":"As for the PTDF matrix, the LODF one can be evaluated according to three different approaches:\n\nDense: considers functions for dense matrix multiplication and inversion\nKLU: considers functions for sparse matrix multiplication and inversion (default)\nMKLPardiso: uses Intel's MKL Pardiso solver for sparse matrix operations (only available on Intel-based systems running Linux or Windows)\n\nThe evaluation of the LODF matrix can be easily performed starting from importing the system's data and then by simply calling the LODF method.\n\nusing PowerNetworkMatrices\nusing PowerSystemCaseBuilder\n\nconst PNM = PowerNetworkMatrices\nconst PSB = PowerSystemCaseBuilder\n\n# get the System data\nsys = PSB.build_system(PSB.PSITestSystems, \"c_sys5\");\n\n# compute the LODF matrix\nlodf_1 = LODF(sys);\n\nlodf_2 = LODF(sys, linear_solver=\"Dense\");\n\n# show matrix\nget_lodf_data(lodf_1)\n\nAdvanced users might be interested in computing the LODF matrix starting from either the IncidenceMatrix and PTDF structures (CASE 1), or by the information related to IncidenceMatrix, BA_Matrix and ABA_Matrix (CASE 2).\n\n# CASE 1\n\n# get the Incidence and PTDF matrix\na = IncidenceMatrix(sys);\nptdf = PTDF(sys);\n\n# compute LODF matrix with the two network matrices\nlodf_3 = LODF(a, ptdf);\n\n# CASE 2\n\n# get the BA and ABA matrices (ABA matrix must include LU factorization\n# matrices)\nba = BA_Matrix(sys);\naba = ABA_Matrix(sys, factorize = true);\n\n# compute LODF matrix with the three network matrices\nlodf_4 = LODF(a, aba, ba);\n\nNOTE: whenever the method LODF(sys::System) is used, the methods previously defined for CASE 1 are executed in sequence. Therefore the method LODF(a::IncidenceMatrix, ptdf::PTDF) is the default one when evaluating the LODF matrix from the System data directly.","category":"section"},{"location":"tutorials/tutorial_LODF_matrix/#Available-methods-for-the-computation-of-the-LODF-matrix","page":"LODF matrix","title":"Available methods for the computation of the LODF matrix","text":"For those methods that either require the evaluation of the PTDF matrix, or that execute this evaluation internally, three different approaches can be used.\n\nAs for the PTDF matrix, here too the optional argument linear_solver can be specified with either KLU (for sparse matrix calculation), Dense (for dense matrix calculation), or MKLPardiso (for Intel MKL Pardiso sparse solver).\n\nlodf_dense = LODF(sys, linear_solver=\"Dense\");\n\nlodf_mkl = LODF(sys, linear_solver=\"MKLPardiso\");\n\nNOTE (1): by default the \"KLU\" method is selected, which appeared to require significant less time and memory with respect to \"Dense\". Please note that regardless of which method (KLU, Dense, or MKLPardiso) is used, the resulting LODF matrix is stored as a dense one.\n\nNOTE (2): for the moment, the method LODF(a::IncidenceMatrix, aba::ABA_Matrix, ba::BA_Matrix) will take KLU as linear_solver option.\n\nNote on MKLPardiso: The MKLPardiso solver option is only available on Intel-based systems running Linux or Windows. On other platforms (e.g., ARM-based systems or macOS), use KLU or Dense instead.","category":"section"},{"location":"tutorials/tutorial_LODF_matrix/#\"Sparse\"-LODF-matrix","page":"LODF matrix","title":"\"Sparse\" LODF matrix","text":"The LODF matrix can be computed in a \"sparse\" fashion by defining the input argument tol. If this argument is defined, then elements of the LODF matrix whose absolute values are below the set threshold are dropped. In addition, the matrix will be stored as a sparse one of type SparseArrays.SparseMatrixCSC{Float64, Int} type instead of Matrix{Float64} one.\n\nBy considering an \"extreme\" value of 0.4 as tol, the LODF matrix can be computed as follows:\n\nlodf_sparse = LODF(sys, tol=0.4);\nget_lodf_data(lodf_sparse)\n\nPlease consider that 0.4 was used for the purpose of this tutorial. In practice much smaller values are used (e.g., 1e-5).\n\nNOTE (1): elements whose absolute values exceed the tol argument are removed from the LODF matrix after this has been computed.\n\nNOTE (2): the tol argument does not refer to the \"sparsification\" tolerance of the PTDF matrix that is computed in the LODF method.\n\nNOTE (3): in case the method LODF(a::IncidenceMatrix, ptdf::PTDF) is considered, an error will be thrown whenever the tol argument in the PTDF structure used as input is different than 1e-15.","category":"section"},{"location":"tutorials/tutorial_VirtualPTDF_matrix/#VirtualPTDF","page":"VirtualPTDF matrix","title":"VirtualPTDF","text":"Contrary to the traditional PTDF matrix, the VirtualPTDF is a structure containing rows of the original matrix, related to specific system arcs. The different rows of the PTDF matrix are cached in the VirtualPTDF structure as they are evaluated. This allows to keep just the portion of the original matrix which is of interest to the user, avoiding the unnecessary computation of the whole matrix.\n\nRefer to the different arguments of the VirtualPTDF methods by looking at the \"Public API Reference\" page.","category":"section"},{"location":"tutorials/tutorial_VirtualPTDF_matrix/#How-the-VirtualPTDF-works","page":"VirtualPTDF matrix","title":"How the VirtualPTDF works","text":"The VirtualPTDF is a structure containing everything needed to compute any row of the PTDF matrix and store it. To do so, the VirtualPTDF must store the BA matrix (coming from the BA_Matrix struct) and the inverse of the ABA matrix (coming from ABA_MAtrix struct). In particular, KLU is used to get the LU factorization matrices of the ABA matrix and these ones are stored, avoid the inversion.\n\nOnce the VirtualPTDF is initialized, each row of the PTDF matrix can be evaluated separately. The algorithmic procedure is the following:\n\nDefine the VirtualPTDF structure\nCall any element of the matrix to define and store the relative row as well as showing the selected element\n\nRegarding point 2, if the row has been stored previously then the desired element is just loaded from the cache and shown.\n\nThe flowchart below shows how the VirtualPTDF is structured and how it works. Examples will be presented in the following sections.\n\n<img src=\"../../assets/VirtualPTDF_scheme.png\"/>","category":"section"},{"location":"tutorials/tutorial_VirtualPTDF_matrix/#Initialize-VirtualPTDF-and-compute/access-row/element","page":"VirtualPTDF matrix","title":"Initialize VirtualPTDF and compute/access row/element","text":"As for the PTDF matrix, at first the System data must be loaded. The \"RTS-GMLC\" systems is considered as example:\n\nusing PowerNetworkMatrices\nusing PowerSystems\nusing PowerSystemCaseBuilder\n\nconst PSY = PowerSystems;\nconst PNM = PowerNetworkMatrices;\nconst PSB = PowerSystemCaseBuilder;\n\nsys = PSB.build_system(PSB.PSISystems, \"RTS_GMLC_DA_sys\");\n\nAt this point the VirtualPTDF is initialized with the following simple command:\n\nv_ptdf = VirtualPTDF(sys);\n\nNow, an element of the matrix can be computed by calling the arc tuple and bus number:\n\nel_C31_105 = v_ptdf[(318, 321), 105]\n\nAlternatively, the value can be indexed by row and column numbers directly. In this case the row and column numbers are mapped by the dictonaries contained in the lookup field. \n\nrow_number = v_ptdf.lookup[1][(318, 321)]\ncol_number = v_ptdf.lookup[2][105]\nel_C31_105_bis = v_ptdf[row_number, col_number]\n\nNOTE: this example was made for the sake of completeness and considering the actual arc tuple and bus number is recommended.\n\nAs previously mentioned, in order to evaluate a single element of the VirtualPTDF, the entire row related to the selected arc must be considered. For this reason it is cached in the VirtualPTDF structure for later calls. This is evident by looking at the following example:\n\nsys_2k = PSB.build_system(PSB.PSYTestSystems, \"tamu_ACTIVSg2000_sys\");\n\nv_ptdf_2k = VirtualPTDF(sys_2k);\n\n# evaluate PTDF row related to arc (5270, 5474)\n@time v_ptdf_2k[(5270, 5474), 8155]\n\n# call same element after the row has been stored\n@time v_ptdf_2k[(5270, 5474), 8155]","category":"section"},{"location":"tutorials/tutorial_VirtualPTDF_matrix/#VirtualPTDF-with-distributed-slack-bus","page":"VirtualPTDF matrix","title":"VirtualPTDF with distributed slack bus","text":"As for the PTDF matrix, here too each row can be evaluated considering distributed slack buses. A vector of type Vector{Float64} is defined, specifying the weights for each bus of the system. \n\n# smaller system for the next examples\nsys_2 = PSB.build_system(PSB.PSITestSystems, \"c_sys5\");\n\n# consider equal distribution accross each bus for this example\nbuscount = length(PSY.get_available_components(PSY.ACBus, sys_2));\ndist_slack = 1 / buscount * ones(buscount);\ndis_slack_dict = Dict(i => dist_slack[i] / sum(dist_slack) for i in 1:buscount)\n\nNow initialize the VirtualPTDF by defining the dist_slack field with the vector of weights previously computed:\n\nv_ptdf_distr = VirtualPTDF(sys_2, dist_slack=dis_slack_dict);\nv_ptdf_orig = VirtualPTDF(sys_2);\n\nNow check the difference with the same row related to the branch \"1\" evaluated without considering distributed slack bus.\n\nrow_distr = [v_ptdf_distr[\"1\", j] for j in v_ptdf_distr.axes[2]]\nrow_original = [v_ptdf_orig[\"1\", j] for j in v_ptdf_orig.axes[2]]","category":"section"},{"location":"tutorials/tutorial_VirtualPTDF_matrix/#\"Sparse\"-VirtualPTDF","page":"VirtualPTDF matrix","title":"\"Sparse\" VirtualPTDF","text":"Sparsification of each row can be achieved in the same fashion as for the PTDF matrix, by removing those elements whose absolute values is below a certain threshold.\n\nAs for the example show for the PTDF matrix, here to a very high values of 0.2 is considered for the tol field. Again, this value is considered just for the sake of this example.\n\nv_ptdf_dense = VirtualPTDF(sys_2);\nv_ptdf_sparse = VirtualPTDF(sys_2, tol=0.2);\n\nLet's now evaluate the same row as before and compare the results:\n\noriginal_row = [v_ptdf_dense[\"1\", j] for j in v_ptdf_dense.axes[2]]\nsparse_row = [v_ptdf_sparse[\"1\", j] for j in v_ptdf_sparse.axes[2]]","category":"section"},{"location":"tutorials/tutorial_VirtualPTDF_matrix/#Network-Reductions","page":"VirtualPTDF matrix","title":"Network Reductions","text":"The VirtualPTDF can be computed with network reductions applied to simplify the system topology. Network reductions eliminate certain buses and branches while preserving the electrical characteristics of the network. This can significantly reduce computation time and memory usage for large systems.\n\nTwo types of network reductions are supported:\n\nRadialReduction: Eliminates radial (leaf) buses that have only one connection\nDegreeTwoReduction: Eliminates degree-two buses (buses with exactly two connections) by combining their incident branches\n\nFor detailed information about these reductions, see the RadialReduction tutorial and DegreeTwoReduction tutorial.","category":"section"},{"location":"tutorials/tutorial_VirtualPTDF_matrix/#Using-Network-Reductions-with-VirtualPTDF","page":"VirtualPTDF matrix","title":"Using Network Reductions with VirtualPTDF","text":"To apply network reductions, pass a vector of NetworkReduction objects to the network_reductions keyword argument:\n\n# Apply radial reduction\nv_ptdf_radial = VirtualPTDF(sys_2, network_reductions=[RadialReduction()]);\n\n# Apply degree-two reduction\nv_ptdf_degree_two = VirtualPTDF(sys_2, network_reductions=[DegreeTwoReduction()]);\n\n# Combine multiple reductions (order matters - RadialReduction first is recommended)\nv_ptdf_combined = VirtualPTDF(sys_2, network_reductions=[RadialReduction(), DegreeTwoReduction()]);","category":"section"},{"location":"tutorials/tutorial_VirtualPTDF_matrix/#Protecting-Specific-Buses-from-Reduction","page":"VirtualPTDF matrix","title":"Protecting Specific Buses from Reduction","text":"Both reduction types allow you to specify buses that should not be eliminated using the irreducible_buses parameter:\n\n# Protect specific buses from radial reduction\nreduction = RadialReduction(irreducible_buses=[1, 2])\nv_ptdf_protected = VirtualPTDF(sys_2, network_reductions=[reduction]);","category":"section"},{"location":"tutorials/tutorial_VirtualPTDF_matrix/#DegreeTwoReduction-Options","page":"VirtualPTDF matrix","title":"DegreeTwoReduction Options","text":"The DegreeTwoReduction has an additional option to control whether buses with reactive power injections are reduced:\n\n# Preserve buses with reactive power injections\nreduction = DegreeTwoReduction(reduce_reactive_power_injectors=false)\nv_ptdf_preserve_reactive = VirtualPTDF(sys_2, network_reductions=[reduction]);","category":"section"},{"location":"tutorials/tutorial_VirtualPTDF_matrix/#Accessing-Reduction-Information","page":"VirtualPTDF matrix","title":"Accessing Reduction Information","text":"After initializing the VirtualPTDF with reductions, you can access information about what was reduced:\n\nv_ptdf_reduced = VirtualPTDF(sys_2, network_reductions=[RadialReduction(), DegreeTwoReduction()]);\n\n# Get the reduction data\nreduction_data = get_network_reduction_data(v_ptdf_reduced)","category":"section"},{"location":"tutorials/tutorial_VirtualPTDF_matrix/#Combining-Reductions-with-Other-Options","page":"VirtualPTDF matrix","title":"Combining Reductions with Other Options","text":"Network reductions can be combined with other VirtualPTDF options like distributed slack and sparsification:\n\nv_ptdf_full_options = VirtualPTDF(sys_2,\n    dist_slack=dis_slack_dict,\n    tol=1e-5,\n    network_reductions=[RadialReduction(), DegreeTwoReduction()]\n);\n\nNOTE: The VirtualPTDF only supports KLU and AppleAccelerate linear solvers when using network reductions. The reference (slack) bus is automatically protected from elimination during reductions.","category":"section"},{"location":"api/public/#Public-API-Reference","page":"Public API Reference","title":"Public API Reference","text":"","category":"section"},{"location":"api/public/#PowerNetworkMatrices.ABA_Matrix","page":"Public API Reference","title":"PowerNetworkMatrices.ABA_Matrix","text":"Structure containing the ABA matrix and related power system analysis data.\n\nThe ABA matrix represents the bus susceptance matrix computed as A^T * B * A, where A is the incidence matrix and B is the branch susceptance matrix. This matrix is fundamental for DC power flow analysis, sensitivity calculations, and linear power system studies.\n\nFields\n\ndata::SparseArrays.SparseMatrixCSC{Float64, Int}:       The ABA matrix data representing the bus susceptance matrix. This square matrix has       dimensions equal to the number of buses excluding reference buses\naxes::Ax:       Tuple containing identical bus number vectors for rows and columns, excluding reference buses\nlookup::L <: NTuple{2, Dict}:       Tuple of identical dictionaries providing fast lookup from bus numbers to matrix indices\nsubnetwork_axes::Dict{Int, Ax}:       Mapping from reference bus numbers to their corresponding subnetwork axes\nref_bus_position::Vector{Int}:       Vector containing the original indices of reference buses before matrix reduction\nK::F <: Union{Nothing, KLU.KLUFactorization{Float64, Int}}:       Optional KLU factorization object for efficient linear system solving. Nothing if unfactorized\nnetwork_reduction_data::NetworkReductionData:       Container for network reduction information applied during matrix construction\n\nMathematical Properties\n\nMatrix Form: ABA = A^T * B * A (bus susceptance matrix)\nDimensions: (nbuses - nref) × (nbuses - nref)\nSymmetry: Positive definite symmetric matrix (for connected networks)\nSparsity: Inherits sparsity pattern from network topology\n\nNotes\n\nReference buses are excluded from the matrix to ensure invertibility\nFactorization enables efficient solving of linear systems Ax = b\nUsed primarily for DC power flow analysis and power system sensitivity studies\nSupports various network reduction techniques for computational efficiency\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PowerNetworkMatrices.ABA_Matrix-Tuple{PowerSystems.System}","page":"Public API Reference","title":"PowerNetworkMatrices.ABA_Matrix","text":"ABA_Matrix(sys; factorize, network_reductions, kwargs...)\n\n\nABA_Matrix(sys::PSY.System; factorize::Bool = false, network_reductions::Vector{NetworkReduction} = NetworkReduction[], kwargs...)\n\nConstruct an ABA_Matrix from a PowerSystems.System by computing A^T * B * A where A is the incidence matrix and B is the branch susceptance matrix. The resulting matrix is fundamental for DC power flow analysis and power system sensitivity studies.\n\nArguments\n\nsys::PSY.System: The power system from which to construct the ABA matrix\n\nKeyword Arguments\n\nfactorize::Bool = false:       Whether to perform KLU factorization during construction for efficient linear system solving\nnetwork_reductions::Vector{NetworkReduction} = NetworkReduction[]:       Vector of network reduction algorithms to apply before matrix construction\ninclude_constant_impedance_loads::Bool=true:        Whether to include constant impedance loads as shunt admittances in the network model\nsubnetwork_algorithm=iterative_union_find:       Algorithm used for identifying electrical islands and connected components\nAdditional keyword arguments are passed to the underlying Ybus constructor\n\nReturns\n\nABA_Matrix: The constructed ABA matrix structure containing:\nBus susceptance matrix data (excluding reference buses)\nNetwork topology information and reference bus positions\nOptional KLU factorization for efficient solving\n\nMathematical Process\n\nYbus Construction: Creates admittance matrix from system data\nIncidence Matrix: Computes bus-branch incidence matrix A\nBA Matrix: Forms branch susceptance weighted incidence matrix\nABA Computation: Calculates A^T * B * A (bus susceptance matrix)\nReference Bus Removal: Excludes reference buses for invertibility\nOptional Factorization: Performs KLU decomposition if requested\n\nNotes\n\nReference buses are automatically detected and excluded from the final matrix\nFactorization significantly improves performance for repeated linear system solves\nNetwork reductions can dramatically improve computational efficiency for large systems\nThe resulting matrix supports PTDF, LODF, and other power system analysis calculations\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.AdjacencyMatrix","page":"Public API Reference","title":"PowerNetworkMatrices.AdjacencyMatrix","text":"AdjacencyMatrix{Ax, L} <: PowerNetworkMatrix{Int8}\n\nAn N × N adjacency matrix representing the connectivity structure of a power system with N buses. This matrix describes the directed connectivity between buses, where non-zero entries indicate electrical connections through transmission lines, transformers, or other network elements.\n\nThe matrix is indexed using bus numbers, which do not need to be sequential. Each element A[i,j] is non-zero if there is a direct electrical connection between bus i and bus j. Diagonal elements are typically zero since self-loops are not meaningful in power network topology.\n\nFields\n\ndata::SparseArrays.SparseMatrixCSC{Int8, Int}: The sparse adjacency matrix storing connectivity information as Int8 values (zero for no connection, non-zero for connection)\naxes::Ax: Tuple containing the axis labels for both dimensions. The first element contains bus identifiers for rows, the second contains bus identifiers for columns (typically identical)\nlookup::L: Tuple of dictionaries providing bidirectional mapping between bus numbers and their corresponding matrix indices\nsubnetwork_axes::Dict{Int, Ax}: Dictionary mapping subnetwork identifiers to their corresponding axis information, used for handling electrical islands\nnetwork_reduction_data::NetworkReductionData: Container for network reduction algorithms and their associated data, enabling efficient matrix operations on reduced networks\n\nExamples\n\n# Create from a PowerSystems.System\nsys = System(\"case5.m\")\nadj = AdjacencyMatrix(sys)\n\n# Create from a Ybus matrix\nybus = Ybus(sys)\nadj = AdjacencyMatrix(ybus)\n\n# Check connectivity\nis_connected = validate_connectivity(adj)\nsubnetworks = find_subnetworks(adj)\n\nSee also: Ybus, IncidenceMatrix, PowerNetworkMatrix\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PowerNetworkMatrices.AdjacencyMatrix-Tuple{PowerSystems.System}","page":"Public API Reference","title":"PowerNetworkMatrices.AdjacencyMatrix","text":"AdjacencyMatrix(sys; kwargs...)\n\n\nAdjacencyMatrix(sys::PSY.System; kwargs...)\n\nConstruct an AdjacencyMatrix from a PowerSystems.System.\n\nArguments\n\nsys::PSY.System: The power system from which to construct the adjacency matrix\n\nKeyword arguments\n\nnetwork_reductions::Vector{NetworkReduction}=[]: Network reduction algorithms to apply\ninclude_constant_impedance_loads::Bool=true: Whether to include constant impedance loads as shunt admittances\nsubnetwork_algorithm=iterative_union_find: Algorithm for finding electrical islands\n\nReturns\n\nAdjacencyMatrix: An N x N adjacency matrix indexed with bus numbers showing connectivity\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.AdjacencyMatrix-Tuple{Ybus}","page":"Public API Reference","title":"PowerNetworkMatrices.AdjacencyMatrix","text":"AdjacencyMatrix(ybus)\n\n\nAdjacencyMatrix(ybus::Ybus)\n\nConstruct an AdjacencyMatrix from a Ybus matrix.\n\nArguments\n\nybus::Ybus: The Ybus matrix from which to construct the adjacency matrix\n\nReturns\n\nAdjacencyMatrix: The constructed adjacency matrix showing bus connectivity\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.ArcAdmittanceMatrix","page":"Public API Reference","title":"PowerNetworkMatrices.ArcAdmittanceMatrix","text":"Arc admittance matrix\n\nArguments\n\ndata::SparseArrays.SparseMatrixCSC{ComplexF32, Int}:       The arc admittance matrix in the from-to direction\naxes<:NTuple{2, Dict}:       Tuple containing two vectors (the first one showing the arc tuples,       the second showing the buses numbers).\nlookup<:NTuple{2, Dict}:       Tuple containing two dictionaries, the first mapping the arc tuples       and the second the buses with their enumerated indexes.\nnetwork_reduction::NetworkReduction:       Structure containing the details of the network reduction applied when computing the matrix\ndirection::Symbol:       Direction of admittance (:FromTo or :ToFrom)\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PowerNetworkMatrices.BA_Matrix","page":"Public API Reference","title":"PowerNetworkMatrices.BA_Matrix","text":"Structure containing the BA matrix and related network topology data.\n\nThe BA matrix represents the branch-bus incidence matrix weighted by branch susceptances, computed as the product of the incidence matrix A and the susceptance matrix B.\n\nFields\n\ndata::SparseArrays.SparseMatrixCSC{Float64, Int}:       The transposed BA matrix data. Each row corresponds to a bus and each column       corresponds to a branch, with values representing weighted branch susceptances\naxes::Ax:       Tuple containing two vectors: bus numbers (rows) and branch identifiers (columns)\nlookup::L <: NTuple{2, Dict}:       Tuple of dictionaries providing fast lookup from bus/branch names to matrix indices\nsubnetwork_axes::Dict{Int, Ax}:       Mapping from reference bus numbers to their corresponding subnetwork axes\nnetwork_reduction_data::NetworkReductionData:       Container for network reduction information applied during matrix construction\n\nNotes\n\nThe matrix is stored in transposed form for computational efficiency\nReference buses are identified through subnetwork_axes keys\nSupports various network reduction techniques for computational efficiency\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PowerNetworkMatrices.BA_Matrix-Tuple{PowerSystems.System}","page":"Public API Reference","title":"PowerNetworkMatrices.BA_Matrix","text":"BA_Matrix(sys; network_reductions, kwargs...)\n\n\nBA_Matrix(sys::PSY.System; network_reductions::Vector{NetworkReduction} = Vector{NetworkReduction}(), kwargs...)\n\nConstruct a BA_Matrix from a PowerSystems.System by first building the underlying Ybus matrix and then computing the branch-bus incidence matrix weighted by branch susceptances.\n\nArguments\n\nsys::PSY.System: The power system from which to construct the BA matrix\n\nKeyword Arguments\n\nnetwork_reductions::Vector{NetworkReduction} = Vector{NetworkReduction}():       Vector of network reduction algorithms to apply before matrix construction\ninclude_constant_impedance_loads::Bool=true:       Whether to include constant impedance loads as shunt admittances in the network model\nsubnetwork_algorithm=iterative_union_find:       Algorithm used for identifying electrical islands and connected components\nAdditional keyword arguments are passed to the underlying Ybus constructor\n\nReturns\n\nBA_Matrix: The constructed BA matrix structure containing the transposed branch-bus incidence             matrix weighted by susceptances, along with network topology information\n\nNotes\n\nThis constructor creates a Ybus matrix internally and then converts it to a BA_Matrix\nNetwork reductions can significantly improve computational efficiency for large systems\nThe resulting matrix supports DC power flow calculations and sensitivity analysis\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.BA_Matrix-Tuple{Ybus}","page":"Public API Reference","title":"PowerNetworkMatrices.BA_Matrix","text":"BA_Matrix(ybus)\n\n\nBA_Matrix(ybus::Ybus)\n\nConstruct a BA_Matrix from a Ybus matrix.\n\nArguments\n\nybus::Ybus: The Ybus matrix from which to construct the BA matrix\n\nReturns\n\nBA_Matrix: The constructed BA matrix structure containing the transposed BA matrix\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.DegreeTwoReduction","page":"Public API Reference","title":"PowerNetworkMatrices.DegreeTwoReduction","text":"DegreeTwoReduction <: NetworkReduction\n\nNetwork reduction algorithm that eliminates buses with exactly two connections by combining the incident branches into a single equivalent branch. This reduction preserves the electrical characteristics of the network while simplifying its topology.\n\nFields\n\nirreducible_buses::Vector{Int}: List of bus numbers that should not be eliminated even if they have degree two\nreduce_reactive_power_injectors::Bool: Whether to reduce buses with reactive power injections (default: true)\n\nExamples\n\n# Create degree-two reduction with default settings\nreduction = DegreeTwoReduction()\n\n# Create degree-two reduction protecting specific buses\nreduction = DegreeTwoReduction(irreducible_buses=[101, 205])\n\n# Create reduction that preserves buses with reactive power injections\nreduction = DegreeTwoReduction(reduce_reactive_power_injectors=false)\n\n# Apply to system\nybus = Ybus(system; network_reductions=[reduction])\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PowerNetworkMatrices.IncidenceMatrix","page":"Public API Reference","title":"PowerNetworkMatrices.IncidenceMatrix","text":"Structure containing the network incidence matrix and related topology data.\n\nThe incidence matrix A represents the bus-branch connectivity of the power network, where each row corresponds to a branch and each column corresponds to a bus. Elements are:\n\n+1 for the \"from\" bus of a branch\n-1 for the \"to\" bus of a branch  \n0 for buses not connected to the branch\n\nFields\n\ndata::SparseArrays.SparseMatrixCSC{Int8, Int}:       The incidence matrix data with dimensions (nbranches × nbuses). Values are {-1, 0, +1}       representing the directed connectivity between branches and buses\naxes::Ax:       Tuple containing (arcidentifiers, busnumbers) where arcs are branch endpoint pairs       and buses are the network bus numbers\nlookup::L <: NTuple{2, Dict}:       Tuple of dictionaries providing fast lookup from arc/bus identifiers to matrix indices\nsubnetwork_axes::Dict{Int, Ax}:       Mapping from reference bus numbers to their corresponding subnetwork axes\nnetwork_reduction_data::NetworkReductionData:       Container for network reduction information applied during matrix construction\n\nMathematical Properties\n\nMatrix Dimensions: (nbranches × nbuses)\nElement Values: {-1, 0, +1} representing directed branch-bus connectivity\nRow Sum: Each row sums to zero (conservation at branch level)\nRank: Rank is (nbuses - nislands) for connected networks\nSparsity: Very sparse with exactly 2 non-zero elements per branch row\n\nApplications\n\nPower Flow: Forms the basis for DC power flow equations: P = A^T * f\nSensitivity Analysis: Used in PTDF and LODF calculations\nNetwork Analysis: Identifies connected components and network structure\nTopology Processing: Enables network reduction and equivalencing algorithms\n\nNotes\n\nEach branch contributes exactly one row with two non-zero entries (+1, -1)\nReference buses are preserved in the matrix but identified separately\nSupports various network reduction techniques for computational efficiency\nEssential building block for BAMatrix and ABAMatrix constructions\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PowerNetworkMatrices.IncidenceMatrix-Tuple{PowerSystems.System}","page":"Public API Reference","title":"PowerNetworkMatrices.IncidenceMatrix","text":"IncidenceMatrix(sys; network_reductions, kwargs...)\n\n\nIncidenceMatrix(sys::PSY.System; network_reductions::Vector{NetworkReduction} = NetworkReduction[], kwargs...)\n\nConstruct an IncidenceMatrix from a PowerSystems.System by extracting the network topology and creating the bus-branch connectivity matrix fundamental to power system analysis.\n\nArguments\n\nsys::PSY.System: The power system from which to construct the incidence matrix\n\nKeyword Arguments\n\nnetwork_reductions::Vector{NetworkReduction} = NetworkReduction[]:        Vector of network reduction algorithms to apply before matrix construction\ninclude_constant_impedance_loads::Bool=true:        Whether to include constant impedance loads as shunt admittances in the network model\nsubnetwork_algorithm=iterative_union_find:        Algorithm used for identifying electrical islands and connected components\nAdditional keyword arguments are passed to the underlying Ybus constructor\n\nReturns\n\nIncidenceMatrix: The constructed incidence matrix structure containing:\nBus-branch connectivity matrix with {-1, 0, +1} elements\nNetwork topology information and reference bus identification\nSupport for network reductions and connected component analysis\n\nMathematical Construction\n\nNetwork Extraction: Identifies all branches and buses from the power system\nConnectivity Mapping: Creates directed branch-bus relationships  \nMatrix Assembly: Constructs sparse matrix with +1/-1 entries for branch endpoints\nTopology Analysis: Identifies reference buses and connected components\nNetwork Reductions: Applies specified reduction algorithms if provided\n\nApplications\n\nFoundation Matrix: Essential for constructing BAMatrix and ABAMatrix\nDC Power Flow: Enables linearized power flow analysis through P = A^T * f\nSensitivity Analysis: Required for PTDF, LODF, and other sensitivity calculations\nNetwork Analysis: Supports topology processing and network equivalencing\n\nNotes\n\nEach branch creates exactly one matrix row with two non-zero entries\nNetwork reductions can significantly improve computational efficiency\nReference buses are automatically identified for later matrix operations\nThe matrix preserves full network topology for comprehensive power system analysis\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.IncidenceMatrix-Tuple{Ybus}","page":"Public API Reference","title":"PowerNetworkMatrices.IncidenceMatrix","text":"IncidenceMatrix(ybus)\n\n\nIncidenceMatrix(ybus::Ybus)\n\nConstruct an IncidenceMatrix from an existing Ybus matrix by extracting the network topology and creating the bus-branch connectivity matrix. This constructor leverages the network  structure already captured in the Ybus matrix.\n\nArguments\n\nybus::Ybus: The Ybus matrix containing network topology and admittance data\n\nReturns\n\nIncidenceMatrix: The constructed incidence matrix structure containing:\nBus-branch connectivity matrix with {-1, 0, +1} elements representing directed connections\nNetwork topology information extracted from the Ybus structure\nReference bus identification and subnetwork axes from the source matrix\nNetwork reduction data inherited from the Ybus matrix\n\nConstruction Process\n\nTopology Extraction: Retrieves bus and branch information from the Ybus matrix\nArc Processing: Creates directed arc representations from branch connectivity\nMatrix Assembly: Constructs sparse incidence matrix with +1 (from bus) and -1 (to bus) entries\nIsolated Bus Handling: Includes isolated buses with zero entries for completeness\nMetadata Transfer: Preserves reference bus positions and network reduction information\n\nMathematical Properties\n\nMatrix Form: A[i,j] = +1 if branch i originates at bus j, -1 if it terminates at bus j, 0 otherwise\nDimensions: (nbranches × nbuses) including all network branches and buses\nSparsity: Exactly 2 non-zero entries per branch row (except for isolated buses)\nConsistency: Maintains the same network topology and reduction state as the source Ybus\n\nNotes\n\nThis constructor is more efficient when a Ybus matrix is already available\nPreserves all network reduction information from the source matrix\nIsolated buses are handled explicitly to maintain network completeness\nEssential for creating downstream matrices like BAMatrix and ABAMatrix from existing Ybus\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.LODF","page":"Public API Reference","title":"PowerNetworkMatrices.LODF","text":"Structure containing the Line Outage Distribution Factor (LODF) matrix and related power system data.\n\nThe LODF matrix contains sensitivity coefficients that quantify how the outage of one transmission  line affects the power flows on all other lines in the system. Each element LODF[i,j] represents  the change in flow on line i when line j is taken out of service, normalized by the pre-outage  flow on line j.\n\nFields\n\ndata::M <: AbstractArray{Float64, 2}:       The LODF matrix data stored in transposed form for computational efficiency.        Element (i,j) represents the sensitivity of line j flow to line i outage\naxes::Ax:       Tuple of identical branch/arc identifier vectors for both matrix dimensions\nlookup::L <: NTuple{2, Dict}:       Tuple of identical dictionaries providing fast lookup from branch identifiers to matrix indices\nsubnetwork_axes::Dict{Int, Ax}:       Mapping from reference bus numbers to their corresponding subnetwork branch axes\ntol::Base.RefValue{Float64}:       Tolerance threshold used for matrix sparsification (elements below this value are dropped)\nnetwork_reduction_data::NetworkReductionData:       Container for network reduction information applied during matrix construction\n\nMathematical Properties\n\nMatrix Form: LODF[i,j] = ∂fi/∂Pj where fi is flow on line i, Pj is injection change due to line j outage\nDimensions: (nbranches × nbranches) for all transmission lines in the system\nDiagonal Elements: Always -1 (100% flow reduction on the outaged line itself)\nSymmetry: Generally non-symmetric matrix reflecting directional flow sensitivities\nPhysical Meaning: Values represent fraction of pre-outage flow that redistributes to other lines\n\nApplications\n\nContingency Analysis: Evaluate impact of single line outages on system flows\nSecurity Assessment: Identify critical transmission bottlenecks and vulnerable lines\nSystem Planning: Analyze network robustness and redundancy requirements\nReal-time Operations: Support operator decision-making for preventive/corrective actions\n\nComputational Notes\n\nStorage: Matrix stored in transposed form for efficient column-wise access patterns\nSparsification: Small elements removed based on tolerance to reduce memory usage\nLinear Approximation: Based on DC power flow assumptions (neglects voltage magnitudes and reactive power)\nSingle Contingencies: Designed for single line outage analysis (N-1 contingencies)\n\nUsage Notes\n\nAccess via lodf[monitored_line, outaged_line] returns sensitivity coefficient\nDiagonal elements are always -1.0 representing complete flow loss on outaged line\nMatrix sparsification improves performance but may introduce small numerical errors\nResults valid under DC power flow assumptions and normal operating conditions\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PowerNetworkMatrices.LODF-Tuple{IncidenceMatrix, ABA_Matrix, BA_Matrix}","page":"Public API Reference","title":"PowerNetworkMatrices.LODF","text":"LODF(A, ABA, BA; linear_solver, tol)\n\n\nLODF(A::IncidenceMatrix, ABA::ABA_Matrix, BA::BA_Matrix; linear_solver::String = \"KLU\", tol::Float64 = eps())\n\nConstruct a Line Outage Distribution Factor (LODF) matrix from incidence, ABA, and BA matrices. This constructor provides direct control over the underlying matrix computations and is most efficient when the prerequisite matrices with factorization are already available.\n\nArguments\n\nA::IncidenceMatrix: The incidence matrix containing bus-branch connectivity information\nABA::ABA_Matrix: The bus susceptance matrix (A^T * B * A), preferably with KLU factorization\nBA::BA_Matrix: The branch susceptance weighted incidence matrix (B * A)\n\nKeyword Arguments\n\nlinear_solver::String = \"KLU\":        Linear solver algorithm for matrix computations. Currently only \"KLU\" is supported\ntol::Float64 = eps():        Sparsification tolerance for dropping small matrix elements\n\nReturns\n\nLODF: The constructed LODF matrix structure with line outage sensitivity coefficients\n\nMathematical Computation\n\nThis method computes LODF using the factorized form:\n\nLODF = (A * ABA^(-1) * BA) / (1 - diag(A * ABA^(-1) * BA))\n\nwhere:\n\nA is the incidence matrix\nABA^(-1) uses the factorized form from the ABA matrix (requires ABA.K to be factorized)\nBA is the susceptance-weighted incidence matrix\n\nRequirements and Limitations\n\nFactorization Required: The ABA matrix should be pre-factorized (contains KLU factorization) for efficiency\nSingle Slack Bus: This method does not support distributed slack bus configurations\nNetwork Consistency: All three input matrices must have equivalent network reduction states\nSolver Limitation: Currently only supports \"KLU\" linear solver\n\nPerformance Advantages\n\nPre-factorization: Leverages existing KLU factorization in ABA matrix for maximum efficiency\nDirect Computation: Avoids intermediate PTDF calculation, reducing computational steps\nMemory Efficient: Works directly with sparse matrix structures throughout computation\nNumerical Stability: Uses numerically stable KLU solver for matrix operations\n\nError Handling\n\nValidates network reduction consistency across all three input matrices\nRaises error if matrices have mismatched reduction states\nValidates linear solver selection (currently only \"KLU\" supported)\n\nUsage Recommendations\n\nUse this constructor when you have pre-computed and factorized matrices available\nEnsure ABA matrix is factorized using factorize(ABA) or constructed with factorize=true\nFor systems with distributed slack, use the PTDF-based constructor instead\nMost efficient option for repeated LODF computations on the same network topology\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.LODF-Tuple{IncidenceMatrix, PTDF}","page":"Public API Reference","title":"PowerNetworkMatrices.LODF","text":"LODF(A, PTDFm; linear_solver, tol)\n\n\nLODF(A::IncidenceMatrix, PTDFm::PTDF; linear_solver::String = \"KLU\", tol::Float64 = eps())\n\nConstruct a Line Outage Distribution Factor (LODF) matrix from existing incidence and PTDF matrices. This constructor is more efficient when the prerequisite matrices are already available.\n\nArguments\n\nA::IncidenceMatrix: The incidence matrix containing bus-branch connectivity information\nPTDFm::PTDF: The power transfer distribution factor matrix (should be non-sparsified for accuracy)\n\nKeyword Arguments\n\nlinear_solver::String = \"KLU\":        Linear solver algorithm for matrix computations. Options: \"KLU\", \"Dense\", \"MKLPardiso\"\ntol::Float64 = eps():        Sparsification tolerance for the LODF matrix (not applied to input PTDF)\n\nReturns\n\nLODF: The constructed LODF matrix structure with line outage sensitivity coefficients\n\nMathematical Computation\n\nThe LODF matrix is computed using the formula:\n\nLODF = (A * PTDF) / (1 - diag(A * PTDF))\n\nwhere:\n\nA is the incidence matrix representing bus-branch connectivity\nPTDF contains power transfer distribution factors\nThe denominator (1 - diagonal terms) accounts for the outaged line's own flow\n\nImportant Notes\n\nPTDF Sparsification: The input PTDF matrix should be non-sparsified (constructed with default tolerance) to avoid accuracy issues\nTolerance Application: The tol parameter only affects LODF sparsification, not the input PTDF\nNetwork Consistency: Both input matrices must have equivalent network reduction states\nDiagonal Elements: Automatically set to -1.0 representing complete flow loss on outaged lines\n\nPerformance Considerations\n\nMatrix Validation: Warns if input PTDF was sparsified and converts to dense format for accuracy\nMemory Usage: Sparsification with tol > eps() can significantly reduce memory requirements\nComputational Efficiency: More efficient than system-based constructor when matrices exist\n\nError Handling\n\nValidates that incidence and PTDF matrices have consistent network reduction data\nIssues warnings if sparsified PTDF matrices are used (potential accuracy issues)\nSupports automatic conversion of sparse PTDF to dense format when necessary\n\nLinear Solver Selection\n\n\"KLU\": Recommended for most applications (sparse, numerically stable)\n\"Dense\": Faster for smaller systems but higher memory usage\n\"MKLPardiso\": Best performance for very large systems (requires MKL library)\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.LODF-Tuple{PowerSystems.System}","page":"Public API Reference","title":"PowerNetworkMatrices.LODF","text":"LODF(sys; linear_solver, tol, network_reductions, kwargs...)\n\n\nLODF(sys::PSY.System; linear_solver::String = \"KLU\", tol::Float64 = eps(), network_reductions::Vector{NetworkReduction} = NetworkReduction[], kwargs...)\n\nConstruct a Line Outage Distribution Factor (LODF) matrix from a PowerSystems.System by computing  the sensitivity of line flows to single line outages. This is the primary constructor for LODF  analysis starting from system data.\n\nArguments\n\nsys::PSY.System: The power system from which to construct the LODF matrix\n\nKeyword Arguments\n\nlinear_solver::String = \"KLU\":        Linear solver algorithm for matrix computations. Options: \"KLU\", \"Dense\", \"MKLPardiso\"\ntol::Float64 = eps():        Sparsification tolerance for dropping small matrix elements to reduce memory usage\nnetwork_reductions::Vector{NetworkReduction} = NetworkReduction[]:        Vector of network reduction algorithms to apply before matrix construction\ninclude_constant_impedance_loads::Bool=true:        Whether to include constant impedance loads as shunt admittances in the network model\nsubnetwork_algorithm=iterative_union_find:        Algorithm used for identifying electrical islands and connected components\nAdditional keyword arguments are passed to the underlying matrix constructors\n\nReturns\n\nLODF: The constructed LODF matrix structure containing:\nLine-to-line outage sensitivity coefficients\nNetwork topology information and branch identifiers\nSparsification tolerance and computational metadata\n\nConstruction Process\n\nYbus Construction: Creates system admittance matrix with specified reductions\nIncidence Matrix: Builds bus-branch connectivity matrix A\nBA Matrix: Computes branch susceptance weighted incidence matrix\nPTDF Calculation: Derives power transfer distribution factors\nLODF Computation: Calculates line outage distribution factors from PTDF\nSparsification: Applies tolerance threshold to reduce matrix density\n\nLinear Solver Options\n\n\"KLU\": Sparse LU factorization (default, recommended for most cases)\n\"Dense\": Dense matrix operations (faster for small systems)\n\"MKLPardiso\": Intel MKL Pardiso solver (requires MKL, best for very large systems)\n\nMathematical Foundation\n\nThe LODF matrix is computed using the relationship:\n\nLODF = (A * PTDF) / (1 - diag(A * PTDF))\n\nwhere A is the incidence matrix and PTDF is the power transfer distribution factor matrix.\n\nNotes\n\nSparsification with tol > eps() can significantly reduce memory usage\nNetwork reductions can improve computational efficiency for large systems\nResults are valid under DC power flow assumptions (linear approximation)\nDiagonal elements are always -1.0 representing complete flow loss on outaged lines\nFor very large systems, consider using \"MKLPardiso\" solver with appropriate chunk size\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.NetworkReduction","page":"Public API Reference","title":"PowerNetworkMatrices.NetworkReduction","text":"NetworkReduction\n\nAbstract base type for all network reduction algorithms used in power network analysis. Network reductions are mathematical transformations that eliminate buses and branches  while preserving the electrical behavior of the remaining network elements.\n\nConcrete implementations include:\n\nRadialReduction: Eliminates radial (dangling) buses and branches\nDegreeTwoReduction: Eliminates buses with exactly two connections\nWardReduction: Reduces external buses while preserving study bus behavior\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PowerNetworkMatrices.NetworkReductionData","page":"Public API Reference","title":"PowerNetworkMatrices.NetworkReductionData","text":"NetworkReductionData\n\nMutable struct containing all data mappings and metadata for network reduction operations. This structure tracks how buses and branches are mapped, combined, or eliminated during network reduction algorithms.\n\nFields\n\nirreducible_buses::Set{Int}: Buses that cannot be reduced\nbus_reduction_map::Dict{Int, Set{Int}}: Maps retained buses to sets of eliminated buses\nreverse_bus_search_map::Dict{Int, Int}: Maps eliminated buses to their parent buses\ndirect_branch_map::Dict{Tuple{Int, Int}, PSY.ACTransmission}: One-to-one branch mappings\nreverse_direct_branch_map::Dict{PSY.ACTransmission, Tuple{Int, Int}}: Reverse direct mappings\nparallel_branch_map::Dict{Tuple{Int, Int}, BranchesParallel}: Parallel branch combinations\nreverse_parallel_branch_map::Dict{PSY.ACTransmission, Tuple{Int, Int}}: Reverse parallel mappings\nseries_branch_map::Dict{Tuple{Int, Int}, BranchesSeries}: Series branch combinations\nreverse_series_branch_map::Dict{Any, Tuple{Int, Int}}: Reverse series mappings\ntransformer3W_map::Dict{Tuple{Int, Int}, ThreeWindingTransformerWinding}: Three-winding transformer mappings\nreverse_transformer3W_map::Dict{ThreeWindingTransformerWinding, Tuple{Int, Int}}: Reverse transformer mappings\nremoved_buses::Set{Int}: Set of buses eliminated from the network\nremoved_arcs::Set{Tuple{Int, Int}}: Set of arcs eliminated from the network\nadded_admittance_map::Dict{Int, Complex{Float32}}: Admittances added to buses during reduction\nadded_branch_map::Dict{Tuple{Int, Int}, Complex{Float32}}: New branches created during reduction\nall_branch_maps_by_type::Dict{String, Any}: Branch mappings organized by component type\nreductions::ReductionContainer: Container tracking applied reduction algorithms\nname_to_arc_map::Dict{Type, DataStructures.SortedDict{String, Tuple{Tuple{Int, Int}, String}}}: Lazily filled with the call to populate_branch_maps_by_type!, maps string names to their corresponding arcs and the map where the arc can be found. Used in optimization models or power flow reporting after reductions are applied. It is possible to have repeated arcs for some names if case of serial or parallel combinations.\nfilters_applied::Dict{Type, Function}: Filters applied when populating branch maps by type\ndirect_branch_name_map::Dict{String, Tuple{Int, Int}}: Lazily filled, maps branch names to their corresponding arc tuples for direct branches\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PowerNetworkMatrices.PTDF","page":"Public API Reference","title":"PowerNetworkMatrices.PTDF","text":"Structure containing the Power Transfer Distribution Factor (PTDF) matrix and related power system data.\n\nThe PTDF matrix contains sensitivity coefficients that quantify how power injections at buses affect the power flows on transmission lines. Each element PTDF[i,j] represents the incremental change in flow on line i due to a unit power injection at bus j, under DC power flow assumptions.\n\nFields\n\ndata::M <: AbstractArray{Float64, 2}:       The PTDF matrix data stored in transposed form for computational efficiency.       Element (i,j) represents the sensitivity of line j flow to bus i injection\naxes::Ax:       Tuple containing (busnumbers, branchidentifiers) for matrix dimensions\nlookup::L <: NTuple{2, Dict}:       Tuple of dictionaries providing fast lookup from bus/branch identifiers to matrix indices\nsubnetwork_axes::Dict{Int, Ax}:       Mapping from reference bus numbers to their corresponding subnetwork axes\ntol::Base.RefValue{Float64}:       Tolerance threshold used for matrix sparsification (elements below this value are dropped)\nnetwork_reduction_data::NetworkReductionData:       Container for network reduction information applied during matrix construction\n\nMathematical Properties\n\nMatrix Form: PTDF[i,j] = ∂fi/∂Pj where fi is flow on line i, Pj is injection at bus j\nDimensions: (nbuses × narcs) for all buses and impedance arcs\nLinear Superposition: Total flow = Σ(PTDF[i,j] × Pj) for all injections Pj\nPhysical Meaning: Values represent the fraction of bus injection that flows through each line\nReference Bus: Rows corresponding to reference buses are typically zero\n\nApplications\n\nPower Flow Analysis: Rapid calculation of line flows for given injection patterns\nSensitivity Studies: Evaluate impact of generation/load changes on transmission flows\nCongestion Management: Identify lines affected by specific injection changes\nMarket Analysis: Support nodal pricing and transmission rights calculations\nPlanning Studies: Assess transmission utilization under various scenarios\n\nComputational Features\n\nMatrix Storage: Stored in transposed form (bus × branch) for efficient computation\nSparsification: Small elements removed based on tolerance to reduce memory usage\nReference Bus Handling: Reference bus injections automatically handled in calculations\nDistributed Slack: Supports distributed slack bus configurations for improved realism\n\nUsage Notes\n\nAccess via ptdf[bus, line] returns the sensitivity coefficient\nMatrix indexing uses bus numbers and branch identifiers\nSparsification improves memory efficiency but may introduce small numerical errors\nResults valid under DC power flow assumptions (neglects voltage magnitudes and reactive power)\nReference bus choice affects the specific values but not the relative sensitivities\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PowerNetworkMatrices.PTDF-Tuple{AbstractString}","page":"Public API Reference","title":"PowerNetworkMatrices.PTDF","text":"PTDF(filename)\n\n\nDeserialize a PTDF from an HDF5 file.\n\nArguments\n\nfilename::AbstractString: File containing a serialized PTDF.\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.PTDF-Tuple{IncidenceMatrix, BA_Matrix}","page":"Public API Reference","title":"PowerNetworkMatrices.PTDF","text":"PTDF(A, BA; dist_slack, linear_solver, tol)\n\n\nPTDF(A::IncidenceMatrix, BA::BA_Matrix; dist_slack::Dict{Int, Float64} = Dict{Int, Float64}(), linear_solver = \"KLU\", tol::Float64 = eps())\n\nConstruct a Power Transfer Distribution Factor (PTDF) matrix from existing incidence and BA matrices. This constructor is more efficient when the prerequisite matrices are already available and provides direct control over the underlying matrix computations.\n\nArguments\n\nA::IncidenceMatrix: The incidence matrix containing bus-branch connectivity information\nBA::BA_Matrix: The branch susceptance weighted incidence matrix (B × A)\n\nKeyword Arguments\n\ndist_slack::Dict{Int, Float64} = Dict{Int, Float64}():       Dictionary mapping bus numbers to distributed slack participation factors.       Empty dictionary uses single slack bus (reference bus from matrices)\nlinear_solver::String = \"KLU\":       Linear solver algorithm for matrix computations. Options: \"KLU\", \"Dense\", \"MKLPardiso\"\ntol::Float64 = eps():       Sparsification tolerance for dropping small matrix elements to reduce memory usage\n\nReturns\n\nPTDF: The constructed PTDF matrix structure with injection-to-flow sensitivity coefficients\n\nMathematical Computation\n\nThe PTDF matrix is computed using the relationship:\n\nPTDF = (A^T × B × A)^(-1) × A^T × B\n\nwhere:\n\nA is the incidence matrix representing bus-branch connectivity\nB is the diagonal susceptance matrix (embedded in BA matrix)\nThe computation involves solving the ABA linear system for efficiency\n\nDistributed Slack Handling\n\nSingle Slack: Uses reference bus identified from input matrices\nDistributed Slack: Applies participation factor corrections to final PTDF\nAutomatic Processing: Dictionary converted to vector form matching matrix dimensions\nValidation: Ensures distributed slack bus numbers exist in the network\nNormalization: Participation factors automatically normalized to maintain power balance\n\nNetwork Consistency Requirements\n\nReduction Compatibility: Both input matrices must have equivalent network reduction states\nReference Alignment: BA matrix reference buses determine the PTDF reference framework\nTopology Consistency: Matrices must represent the same network topology\n\nPerformance Considerations\n\nMatrix Reuse: More efficient when A and BA matrices are already computed\nMemory Management: Sparsification reduces storage requirements significantly\nSolver Selection: KLU recommended for sparse systems, Dense for small networks\nComputational Efficiency: Avoids redundant system matrix construction\n\nError Handling and Validation\n\nMatrix Compatibility: Validates that A and BA have consistent network reductions\nSlack Validation: Checks that distributed slack buses exist in the matrix structure\nSolver Validation: Ensures selected linear solver is supported and available\nNumerical Stability: Handles singular systems and provides informative error messages\n\nUsage Recommendations\n\nPreferred Method: Use when incidence and BA matrices are already available\nRepeated Calculations: Ideal for multiple PTDF computations with different slack configurations\nLarge Systems: Consider sparsification for memory efficiency\nDistributed Slack: Provides more realistic modeling of generator response to load changes\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.PTDF-Tuple{PowerSystems.System}","page":"Public API Reference","title":"PowerNetworkMatrices.PTDF","text":"PTDF(sys; dist_slack, linear_solver, tol, kwargs...)\n\n\nPTDF(sys::PSY.System; dist_slack::Dict{Int, Float64} = Dict{Int, Float64}(), linear_solver = \"KLU\", tol::Float64 = eps(), network_reductions::Vector{NetworkReduction} = NetworkReduction[], kwargs...)\n\nConstruct a Power Transfer Distribution Factor (PTDF) matrix from a PowerSystems.System by computing the sensitivity of transmission line flows to bus power injections. This is the primary constructor for PTDF analysis starting from system data.\n\nArguments\n\nsys::PSY.System: The power system from which to construct the PTDF matrix\n\nKeyword Arguments\n\ndist_slack::Dict{Int, Float64} = Dict{Int, Float64}():       Dictionary mapping bus numbers to distributed slack weights for realistic slack modeling.       Empty dictionary uses single slack bus (default behavior)\nlinear_solver::String = \"KLU\":       Linear solver algorithm for matrix computations. Options: \"KLU\", \"Dense\", \"MKLPardiso\"\ntol::Float64 = eps():       Sparsification tolerance for dropping small matrix elements to reduce memory usage\nnetwork_reductions::Vector{NetworkReduction} = NetworkReduction[]:       Vector of network reduction algorithms to apply before matrix construction\ninclude_constant_impedance_loads::Bool=true:       Whether to include constant impedance loads as shunt admittances in the network model\nsubnetwork_algorithm=iterative_union_find:       Algorithm used for identifying electrical islands and connected components\nAdditional keyword arguments are passed to the underlying matrix constructors\n\nReturns\n\nPTDF: The constructed PTDF matrix structure containing:\nBus-to-impedance-arc injection sensitivity coefficients\nNetwork topology information and reference bus identification\nSparsification tolerance and computational metadata\n\nConstruction Process\n\nYbus Construction: Creates system admittance matrix with specified reductions\nIncidence Matrix: Builds bus-branch connectivity matrix A\nBA Matrix: Computes branch susceptance weighted incidence matrix\nPTDF Computation: Calculates power transfer distribution factors using A^T × B^(-1) × A\nDistributed Slack: Applies distributed slack correction if specified\nSparsification: Removes small elements based on tolerance threshold\n\nDistributed Slack Configuration\n\nSingle Slack: Empty dist_slack dictionary uses conventional single slack bus\nDistributed Slack: Dictionary maps bus numbers to participation factors\nNormalization: Participation factors automatically normalized to sum to 1.0\nPhysical Meaning: Distributed slack better represents generator response to load changes\n\nLinear Solver Options\n\n\"KLU\": Sparse LU factorization (default, recommended for most cases)\n\"Dense\": Dense matrix operations (faster for small systems, higher memory usage)\n\"MKLPardiso\": Intel MKL Pardiso solver (requires MKL library, best for very large systems)\n\nMathematical Foundation\n\nThe PTDF matrix is computed as:\n\nPTDF = A^T × (A^T × B × A)^(-1) × A^T × B\n\nwhere A is the incidence matrix and B is the susceptance matrix.\n\nNotes\n\nResults are valid under DC power flow assumptions (linear approximation)\nReference bus selection affects specific values but not relative sensitivities\nSparsification with tol > eps() can significantly reduce memory usage\nNetwork reductions improve computational efficiency for large systems\nDistributed slack provides more realistic representation of system response\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.RadialReduction","page":"Public API Reference","title":"PowerNetworkMatrices.RadialReduction","text":"RadialReduction <: NetworkReduction\n\nNetwork reduction algorithm that eliminates radial (dangling) buses and their associated branches from the power network. Radial buses are leaf nodes with only one connection that do not affect the electrical behavior of the rest of the network.\n\nFields\n\nirreducible_buses::Vector{Int}: List of bus numbers that should not be eliminated even if they are radial\n\nExamples\n\n# Create radial reduction with no protected buses\nreduction = RadialReduction()\n\n# Create radial reduction protecting specific buses\nreduction = RadialReduction(irreducible_buses=[101, 205])\n\n# Apply to system\nybus = Ybus(system; network_reductions=[reduction])\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PowerNetworkMatrices.VirtualLODF","page":"Public API Reference","title":"PowerNetworkMatrices.VirtualLODF","text":"The Virtual Line Outage Distribution Factor (VirtualLODF) structure gathers the rows of the LODF matrix as they are evaluated on-the-go. These rows are evaluated independently, cached in the structure and do not require the computation of the whole matrix (therefore significantly reducing the computational requirements).\n\nThe VirtualLODF is initialized with no row stored.\n\nThe VirtualLODF struct is indexed using branch names.\n\nArguments\n\nK::KLU.KLUFactorization{Float64, Int}:       LU factorization matrices of the ABA matrix, evaluated by means of KLU.\nBA::SparseArrays.SparseMatrixCSC{Float64, Int}:       BA matrix.\nA::SparseArrays.SparseMatrixCSC{Int8, Int}:       Incidence matrix.\ninv_PTDF_A_diag::Vector{Float64}:       Vector contiaining the element-wise reciprocal of the diagonal elements       coming from multuiplying the PTDF matrix with th Incidence matrix\nref_bus_positions::Set{Int}:       Vector containing the indexes of the rows of the transposed BA matrix       corresponding to the reference buses.\ndist_slack::Vector{Float64}:       Vector of weights to be used as distributed slack bus.       The distributed slack vector has to be the same length as the number of buses.\naxes<:NTuple{2, Dict}:       Tuple containing two vectors showing the branch names.\nlookup<:NTuple{2, Dict}:       Tuple containing two dictionaries, mapping the branches names       the enumerated row indexes indexes.\nvalid_ix::Vector{Int}:       Vector containing the row/columns indices of matrices related the buses       which are not slack ones.\ntemp_data::Vector{Float64}:       Temporary vector for internal use.\ncache::RowCache:       Cache were LODF rows are stored.\nsubnetworks::Dict{Int, Set{Int}}:       Dictionary containing the subsets of buses defining the different subnetwork of the system.\ntol::Base.RefValue{Float64}:       Tolerance related to scarification and values to drop.\nnetwork_reduction::NetworkReduction:       Structure containing the details of the network reduction applied when computing the matrix\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PowerNetworkMatrices.VirtualLODF-Tuple{PowerSystems.System}","page":"Public API Reference","title":"PowerNetworkMatrices.VirtualLODF","text":"VirtualLODF(\n    sys;\n    dist_slack,\n    tol,\n    max_cache_size,\n    persistent_arcs,\n    network_reductions,\n    kwargs...\n)\n\n\nBuilds the Virtual LODF matrix from a system. The return is a VirtualLODF struct with an empty cache.\n\nArguments\n\nsys::PSY.System:       PSY system for which the matrix is constructed\n\nKeyword Arguments\n\nnetwork_reduction::NetworkReduction:       Structure containing the details of the network reduction applied when computing the matrix\nkwargs...:       other keyword arguments used by VirtualPTDF\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.VirtualPTDF","page":"Public API Reference","title":"PowerNetworkMatrices.VirtualPTDF","text":"The Virtual Power Transfer Distribution Factor (VirtualPTDF) structure gathers the rows of the PTDF matrix as they are evaluated on-the-go. These rows are evaluated independently, cached in the structure and do not require the computation of the whole matrix (therefore significantly reducing the computational requirements).\n\nThe VirtualPTDF is initialized with no row stored.\n\nThe VirtualPTDF is indexed using branch names and bus numbers as for the PTDF matrix.\n\nArguments\n\nK::Union{KLU.KLUFactorization{Float64, Int}, AppleAccelerate.AAFactorization{Float64}}:       LU factorization matrices of the ABA matrix, evaluated by means of KLU or AppleAccelerate\nBA::SparseArrays.SparseMatrixCSC{Float64, Int}:       BA matrix\nref_bus_positions::Set{Int}:       Vector containing the indexes of the columns of the BA matrix corresponding       to the reference buses\ndist_slack::Vector{Float64}:       Vector of weights to be used as distributed slack bus.       The distributed slack vector has to be the same length as the number of buses.\naxes<:NTuple{2, Dict}:       Tuple containing two vectors: the first one showing the branches names,       the second showing the buses numbers. There is no link between the       order of the vector of the branches names and the way the PTDF rows are       stored in the cache.\nlookup<:NTuple{2, Dict}:       Tuple containing two dictionaries, mapping the branches       and buses with their enumerated indexes. The branch indexes refer to       the key of the cache dictionary. The bus indexes refer to the position       of the elements in the PTDF row stored.\ntemp_data::Vector{Float64}:       Temporary vector for internal use.\nvalid_ix::Vector{Int}:       Vector containing the row/columns indices of matrices related the buses       which are not slack ones.\ncache::RowCache:       Cache were PTDF rows are stored.\nsubnetworks::Dict{Int, Set{Int}}:       Dictionary containing the subsets of buses defining the different subnetwork of the system.\ntol::Base.RefValue{Float64}:       Tolerance related to scarification and values to drop.\nnetwork_reduction::NetworkReduction:       Structure containing the details of the network reduction applied when computing the matrix\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PowerNetworkMatrices.VirtualPTDF-Tuple{PowerSystems.System}","page":"Public API Reference","title":"PowerNetworkMatrices.VirtualPTDF","text":"VirtualPTDF(\n    sys;\n    dist_slack,\n    linear_solver,\n    tol,\n    max_cache_size,\n    persistent_arcs,\n    network_reductions,\n    kwargs...\n)\n\n\nBuilds the Virtual PTDF matrix from a system. The return is a VirtualPTDF struct with an empty cache.\n\nArguments\n\nsys::PSY.System:       PSY system for which the matrix is constructed\n\nKeyword Arguments\n\ndist_slack::Vector{Float64} = Float64[]:       Vector of weights to be used as distributed slack bus.       The distributed slack vector has to be the same length as the number of buses.\nlinear_solver::String = \"KLU\":       Linear solver to use for factorization. Options: \"KLU\", \"AppleAccelerate\"\ntol::Float64 = eps():       Tolerance related to sparsification and values to drop.\nmax_cache_size::Int:       max cache size in MiB (initialized as MAXCACHESIZE_MiB).\npersistent_lines::Vector{String}:       line to be evaluated as soon as the VirtualPTDF is created (initialized as empty vector of strings).\nnetwork_reduction::NetworkReduction:       Structure containing the details of the network reduction applied when computing the matrix\nkwargs...:       other keyword arguments used by VirtualPTDF\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.Ybus","page":"Public API Reference","title":"PowerNetworkMatrices.Ybus","text":"Ybus{Ax, L <: NTuple{2, Dict}} <: PowerNetworkMatrix{ComplexF32}\n\nNodal admittance matrix (Y-bus) representing the electrical admittance relationships between buses in a power system. This N×N sparse complex matrix encodes the network topology and electrical parameters needed for power flow calculations and network analysis.\n\nFields\n\ndata::SparseArrays.SparseMatrixCSC{ComplexF32, Int}: Sparse Y-bus matrix with complex admittance values\nadjacency_data::SparseArrays.SparseMatrixCSC{Int8, Int}: Network connectivity information\naxes::Ax: Tuple of bus axis vectors for indexing (busnumbers, busnumbers)\nlookup::L: Tuple of lookup dictionaries mapping bus numbers to matrix indices\nsubnetwork_axes::Dict{Int, Ax}: Bus axes for each electrical island/subnetwork\narc_subnetwork_axis::Dict{Int, Vector{Tuple{Int, Int}}}: Arc axes for each subnetwork\nnetwork_reduction_data::NetworkReductionData: Metadata from network reduction operations\narc_admittance_from_to::Union{ArcAdmittanceMatrix, Nothing}: From-to arc admittance matrix\narc_admittance_to_from::Union{ArcAdmittanceMatrix, Nothing}: To-from arc admittance matrix\n\nKey Features\n\nIndexed by bus numbers (non-sequential numbering supported)\nSupports network reductions (radial, degree-two, Ward)\nHandles multiple electrical islands/subnetworks\nOptional arc admittance matrices for power flow calculations\nSparse matrix representation for computational efficiency\n\nUsage\n\nThe Y-bus is fundamental for:\n\nPower flow analysis: V = Y⁻¹I\nShort circuit calculations\nNetwork impedance analysis\nSensitivity analysis (PTDF/LODF)\n\nExamples\n\n# Basic Y-bus construction\nybus = Ybus(system)\n\n# With arc admittance matrices for power flow\nybus = Ybus(system; make_arc_admittance_matrices=true)\n\n# With network reductions\nybus = Ybus(system; network_reductions=[RadialReduction(), DegreeTwoReduction()])\n\nSee Also\n\nPTDF: Power Transfer Distribution Factors\nLODF: Line Outage Distribution Factors\nNetworkReduction: Network reduction algorithms\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PowerNetworkMatrices.Ybus-Tuple{PowerSystems.System}","page":"Public API Reference","title":"PowerNetworkMatrices.Ybus","text":"Ybus(\n    sys;\n    make_arc_admittance_matrices,\n    network_reductions,\n    include_constant_impedance_loads,\n    subnetwork_algorithm\n)\n\n\nYbus(\n    sys::PSY.System;\n    make_arc_admittance_matrices::Bool = false,\n    network_reductions::Vector{NetworkReduction} = NetworkReduction[],\n    include_constant_impedance_loads::Bool = true,\n    subnetwork_algorithm = iterative_union_find,\n    kwargs...\n) -> Ybus\n\nConstruct a nodal admittance matrix (Y-bus) from a power system.\n\nBuilds the sparse complex Y-bus matrix representing the electrical admittance relationships between buses in the power system. Handles AC branches, transformers, shunt elements, and network reductions while maintaining connectivity analysis.\n\nArguments\n\nsys::PSY.System: Power system to build Y-bus from\n\nKeyword arguments\n\nmake_arc_admittance_matrices::Bool=false: Whether to construct arc admittance matrices for power flow\nnetwork_reductions::Vector{NetworkReduction}=[]: Network reduction algorithms to apply\ninclude_constant_impedance_loads::Bool=true: Whether to include constant impedance loads as shunt admittances\nsubnetwork_algorithm=iterative_union_find: Algorithm for finding electrical islands\n\nReturns\n\nYbus: Constructed Y-bus matrix with network topology and electrical parameters\n\nFeatures\n\nBranch Support: Lines, transformers, phase shifters, three-winding transformers\nShunt Elements: Fixed admittances, switched admittances, constant impedance loads\nNetwork Reductions: Radial, degree-two, Ward reductions for computational efficiency\nMultiple Islands: Handles disconnected network components with separate reference buses\nBranch Matrices: Optional from-to/to-from admittance matrices for power flow calculations\n\nExamples\n\n# Basic Y-bus construction\nybus = Ybus(system)\n\n# With arc admittance matrices for power flow\nybus = Ybus(system; make_arc_admittance_matrices=true)\n\n# Apply network reductions for computational efficiency\nreductions = [RadialReduction(), DegreeTwoReduction()]\nybus = Ybus(system; network_reductions=reductions)\n\n# Exclude constant impedance loads\nybus = Ybus(system; include_constant_impedance_loads=false)\n\nSee Also\n\nNetworkReduction: Network reduction algorithms\nPTDF: Power transfer distribution factors\nLODF: Line outage distribution factors\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.depth_first_search-Tuple{SparseArrays.SparseMatrixCSC, Vector{Int64}}","page":"Public API Reference","title":"PowerNetworkMatrices.depth_first_search","text":"depth_first_search(M, bus_numbers)\n\n\ndepth_first_search(M::SparseArrays.SparseMatrixCSC, bus_numbers::Vector{Int})\n\nFind connected subnetworks using depth-first search algorithm.\n\nArguments\n\nM::SparseArrays.SparseMatrixCSC: Sparse matrix representing network connectivity\nbus_numbers::Vector{Int}: Vector containing the bus numbers of the system\n\nReturns\n\nDict{Int, Set{Int}}: Dictionary mapping representative bus numbers to sets of connected buses\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.factorize-Union{Tuple{ABA_Matrix{Ax, L, Nothing}}, Tuple{L}, Tuple{Ax}} where {Ax, L<:Tuple{Dict, Dict}}","page":"Public API Reference","title":"PowerNetworkMatrices.factorize","text":"factorize(ABA)\n\n\nEvaluates the LU factorization matrices of the ABA matrix, using KLU.\n\nArguments\n\nABA::ABA_Matrix{Ax, L, Nothing} where {Ax, L <: NTuple{2, Dict}}:       container for the ABA matrix, with ABA.K == nothing (LU matrices in K not evaluated)\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.find_subnetworks-Tuple{AdjacencyMatrix}","page":"Public API Reference","title":"PowerNetworkMatrices.find_subnetworks","text":"find_subnetworks(M)\n\n\nEvaluates subnetworks by looking for the subsets of buses connected each other, but not connected with buses of other subsets.\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.find_subnetworks-Tuple{PowerSystems.System}","page":"Public API Reference","title":"PowerNetworkMatrices.find_subnetworks","text":"find_subnetworks(sys)\n\n\nFinds the subnetworks in a system using Depth First Search (DFS). Returns a dictionary keyed by the reference bus of the subnetworks if they exist\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.find_subnetworks-Tuple{SparseArrays.SparseMatrixCSC, Vector{Int64}}","page":"Public API Reference","title":"PowerNetworkMatrices.find_subnetworks","text":"find_subnetworks(M, bus_numbers; subnetwork_algorithm)\n\n\nFinds the subnetworks present in the considered System. This is evaluated by taking a the ABA or Adjacency Matrix.\n\nArguments\n\nM::SparseArrays.SparseMatrixCSC:       input sparse matrix.\nbus_numbers::Vector{Int}:       vector containing the indices of the system's buses.\nsubnetwork_algorithm::Function:       algorithm for computing subnetworks. Valid options are iterativeunionfind (default) and depthfirstsearch\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.find_subnetworks-Tuple{Ybus}","page":"Public API Reference","title":"PowerNetworkMatrices.find_subnetworks","text":"find_subnetworks(M)\n\n\nfind_subnetworks(M::Ybus) -> Dict{Int, Set{Int}}\n\nIdentify electrical islands (subnetworks) in the Y-bus matrix.\n\nAnalyzes the network topology to find groups of buses that are electrically connected to each other but isolated from other groups. Each subnetwork represents an electrical island that requires its own reference bus and can be solved independently.\n\nArguments\n\nM::Ybus: Y-bus matrix to analyze\n\nReturns\n\nDict{Int, Set{Int}}: Dictionary mapping reference bus numbers to sets of bus numbers in each subnetwork\n\nExamples\n\nybus = Ybus(system)\nsubnetworks = find_subnetworks(ybus)\nfor (ref_bus, buses) in subnetworks\n    println(\"Island \", ref_bus, \": \", sort(collect(buses)))\nend\n\nif length(subnetworks) > 1\n    @warn \"Network has \", length(subnetworks), \" electrical islands\"\nend\n\nImplementation Details\n\nUses adjacency matrix analysis to find connected components\nEach subnetwork gets assigned a reference bus for voltage angle reference\nIsolated buses or groups require separate power flow analysis\nCritical for power flow initialization and solution\n\nSee Also\n\nvalidate_connectivity: Check for full connectivity\ndepth_first_search: Graph traversal algorithm\niterative_union_find: Alternative connectivity algorithm\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.from_hdf5-Tuple{Type{PTDF}, AbstractString}","page":"Public API Reference","title":"PowerNetworkMatrices.from_hdf5","text":"from_hdf5(_, filename)\n\n\nDeserialize a PTDF from an HDF5 file.\n\nArguments\n\n::Type{PTDF}:\nfilename::AbstractString: File containing a serialized PTDF.\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.get_bus_reduction_map-Tuple{NetworkReductionData}","page":"Public API Reference","title":"PowerNetworkMatrices.get_bus_reduction_map","text":"get_bus_reduction_map(rb)\n\n\nget_bus_reduction_map(rb::NetworkReductionData)\n\nGet the bus reduction map from NetworkReductionData.\n\nArguments\n\nrb::NetworkReductionData: The network reduction data\n\nReturns\n\nDict{Int, Set{Int}}: Dictionary mapping retained buses to sets of removed buses\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.get_lodf_data-Tuple{LODF}","page":"Public API Reference","title":"PowerNetworkMatrices.get_lodf_data","text":"get_lodf_data(lodf)\n\n\nget_lodf_data(lodf::LODF)\n\nExtract the LODF matrix data in the standard orientation (non-transposed).\n\nArguments\n\nlodf::LODF: The LODF structure from which to extract data\n\nReturns\n\nAbstractArray{Float64, 2}: The LODF matrix data with standard orientation\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.get_ptdf_data-Tuple{PTDF}","page":"Public API Reference","title":"PowerNetworkMatrices.get_ptdf_data","text":"get_ptdf_data(ptdf)\n\n\nget_ptdf_data(ptdf::PTDF)\n\nExtract the PTDF matrix data in the standard orientation (non-transposed).\n\nArguments\n\nptdf::PTDF: The PTDF structure from which to extract data\n\nReturns\n\nAbstractArray{Float64, 2}: The PTDF matrix data with standard orientation\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.get_reductions-Tuple{NetworkReductionData}","page":"Public API Reference","title":"PowerNetworkMatrices.get_reductions","text":"get_reductions(rb)\n\n\nget_reductions(rb::NetworkReductionData)\n\nGet the reduction container from NetworkReductionData.\n\nArguments\n\nrb::NetworkReductionData: The network reduction data\n\nReturns\n\nReductionContainer: Container with the applied network reductions\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.get_ward_reduction-Tuple{SparseArrays.SparseMatrixCSC{ComplexF32, Int64}, Dict{Int64, Int64}, Vector{Int64}, Set{Int64}, Set{Int64}, Vector{Int64}}","page":"Public API Reference","title":"PowerNetworkMatrices.get_ward_reduction","text":"get_ward_reduction(\n    data,\n    bus_lookup,\n    bus_axis,\n    boundary_buses,\n    ref_bus_numbers,\n    study_buses\n)\n\n\nget_ward_reduction(data, bus_lookup, bus_axis, boundary_buses, ref_bus_numbers, study_buses)\n\nPerform Ward reduction to create an equivalent network representation.\n\nWard reduction is a network reduction technique that eliminates external buses while preserving  the electrical characteristics seen from the study buses. External buses are mapped to boundary  buses based on impedance criteria, and equivalent admittances are computed.\n\nArguments\n\ndata::SparseArrays.SparseMatrixCSC{ComplexF32, Int}: Admittance matrix of the system\nbus_lookup::Dict{Int, Int}: Dictionary mapping bus numbers to matrix indices\nbus_axis::Vector{Int}: Vector of all bus numbers in the system\nboundary_buses::Set{Int}: Set of boundary bus numbers between study and external areas\nref_bus_numbers::Set{Int}: Set of reference bus numbers\nstudy_buses::Vector{Int}: Vector of study bus numbers to retain\n\nReturns\n\nTuple: Contains bus reduction map, reverse bus search map, added branch map, and added admittance map\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.is_factorized-Union{Tuple{ABA_Matrix{Ax, L, Nothing}}, Tuple{L}, Tuple{Ax}} where {Ax, L<:Tuple{Dict, Dict}}","page":"Public API Reference","title":"PowerNetworkMatrices.is_factorized","text":"is_factorized(ABA)\n\n\nis_factorized(ABA::ABA_Matrix)\n\nCheck if an ABA_Matrix has been factorized (i.e., contains LU factorization matrices).\n\nArguments\n\nABA::ABA_Matrix: The ABA matrix to check\n\nReturns\n\nBool: true if the matrix has been factorized, false otherwise\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.iterative_union_find-Tuple{SparseArrays.SparseMatrixCSC, Vector{Int64}}","page":"Public API Reference","title":"PowerNetworkMatrices.iterative_union_find","text":"iterative_union_find(M, bus_numbers)\n\n\niterative_union_find(M::SparseArrays.SparseMatrixCSC, bus_numbers::Vector{Int})\n\nFind connected subnetworks using iterative union-find algorithm.\n\nArguments\n\nM::SparseArrays.SparseMatrixCSC: Sparse matrix representing network connectivity\nbus_numbers::Vector{Int}: Vector containing the bus numbers of the system\n\nReturns\n\nDict{Int, Set{Int}}: Dictionary mapping representative bus numbers to sets of connected buses\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.to_hdf5-Tuple{PTDF, AbstractString}","page":"Public API Reference","title":"PowerNetworkMatrices.to_hdf5","text":"to_hdf5(ptdf, filename; compress, compression_level, force)\n\n\nSerialize the PTDF to an HDF5 file.\n\nArguments\n\nptdf::PTDF: matrix\nfilename::AbstractString: File to create\ncompress::Bool: Whether to enabled compression, defaults to true.\ncompression_level::Int: Compression level to use if compression is enabled.\nforce::Bool: Whether to overwrite the file if it already exists, defaults to false.\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.validate_connectivity-Tuple{AdjacencyMatrix}","page":"Public API Reference","title":"PowerNetworkMatrices.validate_connectivity","text":"validate_connectivity(M)\n\n\nValidates connectivity by checking that the number of subnetworks is 1 (fully connected network).\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.validate_connectivity-Tuple{PowerSystems.System}","page":"Public API Reference","title":"PowerNetworkMatrices.validate_connectivity","text":"validate_connectivity(sys)\n\n\nChecks the network connectivity of the system using Depth First Search (DFS)\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerNetworkMatrices.validate_connectivity-Tuple{Ybus}","page":"Public API Reference","title":"PowerNetworkMatrices.validate_connectivity","text":"validate_connectivity(M)\n\n\nvalidate_connectivity(M::Ybus) -> Bool\n\nValidate that the Y-bus represents a fully connected electrical network.\n\nChecks network connectivity by counting the number of electrical islands (subnetworks) in the Y-bus matrix. A fully connected network should have exactly one subnetwork. Multiple subnetworks indicate electrical isolation between parts of the system.\n\nArguments\n\nM::Ybus: Y-bus matrix to validate\n\nReturns\n\nBool: true if network is fully connected (single subnetwork), false otherwise\n\nExamples\n\nybus = Ybus(system)\nif validate_connectivity(ybus)\n    println(\"Network is fully connected\")\nelse\n    println(\"Network has isolated islands\")\n    islands = find_subnetworks(ybus)\n    println(\"Number of islands: \", length(islands))\nend\n\nImplementation Details\n\nUses find_subnetworks() to identify electrical islands\nSingle subnetwork indicates full electrical connectivity\nMultiple subnetworks may require separate power flow solutions\n\nSee Also\n\nfind_subnetworks: Identify electrical islands\nvalidate_connectivity: System-level connectivity validation\n\n\n\n\n\n","category":"method"},{"location":"tutorials/tutorial_VirtualLODF_matrix/#VirtualLODF","page":"VirtualLODF matrix","title":"VirtualLODF","text":"The VirtualLODF structure follows the same philosofy as the VirtualPTDF: it contains rows of the original LODF matrix, evaluated and cached on demand.\n\nRefer to the different arguments of the VirtualLODF methods by looking at the \"Public API Reference\" page.","category":"section"},{"location":"tutorials/tutorial_VirtualLODF_matrix/#How-the-VirtualLODF-works","page":"VirtualLODF matrix","title":"How the VirtualLODF works","text":"The VirtualLODF structure retains many of the similarities of the VirtualPTDF. However, its computation is more complex and requires some additional data.\n\nStarting from the system data, the IncidenceMatrix, BA_Matrix and ABA_Matrix (with relative LU factorization matrices) are evaluated. The ABA_Matrix and BA_Matrix are used for the computation of the diagonal elements of the PTDF matrix, and this vector is stored in the VirtualLODF structure together with the other structures mentioned above.\n\nOnce the VirtualLODF is initialized, each row of the matrix can be evaluated separately and on user request. The algorithmic procedure is the following:\n\nDefine the VirtualPTDF structure\nCall any element of the matrix to define and store the relative row as well as showing the selected element\n\nRegarding point 2, if the row has been stored previously then the desired element is just loaded from the cache and shown.\n\nThe flowchart below shows how the VirtualLODF is structured and how it works. Examples will be presented in the following sections.\n\n<img src=\"../../assets/VirtualLODF_scheme.png\"/>","category":"section"},{"location":"tutorials/tutorial_VirtualLODF_matrix/#Initialize-VirtualLODF-and-compute/access-row/element","page":"VirtualLODF matrix","title":"Initialize VirtualLODF and compute/access row/element","text":"As for the LODF matrix, at first the System data must be loaded. The \"RTS-GMLC\" systems is considered as example:\n\nusing PowerNetworkMatrices\nusing PowerSystemCaseBuilder\n\nconst PNM = PowerNetworkMatrices;\nconst PSB = PowerSystemCaseBuilder;\n\nsys = PSB.build_system(PSB.PSISystems, \"RTS_GMLC_DA_sys\");\n\nAt this point the VirtualLODF is initialized with the following simple command:\n\nv_lodf = VirtualLODF(sys);\n\nNow, an element of the matrix can be computed by using the arc tuples as indices:\n\nel_v_lodf = v_lodf[(221, 222), (202, 206)]\n\nThis element represent the portion flowing on arc (202, 206) now diverted on arc (221, 222) as a consequence of its outage.\n\nAlternatively, the value can be indexted by row and column numbers directly. In this case the row and column numbers are mapped by the dictonaries contained in the lookup field. \n\nrow_number = v_lodf.lookup[1][ (202, 206)]\ncol_number = v_lodf.lookup[2][(221, 222)]\nel_C31_2_105_bis = v_lodf[row_number, col_number]\n\nNOTE: this example was made for the sake of completeness and considering the actual arc tuples is recommended.\n\nAs previously mentioned, in order to evaluate a single element of the VirtualLODF, the entire row related to the selected branch must be considered. For this reason it is cached for later calls. This is evident by looking at the following example:\n\nsys_2k = PSB.build_system(PSB.PSYTestSystems, \"tamu_ACTIVSg2000_sys\");\n\nv_lodf_2k = VirtualLODF(sys_2k);\n\n# evaluate PTDF row related to arc (5270, 5474)\n@time v_lodf_2k[(5270, 5474), (2118, 2113)]\n\n\n# call same element after the row has been stored\n@time v_lodf_2k[(5270, 5474), (2118, 2113)]","category":"section"},{"location":"tutorials/tutorial_VirtualLODF_matrix/#\"Sparse\"-VirtualPTDF","page":"VirtualLODF matrix","title":"\"Sparse\" VirtualPTDF","text":"Sparsification of each row can be achieved in the same fashion as for the LODF matrix, by removing those elements whose absolute values is below a certain threshold.\n\nAs for the example show for the LODF matrix, here to a very high values of 0.4 is considered for the tol field. Again, this value is considered just for the sake of this example.\n\n# smaller system for the next examples\nsys_2 = PSB.build_system(PSB.PSITestSystems, \"c_sys5\");\n\nv_lodf_dense = VirtualLODF(sys_2);\nv_lodf_sparse = VirtualLODF(sys_2, tol=0.4);\n\nLet's now evaluate the same row as before and compare the results:\n\noriginal_row = [v_lodf_dense[\"1\", j] for j in v_lodf_dense.axes[2]]\nsparse_row = [v_lodf_sparse[\"1\", j] for j in v_lodf_sparse.axes[2]]","category":"section"},{"location":"tutorials/tutorial_DegreeTwoReduction/#DegreeTwoReduction","page":"DegreeTwoReduction","title":"DegreeTwoReduction","text":"In this tutorial the DegreeTwoReduction network reduction algorithm is presented. This reduction eliminates buses with exactly two connections by combining the incident branches into a single equivalent branch while preserving the electrical characteristics of the network.\n\nBefore diving into this tutorial we encourage the user to load PowerNetworkMatrices, hit the ? key in the REPL terminal and look for the documentation of DegreeTwoReduction.","category":"section"},{"location":"tutorials/tutorial_DegreeTwoReduction/#Understanding-Degree-Two-Buses","page":"DegreeTwoReduction","title":"Understanding Degree-Two Buses","text":"Degree-two buses are nodes in the network topology that have exactly two connections. These intermediate buses can be eliminated by replacing the two incident branches with a single equivalent branch, simplifying the network while maintaining its electrical behavior. The reduction is performed recursively, identifying and eliminating chains of degree-two nodes to maximize network simplification.","category":"section"},{"location":"tutorials/tutorial_DegreeTwoReduction/#Basic-Usage-of-DegreeTwoReduction","page":"DegreeTwoReduction","title":"Basic Usage of DegreeTwoReduction","text":"The DegreeTwoReduction can be applied when constructing various network matrices. The most common use case is with the Ybus matrix:\n\nusing PowerNetworkMatrices\nusing PowerSystemCaseBuilder\n\nconst PNM = PowerNetworkMatrices\nconst PSB = PowerSystemCaseBuilder\n\n# Load a test system\nsys = PSB.build_system(PSB.PSITestSystems, \"c_sys14\");\n\n# Create Ybus with degree-two reduction\nybus = Ybus(sys; network_reductions=[DegreeTwoReduction()]);","category":"section"},{"location":"tutorials/tutorial_DegreeTwoReduction/#Accessing-Reduction-Information","page":"DegreeTwoReduction","title":"Accessing Reduction Information","text":"After applying the reduction, you can access information about which buses were eliminated and how branches were combined:\n\n# Get the network reduction data\nreduction_data = get_network_reduction_data(ybus);\n\n# View the series branch mapping\n# This shows how multiple branches were combined into composite branches\nget_series_branch_map(reduction_data)\n\n# View the removed buses\nget_removed_buses(reduction_data)\n\n# View the removed arcs (branches that were combined)\nget_removed_arcs(reduction_data)","category":"section"},{"location":"tutorials/tutorial_DegreeTwoReduction/#Configuration-Options","page":"DegreeTwoReduction","title":"Configuration Options","text":"The DegreeTwoReduction provides several configuration options:","category":"section"},{"location":"tutorials/tutorial_DegreeTwoReduction/#Protecting-Specific-Buses","page":"DegreeTwoReduction","title":"Protecting Specific Buses","text":"You can protect certain buses from reduction even if they have degree two:\n\n# Create degree-two reduction that protects specific buses\nreduction = DegreeTwoReduction(irreducible_buses=[101, 205]);\n\n# Apply to system (if these buses exist in the system)\n# ybus_protected = Ybus(sys; network_reductions=[reduction]);","category":"section"},{"location":"tutorials/tutorial_DegreeTwoReduction/#Handling-Reactive-Power-Injectors","page":"DegreeTwoReduction","title":"Handling Reactive Power Injectors","text":"By default, DegreeTwoReduction reduces buses with reactive power injections. You can change this behavior:\n\n# Create reduction that preserves buses with reactive power injections\nreduction = DegreeTwoReduction(reduce_reactive_power_injectors=false);\n\n# Apply to system\nybus_preserve_reactive = Ybus(sys; network_reductions=[reduction]);","category":"section"},{"location":"tutorials/tutorial_DegreeTwoReduction/#Combining-with-Other-Network-Matrices","page":"DegreeTwoReduction","title":"Combining with Other Network Matrices","text":"The DegreeTwoReduction can be applied to other network matrix types as well:\n\n# Apply to PTDF matrix\nptdf = PTDF(sys; network_reductions=[DegreeTwoReduction()]);\n\n# Apply to LODF matrix\nlodf = LODF(sys; network_reductions=[DegreeTwoReduction()]);\n\n# Apply to BA Matrix\nba_matrix = BA_Matrix(sys; network_reductions=[DegreeTwoReduction()]);\n\n# Apply to ABA Matrix\naba_matrix = ABA_Matrix(sys; network_reductions=[DegreeTwoReduction()]);","category":"section"},{"location":"tutorials/tutorial_DegreeTwoReduction/#Benefits-of-Degree-Two-Reduction","page":"DegreeTwoReduction","title":"Benefits of Degree-Two Reduction","text":"Using DegreeTwoReduction provides several advantages:\n\nSmaller Matrices: Eliminates intermediate buses from network matrices\nFaster Computations: Reduced matrix dimensions lead to faster operations\nSimplified Topology: Creates a more direct representation of the network\nPreserved Accuracy: Maintains exact electrical equivalence for the reduced network","category":"section"},{"location":"tutorials/tutorial_DegreeTwoReduction/#Example:-Comparing-Matrix-Sizes","page":"DegreeTwoReduction","title":"Example: Comparing Matrix Sizes","text":"# Create Ybus without reduction\nybus_full = Ybus(sys);\n\n# Create Ybus with degree-two reduction\nybus_reduced = Ybus(sys; network_reductions=[DegreeTwoReduction()]);\n\n# Compare sizes\nsize(ybus_full)\nsize(ybus_reduced)","category":"section"},{"location":"tutorials/tutorial_DegreeTwoReduction/#Understanding-Series-Branch-Chains","page":"DegreeTwoReduction","title":"Understanding Series Branch Chains","text":"When degree-two buses are eliminated, the reduction algorithm identifies chains of series-connected branches. For example:\n\nBus A --- Branch 1 --- Bus B --- Branch 2 --- Bus C\n\nIf Bus B has degree two, it can be eliminated, and Branches 1 and 2 are combined into a single equivalent branch:\n\nBus A --- Equivalent Branch --- Bus C\n\nThe equivalent branch's electrical parameters (impedance, admittance) are calculated to preserve the overall electrical behavior.","category":"section"},{"location":"tutorials/tutorial_DegreeTwoReduction/#Combining-Multiple-Reductions","page":"DegreeTwoReduction","title":"Combining Multiple Reductions","text":"DegreeTwoReduction can be combined with other network reduction algorithms like RadialReduction:\n\n# Apply both radial and degree-two reductions\nreductions = [RadialReduction(), DegreeTwoReduction()];\nybus_multi = Ybus(sys; network_reductions=reductions);\n\n# Get combined reduction data\nmulti_reduction_data = get_network_reduction_data(ybus_multi);","category":"section"},{"location":"tutorials/tutorial_DegreeTwoReduction/#Order-of-Reductions","page":"DegreeTwoReduction","title":"Order of Reductions","text":"When combining multiple reductions, the order can affect the final result:\n\n# First apply radial, then degree-two\nreductions1 = [RadialReduction(), DegreeTwoReduction()];\nybus1 = Ybus(sys; network_reductions=reductions1);\n\n# First apply degree-two, then radial  \nreductions2 = [DegreeTwoReduction(), RadialReduction()];\nybus2 = Ybus(sys; network_reductions=reductions2);\n\n# Compare results\nsize(ybus1)\nsize(ybus2)\n\nIn general, applying RadialReduction first is recommended, as it can create new degree-two buses that can then be eliminated by DegreeTwoReduction.","category":"section"},{"location":"tutorials/tutorial_DegreeTwoReduction/#Important-Notes","page":"DegreeTwoReduction","title":"Important Notes","text":"Topology Preservation: The reduction maintains essential network connectivity\nReference Bus Protection: Reference (slack) buses are automatically protected from elimination\nParallel Paths: The algorithm handles parallel branches correctly\nThree-Winding Transformers: Special handling for three-winding transformer connections\nReversibility: The reduction maintains detailed mapping information for result interpretation\nElectrical Equivalence: Equivalent branches are computed to maintain exact electrical behavior","category":"section"},{"location":"tutorials/tutorial_Incidence_BA_ABA_matrices/#Incidence,-BA-and-ABA-matrices","page":"Incidence, BA and ABA matrices","title":"Incidence, BA and ABA matrices","text":"In this tutorial the IncidenceMatrix, BA_matrix and ABA_matrix are presented. The methods used for their evaluation, as well as how data is stored is shown in the following subsections.\n\nThe matrices here presented are the building blocks for the computation of the PTDF and LODF matrices.","category":"section"},{"location":"tutorials/tutorial_Incidence_BA_ABA_matrices/#IncidenceMatrix","page":"Incidence, BA and ABA matrices","title":"IncidenceMatrix","text":"The PowerNetworkMatrices package defines the structure IncidenceMatrix, which store the Incidence Matrix of the considered system as well as the most relevant network data.\n\nAt first, the System data is loaded.\n\nusing PowerNetworkMatrices\nusing PowerSystemCaseBuilder\n\nconst PNM = PowerNetworkMatrices\nconst PSB = PowerSystemCaseBuilder\n\nsys = PSB.build_system(PSB.PSITestSystems, \"c_sys5\");\n\nThen the Incidence Matrix is computed as follows:\n\nincidence_matrix = PNM.IncidenceMatrix(sys);\n\nThe incidence_matrix variable is a structure of type IncidenceMatrix featuring the following fields:\n\n# axis names: row and column names.\n# row names: tuples of the arcs (from bus number, to bus number)\n# column names: names of the buses\nincidence_matrix.axes\n\n# data: Incidence Matrix\nincidence_matrix.data\n\n# lookup: dictionary linking the arc tuples and bus numbers with the row\n# and column numbers, respectively.\nincidence_matrix.axes\n\n# ref_bus_positions: set containing the positions of the reference buses.\n# this represents the positions where to add the column of zeros. Please refer to the\n# example in the BA matrix for more details.\nincidence_matrix.ref_bus_positions\n\nPlease note that the matrix data can be easily access by using the following function:\n\nPNM.get_data(incidence_matrix)\n\nNote that the number of columns is lower than the actual number of system buses since the column related to the reference bus is discarded.","category":"section"},{"location":"tutorials/tutorial_Incidence_BA_ABA_matrices/#BA_Matrix","page":"Incidence, BA and ABA matrices","title":"BA_Matrix","text":"The BA_Matrix is a structure containing the matrix coming from the product of the IncidenceMatrix and the diagonal matrix containing the impedance of the system's branches (\"B\" matrix).\n\nThe BA_Matrix is computed as follows:\n\nba_matrix = PNM.BA_Matrix(sys);\n\nAs for the IncidenceMatrix, here too the BA_Matrix structure feature the same fields.\n\nAn example related to accessing the matrix data is now provided:\n\n# access data by explicitly calling the field \"data\"\nba_matrix.data\n\n# or by using the \"get_data\" function\nPNM.get_data(ba_matrix)\n\nNote that the number of columns is lower than the actual number of system buses since the column related to the reference bus is discarded.\n\nTo add the column of zeros related to the reference bus, it is necessary to use the information contained in the ref_bus_positions field.\n\nnew_ba_matrix = hcat(\n    ba_matrix.data[:,1:collect(ba_matrix.ref_bus_positions)[1]-1],\n    zeros(size(ba_matrix, 1), 1),\n    ba_matrix.data[:, collect(ba_matrix.ref_bus_positions)[1]:end]\n    )\n\nHowever, trying to change the data field with a matrix of different dimension will result in an error.\n\nba_matrix.data = hcat(\n    ba_matrix.data[:,1:collect(ba_matrix.ref_bus_positions)[1]-1],\n    zeros(size(ba_matrix, 1), 1),\n    ba_matrix.data[:, collect(ba_matrix.ref_bus_positions)[1]:end]\n    )","category":"section"},{"location":"tutorials/tutorial_Incidence_BA_ABA_matrices/#ABA_Matrix","page":"Incidence, BA and ABA matrices","title":"ABA_Matrix","text":"The ABA_Matrix is a structure containing the matrix coming from the product of the IncidenceMatrix and the BA_Matrix. It features the same fields as the IncidenceMatrix and the BA_Matrix, plus the K one. The field ABA_Matrix.K stores the LU factorization matrices (using the methods contained in the package KLU).\n\nTo evaluate the ABA_Matrix, the following command is sufficient:\n\naba_matrix = ABA_Matrix(sys);\n\nBy default the LU factorization matrices are not computed, leaving the K field empty. In case these are wanted, the keyword factorize must be true.\n\naba_matrix_with_LU = ABA_Matrix(sys; factorize=true);\n\naba_matrix_with_LU.K\n\nIf the ABA_Matrix is already computed but the LU factorization was not performed, this can be done by considering the following command:\n\naba_matrix.K\naba_matrix = factorize(aba_matrix);\naba_matrix.K\n\nThe following command can then be used to check if the ABA_Matrix contains the LU factorization matrices:\n\nis_factorized(aba_matrix)","category":"section"},{"location":"tutorials/tutorial_PTDF_matrix/#PTDF-matrix","page":"PTDF matrix","title":"PTDF matrix","text":"In this tutorial the methods for computing the Power Transfer Distribution Factors (PTDF) are presented. Before diving into this tutorial we encourage the user to load PowerNetworkMatrices, hit the ? key in the REPL terminal and look for the documention of the different PTDF methods available.","category":"section"},{"location":"tutorials/tutorial_PTDF_matrix/#Evaluation-of-the-PTDF-matrix","page":"PTDF matrix","title":"Evaluation of the PTDF matrix","text":"The PTDF matrix can be evaluated according to three different approaches:\n\nDense: considers functions for dense matrix multiplication and inversion\nKLU: considers functions for sparse matrix multiplication and inversion (default)\nMKLPardiso: uses Intel's MKL Pardiso solver for sparse matrix operations (only available on Intel-based systems running Linux or Windows)\n\nThe evaluation of the PTDF matrix can be easily performed starting from importing the system's data and then by simply calling the PTDF method.\n\nusing PowerNetworkMatrices\nusing PowerSystemCaseBuilder\n\nconst PNM = PowerNetworkMatrices\nconst PSB = PowerSystemCaseBuilder\n\nsys = PSB.build_system(PSB.PSITestSystems, \"c_sys5\");\n\nptdf_1 = PTDF(sys);\n\nget_ptdf_data(ptdf_1)\n\nAdvanced users might be interested in computing the PTDF matrix starting from either the data contained in the IncidenceMatrix and BA_matrix structures, or by the information related to the branches and buses of the system.\n\n# evaluate the BA_matrix and Incidence_Matrix\nba_matrix = BA_Matrix(sys);\na_matrix = IncidenceMatrix(sys);\n\n# get the PTDF matrix starting from the values of the\n# previously computed matrices\nptdf_2 = PTDF(a_matrix, ba_matrix);\nget_ptdf_data(ptdf_2)","category":"section"},{"location":"tutorials/tutorial_PTDF_matrix/#Available-methods-for-the-computation-of-the-PTDF-matrix","page":"PTDF matrix","title":"Available methods for the computation of the PTDF matrix","text":"As previously mentioned, the PTDF matrix can be evaluated considering different approaches. The method can be selected by specifying the field linear_solver in the PTDF function.\n\nptdf_dense = PTDF(sys, linear_solver=\"Dense\");\nget_ptdf_data(ptdf_dense)\n\nptdf_klu = PTDF(sys, linear_solver=\"KLU\");\nget_ptdf_data(ptdf_klu)\n\nptdf_mkl = PTDF(sys, linear_solver=\"MKLPardiso\");\nget_ptdf_data(ptdf_mkl)\n\nBy default the \"KLU\" method is selected, which appeared to require significant less time and memory with respect to \"Dense\". Please note that regardless of which method (KLU, Dense, or MKLPardiso) is used, the resulting PTDF matrix is stored as a dense one.\n\nNote on MKLPardiso: The MKLPardiso solver option is only available on Intel-based systems running Linux or Windows. On other platforms (e.g., ARM-based systems or macOS), use KLU or Dense instead.","category":"section"},{"location":"tutorials/tutorial_PTDF_matrix/#Evaluating-the-PTDF-matrix-considering-distributed-slack-bus","page":"PTDF matrix","title":"Evaluating the PTDF matrix considering distributed slack bus","text":"Whenever needed, the PTDF matrix can be computed with a distributed slack bus. To do so, a vector of type Vector{Float64} needs to be defined, specifying the weights for each bus of the system. These weights identify how the load on the slack bus is redistributed accross the system.\n\n# consider equal distribution accross each bus for this example\nbuscount = length(PSY.get_available_components(PSY.ACBus, sys));\ndist_slack = 1 / buscount * ones(buscount);\ndist_slack_array = dist_slack / sum(dist_slack);\n\nOnce the vector of the weights is defined, the PTDF matrix can be computed by defining the input argument dist_slack (empty array Float64[] by default):\n\nptdf_distr = PTDF(sys, dist_slack=dist_slack_array);\n\nThe difference between a the matrix computed with and without the dist_slack field defined can be seen as follows:\n\n# with no distributed slack bus\nget_ptdf_data(ptdf_klu)\n# with distributed slack bus\nget_ptdf_data(ptdf_distr)","category":"section"},{"location":"tutorials/tutorial_PTDF_matrix/#\"Sparse\"-PTDF-matrix","page":"PTDF matrix","title":"\"Sparse\" PTDF matrix","text":"The PTDF matrix can be computed in a \"sparse\" fashion by defining the input argument tol. If this argument is defined, then elements of the PTDF matrix whose absolute values are below the set threshold are dropped. In addition, the matrix will be stored as a sparse one of type SparseArrays.SparseMatrixCSC{Float64, Int} instead of Matrix{Float64}.\n\nBy considering an \"extreme\" value of 0.2 as tol, the PTDF matrix can be computed as follows:\n\nptdf_sparse = PTDF(sys, tol=0.2);\nget_ptdf_data(ptdf_sparse)\n\nNOTE: 0.2 was used for the purpose of this tutorial. In practice much smaller values are used (e.g., 1e-5).","category":"section"},{"location":"tutorials/tutorial_PTDF_matrix/#Network-Reductions","page":"PTDF matrix","title":"Network Reductions","text":"The PTDF matrix can be computed with network reductions applied to simplify the system topology. Network reductions eliminate certain buses and branches while preserving the electrical characteristics of the network. This can significantly reduce computation time and memory usage for large systems.\n\nTwo types of network reductions are supported:\n\nRadialReduction: Eliminates radial (leaf) buses that have only one connection\nDegreeTwoReduction: Eliminates degree-two buses (buses with exactly two connections) by combining their incident branches\n\nFor detailed information about these reductions, see the RadialReduction tutorial and DegreeTwoReduction tutorial.","category":"section"},{"location":"tutorials/tutorial_PTDF_matrix/#Using-Network-Reductions-with-PTDF","page":"PTDF matrix","title":"Using Network Reductions with PTDF","text":"To apply network reductions, pass a vector of NetworkReduction objects to the network_reductions keyword argument:\n\n# Apply radial reduction\nptdf_radial = PTDF(sys, network_reductions=[RadialReduction()]);\n\n# Apply degree-two reduction\nptdf_degree_two = PTDF(sys, network_reductions=[DegreeTwoReduction()]);\n\n# Combine multiple reductions (order matters - RadialReduction first is recommended)\nptdf_combined = PTDF(sys, network_reductions=[RadialReduction(), DegreeTwoReduction()]);","category":"section"},{"location":"tutorials/tutorial_PTDF_matrix/#Protecting-Specific-Buses-from-Reduction","page":"PTDF matrix","title":"Protecting Specific Buses from Reduction","text":"Both reduction types allow you to specify buses that should not be eliminated using the irreducible_buses parameter:\n\n# Protect specific buses from radial reduction\nreduction = RadialReduction(irreducible_buses=[1, 2])\nptdf_protected = PTDF(sys, network_reductions=[reduction]);","category":"section"},{"location":"tutorials/tutorial_PTDF_matrix/#DegreeTwoReduction-Options","page":"PTDF matrix","title":"DegreeTwoReduction Options","text":"The DegreeTwoReduction has an additional option to control whether buses with reactive power injections are reduced:\n\n# Preserve buses with reactive power injections\nreduction = DegreeTwoReduction(reduce_reactive_power_injectors=false)\nptdf_preserve_reactive = PTDF(sys, network_reductions=[reduction]);","category":"section"},{"location":"tutorials/tutorial_PTDF_matrix/#Accessing-Reduction-Information","page":"PTDF matrix","title":"Accessing Reduction Information","text":"After computing the PTDF matrix with reductions, you can access information about what was reduced:\n\nptdf_reduced = PTDF(sys, network_reductions=[RadialReduction(), DegreeTwoReduction()]);\n\n# Get the reduction data\nreduction_data = get_network_reduction_data(ptdf_reduced)","category":"section"},{"location":"tutorials/tutorial_PTDF_matrix/#Combining-Reductions-with-Other-Options","page":"PTDF matrix","title":"Combining Reductions with Other Options","text":"Network reductions can be combined with other PTDF options like distributed slack and sparsification:\n\nptdf_full_options = PTDF(sys,\n    linear_solver=\"KLU\",\n    dist_slack=dist_slack_array,\n    tol=1e-5,\n    network_reductions=[RadialReduction(), DegreeTwoReduction()]\n);\n\nNOTE: The reference (slack) bus is automatically protected from elimination during reductions.","category":"section"},{"location":"api/internal/#Internal-API","page":"Internal API Reference","title":"Internal API","text":"","category":"section"},{"location":"api/internal/#PowerNetworkMatrices.EquivalentBranch","page":"Internal API Reference","title":"PowerNetworkMatrices.EquivalentBranch","text":"EquivalentBranch\n\nRepresents the equivalent parameters of a network branch for power flow calculations.\n\nFields\n\nequivalent_r::Float64: Equivalent series resistance (p.u.)\nequivalent_x::Float64: Equivalent series reactance (p.u.)\nequivalent_g_from::Float64: Equivalent shunt conductance at the \"from\" bus (p.u.)\nequivalent_b_from::Float64: Equivalent shunt susceptance at the \"from\" bus (p.u.)\nequivalent_g_to::Float64: Equivalent shunt conductance at the \"to\" bus (p.u.)\nequivalent_b_to::Float64: Equivalent shunt susceptance at the \"to\" bus (p.u.)\nequivalent_tap::Float64: Equivalent transformer tap ratio\nequivalent_shift::Float64: Equivalent phase shift angle (radians)\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerNetworkMatrices.PowerNetworkMatrix","page":"Internal API Reference","title":"PowerNetworkMatrices.PowerNetworkMatrix","text":"Type PowerNetworkMatrix gathers all the different types of Matrices considered in this package \n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerNetworkMatrices.PowerNetworkMatrixKey","page":"Internal API Reference","title":"PowerNetworkMatrices.PowerNetworkMatrixKey","text":"Structure to store the keys of a power network matrix\n\nArguments\n\nI<:Tuple:       tuple containing the indices of the matrix\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerNetworkMatrices.PowerNetworkMatrixKeys","page":"Internal API Reference","title":"PowerNetworkMatrices.PowerNetworkMatrixKeys","text":"Structure to store the keys of a power network matrix\n\nArguments\n\nproduct_iter::Base.Iterators.ProductIterator{T} where T <: Tuple:       iterator of the indices of the network power matrix\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerNetworkMatrices.RowCache","page":"Internal API Reference","title":"PowerNetworkMatrices.RowCache","text":"Structure used for saving the rows of the Virtual PTDF and LODF matrix.\n\nArguments\n\ntemp_cache::Dict{Int, Union{Vector{Float64}, SparseArrays.SparseVector{Float64}}}:       Dictionary saving the row of the PTDF/LODF matrix\npersistent_cache_keys::Set{Int}:       Set listing the rows to keep in temp_cache\nmax_cache_size::Int       Defines the maximum allowed cache size (rows*row_size)\nmax_num_keys::Int       Defines the maximum number of keys saved (rows of the matrix)\naccess_order::Vector{Int}:       Vector tracking access order for LRU eviction (most recent at end)\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerNetworkMatrices.RowCache-Tuple{Int64, Set{Int64}, Any}","page":"Internal API Reference","title":"PowerNetworkMatrices.RowCache","text":"RowCache(max_cache_size, persistent_rows, row_size)\n\n\nStructure used for saving the rows of the Virtual PTDF and LODF matrix.\n\nArguments\n\nmax_cache_size::Int       Defines the maximum allowed cache size (rows*row_size).\npersistent_rows::Set{Int}:       Set listing the rows to keep in temp_cache.\nrow_size       Defines the size of the single row to store.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.ThreeWindingTransformerWinding","page":"Internal API Reference","title":"PowerNetworkMatrices.ThreeWindingTransformerWinding","text":"ThreeWindingTransformerWinding{T<:PSY.ThreeWindingTransformer} <: PSY.ACTransmission\n\nInternal object representing a single winding of a three-winding transformer. Do not export.\n\nThis structure is used internally to decompose three-winding transformers into individual winding components for network matrix construction and analysis purposes.\n\nFields\n\ntransformer::T: The parent three-winding transformer object\nwinding_number::Int: The winding number (1, 2, or 3) that this object represents\n\nNote\n\nThis is an internal object and should not be constructed directly by users or added to a system.\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#Base.eachindex-Tuple{VirtualLODF}","page":"Internal API Reference","title":"Base.eachindex","text":"eachindex(vlodf)\n\n\nGives the cartesian indexes of the LODF matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Base.eachindex-Tuple{VirtualPTDF}","page":"Internal API Reference","title":"Base.eachindex","text":"eachindex(vptdf)\n\n\nGives the cartesian indexes of the PTDF matrix (same as the BA one).\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Base.empty!-Tuple{PowerNetworkMatrices.RowCache}","page":"Internal API Reference","title":"Base.empty!","text":"empty!(cache)\n\n\nErases the cache.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Base.getindex-Tuple{PowerNetworkMatrices.RowCache, Int64}","page":"Internal API Reference","title":"Base.getindex","text":"getindex(cache, key)\n\n\nGets the row of the stored matrix in cache.\n\nArguments\n\ncache::RowCache:       cache where the row vector is going to be saved\nkey::Int:       row number (corresponding to the enumerated branch index) related to the row vector.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Base.getindex-Tuple{VirtualLODF, Any, Any}","page":"Internal API Reference","title":"Base.getindex","text":"getindex(vlodf, row, column)\n\n\nGets the value of the element of the LODF matrix given the row and column indices corresponding to the selected and outage branch respectively. If column is a Colon then the entire row is returned.\n\nArguments\n\nvlodf::VirtualLODF:       VirtualLODF struct where to evaluate and store the row values.\nrow:       selected line name\ncolumn:       outage line name. If Colon then get the values of the whole row.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Base.getindex-Tuple{VirtualPTDF, Any, Any}","page":"Internal API Reference","title":"Base.getindex","text":"getindex(vptdf, row, column)\n\n\nGets the value of the element of the PTDF matrix given the row and column indices corresponding to the branch and buses one respectively. If column is a Colon then the entire row is returned.\n\nArguments\n\nvptdf::VirtualPTDF:       VirtualPTDF struct where to evaluate and store the row values.\nrow:       Branch index.\ncolumn:       Bus index. If Colon then get the values of the whole row.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Base.haskey-Tuple{PowerNetworkMatrices.RowCache, Int64}","page":"Internal API Reference","title":"Base.haskey","text":"haskey(cache, key)\n\n\nChecks if key is present as a key of the dictionary in cache\n\nArguments\n\ncache::RowCache:       cache where data is stored.\nkey::Int:       row number (corresponds to the enumerated branch index).\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Base.isempty-Tuple{PowerNetworkMatrices.RowCache}","page":"Internal API Reference","title":"Base.isempty","text":"isempty(cache)\n\n\nCheck if cache is empty.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Base.isempty-Tuple{VirtualLODF}","page":"Internal API Reference","title":"Base.isempty","text":"isempty(vlodf)\n\n\nChecks if the any of the fields of VirtualLODF is empty.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Base.isempty-Tuple{VirtualPTDF}","page":"Internal API Reference","title":"Base.isempty","text":"isempty(vptdf)\n\n\nChecks if the any of the fields of VirtualPTDF is empty.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Base.length-Tuple{PowerNetworkMatrices.RowCache}","page":"Internal API Reference","title":"Base.length","text":"length(cache)\n\n\nShows the number of rows stored in cache\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Base.setindex!-Tuple{VirtualLODF, Any, CartesianIndex}","page":"Internal API Reference","title":"Base.setindex!","text":"setindex!(_, _, _)\n\n\n!!! STILL TO IMPLEMENT !!!\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Base.setindex!-Tuple{VirtualLODF, Any, Vararg{Any}}","page":"Internal API Reference","title":"Base.setindex!","text":"setindex!(_, _, idx)\n\n\n!!! STILL TO IMPLEMENT !!!\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Base.setindex!-Tuple{VirtualPTDF, Any, CartesianIndex}","page":"Internal API Reference","title":"Base.setindex!","text":"setindex!(_, _, _)\n\n\n!!! STILL TO IMPLEMENT !!!\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Base.setindex!-Tuple{VirtualPTDF, Any, Vararg{Any}}","page":"Internal API Reference","title":"Base.setindex!","text":"setindex!(_, _, idx)\n\n\n!!! STILL TO IMPLEMENT !!!\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Base.setindex!-Union{Tuple{T}, Tuple{PowerNetworkMatrices.RowCache{T}, T, Int64}} where T<:Union{SparseArrays.SparseVector{Float64}, Vector{Float64}}","page":"Internal API Reference","title":"Base.setindex!","text":"setindex!(cache, val, key)\n\n\nAllocates vector as row of the matrix saved in cache.\n\nArguments\n\ncache::RowCache:       cache where the row vector is going to be saved\nval::Union{Vector{Float64}, SparseArrays.SparseVector{Float64}}:       vector to be saved\nkey::Int:       row number (corresponding to the enumerated branch index) related to the input row vector\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Base.size-Tuple{VirtualLODF}","page":"Internal API Reference","title":"Base.size","text":"size(vlodf)\n\n\nShows the size of the whole LODF matrix, not the number of rows stored.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Base.size-Tuple{VirtualPTDF}","page":"Internal API Reference","title":"Base.size","text":"size(vptdf)\n\n\nGives the size of the whole PTDF matrix, not the number of rows stored.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices._calculate_LODF_matrix_AppleAccelerate-Tuple{SparseArrays.SparseMatrixCSC{Int8, Int64}, Matrix{Float64}}","page":"Internal API Reference","title":"PowerNetworkMatrices._calculate_LODF_matrix_AppleAccelerate","text":"_calculate_LODF_matrix_AppleAccelerate(a, ptdf)\n\n\nFunction for internal use only.\n\nComputes the LODF matrix by means of AppleAccelerate for sparse matrices.\n\nArguments\n\na::SparseArrays.SparseMatrixCSC{Int8, Int}:       Incidence Matrix\nptdf::Matrix{Float64}:       PTDF matrix\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices._calculate_PTDF_matrix_AppleAccelerate-Tuple{SparseArrays.SparseMatrixCSC{Int8, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Set{Int64}, Vector{Float64}}","page":"Internal API Reference","title":"PowerNetworkMatrices._calculate_PTDF_matrix_AppleAccelerate","text":"_calculate_PTDF_matrix_AppleAccelerate(\n    A,\n    BA,\n    ref_bus_positions,\n    dist_slack\n)\n\n\nFunction for internal use only.\n\nComputes the PTDF matrix by means of AppleAccelerate for sparse matrices.\n\nArguments\n\nA::SparseArrays.SparseMatrixCSC{Int8, Int}:       Incidence Matrix\nBA::SparseArrays.SparseMatrixCSC{Float64, Int}:       BA matrix\nref_bus_positions::Set{Int}:       vector containing the indexes of the reference slack buses.\ndist_slack::Vector{Float64}:       vector containing the weights for the distributed slacks.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices._calculate_PTDF_matrix_DENSE-Tuple{SparseArrays.SparseMatrixCSC{Int8, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Set{Int64}, Vector{Float64}}","page":"Internal API Reference","title":"PowerNetworkMatrices._calculate_PTDF_matrix_DENSE","text":"_calculate_PTDF_matrix_DENSE(\n    A,\n    BA,\n    ref_bus_positions,\n    dist_slack\n)\n\n\nFunction for internal use only.\n\nComputes the PTDF matrix by means of the LAPACK and BLAS functions for dense matrices.\n\nArguments\n\nA::Matrix{Int8}:       Incidence Matrix\nBA::Matrix{T} where {T <: Union{Float32, Float64}}:       BA matrix\nref_bus_positions::Set{Int}:       vector containing the indexes of the reference slack buses.\ndist_slack::Vector{Float64}):       vector containing the weights for the distributed slacks.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices._calculate_PTDF_matrix_KLU-Tuple{SparseArrays.SparseMatrixCSC{Int8, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Set{Int64}, Vector{Float64}}","page":"Internal API Reference","title":"PowerNetworkMatrices._calculate_PTDF_matrix_KLU","text":"_calculate_PTDF_matrix_KLU(\n    A,\n    BA,\n    ref_bus_positions,\n    dist_slack\n)\n\n\nFunction for internal use only.\n\nComputes the PTDF matrix by means of the KLU.LU factorization for sparse matrices.\n\nArguments\n\nA::SparseArrays.SparseMatrixCSC{Int8, Int}:       Incidence Matrix\nBA::SparseArrays.SparseMatrixCSC{Float64, Int}:       BA matrix\nref_bus_positions::Set{Int}:       vector containing the indexes of the reference slack buses.\ndist_slack::Vector{Float64}:       vector containing the weights for the distributed slacks.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices._calculate_PTDF_matrix_MKLPardiso-Tuple{SparseArrays.SparseMatrixCSC{Int8, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Set{Int64}, Vector{Float64}}","page":"Internal API Reference","title":"PowerNetworkMatrices._calculate_PTDF_matrix_MKLPardiso","text":"_calculate_PTDF_matrix_MKLPardiso(\n    A,\n    BA,\n    ref_bus_positions,\n    dist_slack\n)\n\n\nFunction for internal use only.\n\nComputes the PTDF matrix by means of the MKL Pardiso for dense matrices.\n\nArguments\n\nA::SparseArrays.SparseMatrixCSC{Int8, Int}:       Incidence Matrix\nBA::SparseArrays.SparseMatrixCSC{Float64, Int}:       BA matrix\nref_bus_positions::Set{Int}:       vector containing the indexes of the reference slack buses.\ndist_slack::Vector{Float64}:       vector containing the weights for the distributed slacks.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices._get_complete_chain-Tuple{SparseArrays.SparseMatrixCSC, Int64, Set{Int64}, Set{Int64}}","page":"Internal API Reference","title":"PowerNetworkMatrices._get_complete_chain","text":"_get_complete_chain(\n    adj_matrix,\n    start_node,\n    reduced_indices,\n    irreducible_indices\n)\n\n\n_get_complete_chain(adj_matrix::SparseArrays.SparseMatrixCSC, start_node::Int, reduced_indices::Set{Int}, irreducible_indices::Set{Int})\n\nBuild a complete chain of degree-2 nodes starting from a given node.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices._get_degree2_nodes-Tuple{SparseArrays.SparseMatrixCSC, Set{Int64}}","page":"Internal API Reference","title":"PowerNetworkMatrices._get_degree2_nodes","text":"_get_degree2_nodes(adj_matrix, irreducible_indices)\n\n\n_get_degree2_nodes(adj_matrix::SparseArrays.SparseMatrixCSC, irreducible_indices::Set{Int})\n\nReturn all degree-2 nodes in the adjacency matrix, excluding irreducible indices.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices._get_equivalent_physical_branch_parameters-Tuple{Matrix{ComplexF32}}","page":"Internal API Reference","title":"PowerNetworkMatrices._get_equivalent_physical_branch_parameters","text":"_get_equivalent_physical_branch_parameters(equivalent_ybus)\n\n\nget_equivalent_physical_branch_parameters(equivalent_ybus::Matrix{ComplexF32})\n\nTakes as input a 2x2 Matrix{ComplexF32} representing the Ybus contribution of either a BranchesParallel or BranchesSeries object. Returns a dictionary of equivalent parameters, matching the PowerModels data format.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices._get_neighbors-Tuple{SparseArrays.SparseMatrixCSC, Int64}","page":"Internal API Reference","title":"PowerNetworkMatrices._get_neighbors","text":"_get_neighbors(adj_matrix, node)\n\n\n_get_neighbors(adj_matrix::SparseArrays.SparseMatrixCSC, node::Int)\n\nGet all neighbors of a given node from the adjacency matrix. For undirected graphs, checks both directions.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices._get_partial_chain_recursive!-Tuple{Vector{Int64}, SparseArrays.SparseMatrixCSC, Int64, Int64, Set{Int64}, Set{Int64}}","page":"Internal API Reference","title":"PowerNetworkMatrices._get_partial_chain_recursive!","text":"_get_partial_chain_recursive!(\n    current_chain,\n    adj_matrix,\n    current_node,\n    prev_node,\n    reduced_indices,\n    irreducible_indices\n)\n\n\n_get_partial_chain(adj_matrix::SparseArrays.SparseMatrixCSC,\n                  current_node::Int,\n                  prev_node::Int,\n                  reduced_indices::Set{Int},\n                  irreducible_indices::Set{Int})\n\nRecursively build a chain in one direction from currentnode, avoiding prevnode.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices._is_2degree_node-Tuple{SparseArrays.SparseMatrixCSC, Int64}","page":"Internal API Reference","title":"PowerNetworkMatrices._is_2degree_node","text":"_is_2degree_node(adj_matrix, node)\n\n\n_is_2degree_node(adj_matrix::SparseArrays.SparseMatrixCSC, node::Int)\n\nChecks if a node has exactly two connections in the network.\n\nArguments\n\nadj_matrix::SparseArrays.SparseMatrixCSC: The adjacency matrix of the network.\nnode::Int: The index of the node to check.\n\nReturns\n\nBool: true if the node has exactly two neighbors, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices._is_final_node-Tuple{Int64, SparseArrays.SparseMatrixCSC, Set{Int64}, Set{Int64}}","page":"Internal API Reference","title":"PowerNetworkMatrices._is_final_node","text":"_is_final_node(\n    node,\n    adj_matrix,\n    reduced_indices,\n    irreducible_indices\n)\n\n\n_is_final_node(node::Int, adj_matrix::SparseArrays.SparseMatrixCSC, reduced_indices::Set{Int})\n\nDetermines if a node is a final node in a path traversal.\n\nArguments\n\nnode::Int: The index of the node to check.\nadj_matrix::SparseArrays.SparseMatrixCSC: The adjacency matrix of the network.\nreduced_indices::Set{Int}: Set of indices that have already been reduced.\nirreducible_indices::Set{Int}: Set of indices that should not be reduced.\n\nReturns\n\nBool: true if the node is a final node, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices._should_visit_node-Tuple{Int64, Set{Int64}, Set{Int64}}","page":"Internal API Reference","title":"PowerNetworkMatrices._should_visit_node","text":"_should_visit_node(\n    node,\n    reduced_indices,\n    irreducible_indices\n)\n\n\n_should_visit_node(node::Int, reduced_indices::Set{Int}, irreducible_indices::Set{Int})\n\nDetermines whether a node should be visited during network traversal.\n\nArguments\n\nnode::Int: The index of the node to check.\nreduced_indices::Set{Int}: Set of indices that have already been reduced.\nirreducible_indices::Set{Int}: Set of indices that cannot be reduced.\n\nReturns\n\nBool: true if the node should be visited, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices._ybus!-Tuple{Vector{ComplexF32}, Vector{ComplexF32}, Vector{ComplexF32}, Vector{ComplexF32}, PowerSystems.ACTransmission, Dict{Int64, Int64}, Int64, Vector{Int64}, Vector{Int64}, NetworkReductionData, SparseArrays.SparseMatrixCSC{Int8, Int64}}","page":"Internal API Reference","title":"PowerNetworkMatrices._ybus!","text":"_ybus!(\n    y11,\n    y12,\n    y21,\n    y22,\n    br,\n    num_bus,\n    branch_ix,\n    fb,\n    tb,\n    nr,\n    adj\n)\n\n\nHandles ybus entries for most 2-node AC branches. The types handled here are: Line, DiscreteControlledACBranch, Transformer2W, TapTransformer, and PhaseShiftingTransformer.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.add_branch_entries_to_indexing_maps!-Tuple{Dict{Int64, Int64}, Int64, NetworkReductionData, Vector{Int64}, Vector{Int64}, SparseArrays.SparseMatrixCSC{Int8, Int64}, PowerSystems.ACTransmission}","page":"Internal API Reference","title":"PowerNetworkMatrices.add_branch_entries_to_indexing_maps!","text":"add_branch_entries_to_indexing_maps!(\n    num_bus,\n    branch_ix,\n    nr,\n    fb,\n    tb,\n    adj,\n    br\n)\n\n\nadd_branch_entries_to_indexing_maps!(\n    num_bus::Dict{Int, Int},\n    branch_ix::Int,\n    nr::NetworkReductionData,\n    fb::Vector{Int},\n    tb::Vector{Int},\n    adj::SparseArrays.SparseMatrixCSC{Int8, Int},\n    br::PSY.ACTransmission\n)\n\nUpdate indexing structures when adding an AC transmission branch to the Y-bus.\n\nThis function handles the bookkeeping required when adding a branch: updates network reduction mappings, sets adjacency matrix entries, and records from/to bus indices for the branch in the Y-bus construction vectors.\n\nArguments\n\nnum_bus::Dict{Int, Int}: Mapping from bus numbers to matrix indices\nbranch_ix::Int: Branch index in the vectors\nnr::NetworkReductionData: Network reduction data to update\nfb::Vector{Int}: Vector of from-bus indices\ntb::Vector{Int}: Vector of to-bus indices\nadj::SparseArrays.SparseMatrixCSC{Int8, Int}: Adjacency matrix\nbr::PSY.ACTransmission: AC transmission branch to add\n\nImplementation Details\n\nCalls add_to_branch_maps!() to update reduction mappings\nUpdates adjacency matrix with branch connectivity\nRecords bus indices in from/to vectors for sparse matrix construction\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.add_branch_entries_to_ybus!-Tuple{Vector{ComplexF32}, Vector{ComplexF32}, Vector{ComplexF32}, Vector{ComplexF32}, Int64, PowerSystems.ACTransmission}","page":"Internal API Reference","title":"PowerNetworkMatrices.add_branch_entries_to_ybus!","text":"add_branch_entries_to_ybus!(\n    y11,\n    y12,\n    y21,\n    y22,\n    branch_ix,\n    br\n)\n\n\nadd_branch_entries_to_ybus!(\n    y11::Vector{ComplexF32},\n    y12::Vector{ComplexF32},\n    y21::Vector{ComplexF32},\n    y22::Vector{ComplexF32},\n    branch_ix::Int,\n    br::PSY.ACTransmission\n)\n\nAdd Y-bus matrix entries for an AC transmission branch to the admittance vectors.\n\nThis function calculates the 2×2 Y-bus entries for a branch using ybus_branch_entries() and stores them in the provided vectors at the specified index. The entries represent the Pi-model admittances: Y11 (from-bus self), Y12 (from-to mutual), Y21 (to-from mutual), and Y22 (to-bus self).\n\nArguments\n\ny11::Vector{ComplexF32}: Vector for from-bus self admittances\ny12::Vector{ComplexF32}: Vector for from-to mutual admittances\ny21::Vector{ComplexF32}: Vector for to-from mutual admittances\ny22::Vector{ComplexF32}: Vector for to-bus self admittances\nbranch_ix::Int: Index where to store the branch entries\nbr::PSY.ACTransmission: AC transmission branch\n\nImplementation Details\n\nCalls ybus_branch_entries() to compute Pi-model parameters\nStores results directly in the provided vectors\nUsed during Y-bus matrix assembly process\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.add_segment_to_ybus!-Tuple{PowerNetworkMatrices.BranchesParallel, Vector{ComplexF32}, Vector{ComplexF32}, Vector{ComplexF32}, Vector{ComplexF32}, Vector{Int64}, Vector{Int64}, Int64, Symbol}","page":"Internal API Reference","title":"PowerNetworkMatrices.add_segment_to_ybus!","text":"add_segment_to_ybus!(\n    segment,\n    y11,\n    y12,\n    y21,\n    y22,\n    fb,\n    tb,\n    ix,\n    segment_orientation\n)\n\n\nadd_segment_to_ybus!(\n    segment::BranchesParallel,\n    y11::Vector{ComplexF32},\n    y12::Vector{ComplexF32},\n    y21::Vector{ComplexF32},\n    y22::Vector{ComplexF32},\n    fb::Vector{Int},\n    tb::Vector{Int},\n    ix::Int,\n    segment_orientation::Symbol\n)\n\nAdd multiple parallel branches as a single segment to Y-bus vectors.\n\nHandles the case where a segment in a series chain consists of multiple parallel branches between the same pair of buses. Each branch in the set is added to the same Y-bus position, effectively combining their admittances.\n\nArguments\n\nsegment::BranchesParallel: Set of parallel AC transmission branches\ny11::Vector{ComplexF32}: Vector for from-bus self admittances\ny12::Vector{ComplexF32}: Vector for from-to mutual admittances\ny21::Vector{ComplexF32}: Vector for to-from mutual admittances\ny22::Vector{ComplexF32}: Vector for to-bus self admittances\nfb::Vector{Int}: Vector for from-bus indices\ntb::Vector{Int}: Vector for to-bus indices\nix::Int: Index position for the segment\nsegment_orientation::Symbol: :FromTo or :ToFrom orientation\n\nImplementation Details\n\nIterates through all branches in the parallel set\nCalls single-branch add_segment_to_ybus!() for each branch\nY-bus entries are accumulated at the same index position\nResults in equivalent admittance of parallel combination\n\nSee Also\n\nadd_segment_to_ybus!: Single branch variant\nDegreeTwoReduction: Series chain elimination\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.add_segment_to_ybus!-Tuple{PowerSystems.ACTransmission, Vector{ComplexF32}, Vector{ComplexF32}, Vector{ComplexF32}, Vector{ComplexF32}, Vector{Int64}, Vector{Int64}, Int64, Symbol}","page":"Internal API Reference","title":"PowerNetworkMatrices.add_segment_to_ybus!","text":"add_segment_to_ybus!(\n    segment,\n    y11,\n    y12,\n    y21,\n    y22,\n    fb,\n    tb,\n    ix,\n    segment_orientation\n)\n\n\nadd_segment_to_ybus!(\n    segment::PSY.ACTransmission\n    y11::Vector{ComplexF32},\n    y12::Vector{ComplexF32},\n    y21::Vector{ComplexF32},\n    y22::Vector{ComplexF32},\n    fb::Vector{Int},\n    tb::Vector{Int},\n    ix::Int,\n    segment_orientation::Symbol\n)\n\nAdd a branch segment to Y-bus vectors during series chain reduction.\n\nAdds the Y-bus entries for a single segment (branch or transformer winding) to the admittance vectors, handling the proper orientation. Used when building equivalent Y-bus entries for series chains of degree-two buses.\n\nArguments\n\nsegment::Union{PSY.ACTransmission, Tuple{PSY.ThreeWindingTransformer, Int}}: Branch segment to add\ny11::Vector{ComplexF32}: Vector for from-bus self admittances\ny12::Vector{ComplexF32}: Vector for from-to mutual admittances\ny21::Vector{ComplexF32}: Vector for to-from mutual admittances\ny22::Vector{ComplexF32}: Vector for to-bus self admittances\nfb::Vector{Int}: Vector for from-bus indices\ntb::Vector{Int}: Vector for to-bus indices\nix::Int: Index position for the segment\nsegment_orientation::Symbol: :FromTo or :ToFrom orientation\n\nImplementation Details\n\nComputes Pi-model entries using ybus_branch_entries()\nHandles orientation by swapping entries for :ToFrom\nSets bus indices to consecutive values (ix, ix+1) for chain building\nUsed in degree-two network reduction algorithms\n\nSee Also\n\nDegreeTwoReduction: Degree-two bus elimination\nybus_branch_entries: Pi-model computation\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.add_to_branch_maps!-Tuple{NetworkReductionData, PowerSystems.Arc, PowerSystems.Arc, PowerSystems.Arc, PowerSystems.ThreeWindingTransformer}","page":"Internal API Reference","title":"PowerNetworkMatrices.add_to_branch_maps!","text":"add_to_branch_maps!(\n    nr,\n    primary_star_arc,\n    secondary_star_arc,\n    tertiary_star_arc,\n    br\n)\n\n\nadd_to_branch_maps!(\n    nr::NetworkReductionData,\n    primary_star_arc::PSY.Arc,\n    secondary_star_arc::PSY.Arc,\n    tertiary_star_arc::PSY.Arc,\n    br::PSY.ThreeWindingTransformer\n)\n\nAdd a three-winding transformer to the transformer mapping in NetworkReductionData.\n\nThree-winding transformers are modeled using a star (wye) configuration with three arcs connecting to a virtual star bus. Each available winding is mapped separately.\n\nArguments\n\nnr::NetworkReductionData: Network reduction data to modify\nprimary_star_arc::PSY.Arc: Arc for primary winding\nsecondary_star_arc::PSY.Arc: Arc for secondary winding\ntertiary_star_arc::PSY.Arc: Arc for tertiary winding\nbr::PSY.ThreeWindingTransformer: Three-winding transformer to add\n\nImplementation Details\n\nOnly adds arcs for available windings (checked via PSY.getavailable*)\nMaintains transformer3Wmap and reversetransformer3W_map\nEach winding is numbered (1=primary, 2=secondary, 3=tertiary)\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.add_to_branch_maps!-Union{Tuple{T}, Tuple{NetworkReductionData, PowerSystems.Arc, T}} where T<:PowerSystems.ACTransmission","page":"Internal API Reference","title":"PowerNetworkMatrices.add_to_branch_maps!","text":"add_to_branch_maps!(nr, arc, br)\n\n\nadd_to_branch_maps!(nr::NetworkReductionData, arc::PSY.Arc, br::PSY.ACTransmission)\n\nAdd an AC transmission branch to the appropriate branch mapping in NetworkReductionData.\n\nThis function categorizes branches as direct (one-to-one), parallel (multiple branches between same buses), or creates new mappings as needed. It maintains both forward and reverse lookup dictionaries for efficient access.\n\nArguments\n\nnr::NetworkReductionData: Network reduction data to modify\narc::PSY.Arc: Arc representing the branch connection\nbr::PSY.ACTransmission: AC transmission branch to add\n\nImplementation Details\n\nIf arc already has a direct branch, converts to parallel mapping\nIf arc already has parallel branches, adds to existing set\nOtherwise creates new direct mapping\nMaintains reverse lookup consistency\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.assign_reference_buses!-Tuple{Dict{Int64, Set{Int64}}, Set{Int64}}","page":"Internal API Reference","title":"PowerNetworkMatrices.assign_reference_buses!","text":"assign_reference_buses!(subnetworks, ref_buses)\n\n\nTakes the reference bus numbers and re-assigns the keys in the subnetwork dictionaries to use the reference bus withing each subnetwork.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.build_reduced_ybus-Tuple{Ybus, PowerSystems.System, NetworkReduction}","page":"Internal API Reference","title":"PowerNetworkMatrices.build_reduced_ybus","text":"build_reduced_ybus(ybus, sys, network_reduction)\n\n\nbuild_reduced_ybus(\n    ybus::Ybus,\n    sys::PSY.System,\n    network_reduction::NetworkReduction\n) -> Ybus\n\nApply a network reduction algorithm to a Y-bus matrix.\n\nComputes the network reduction data using the specified reduction algorithm and then applies the reduction to create a new Y-bus matrix with eliminated buses and branches. The electrical behavior of the remaining network is preserved.\n\nArguments\n\nybus::Ybus: Original Y-bus matrix to reduce\nsys::PSY.System: Power system for validation and data access\nnetwork_reduction::NetworkReduction: Reduction algorithm to apply\n\nReturns\n\nYbus: New reduced Y-bus matrix with eliminated elements\n\nImplementation Details\n\nCalls get_reduction() to compute elimination data\nApplies reduction via _apply_reduction()\nPreserves electrical equivalence of remaining network\nUpdates all indexing and mapping structures\n\nExamples\n\nybus = Ybus(system)\nreduction = RadialReduction()\nreduced_ybus = build_reduced_ybus(ybus, system, reduction)\nprintln(\"Original buses: \", length(get_bus_axis(ybus)))\nprintln(\"Reduced buses: \", length(get_bus_axis(reduced_ybus)))\n\nSee Also\n\nNetworkReduction: Reduction algorithm types\nget_reduction: Reduction data computation\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.calculate_ABA_matrix-Tuple{SparseArrays.SparseMatrixCSC{Int8, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Set{Int64}}","page":"Internal API Reference","title":"PowerNetworkMatrices.calculate_ABA_matrix","text":"calculate_ABA_matrix(A, BA, ref_bus_positions)\n\n\nEvaluates the ABA matrix given the System's Incidence matrix (A), BA matrix and reference bus positions.\n\nArguments\n\nA::SparseArrays.SparseMatrixCSC{Int8, Int}:       Incidence matrix.\nBA::SparseArrays.SparseMatrixCSC{Float64, Int}       BA matrix.\n\nNOTE:\n\nevaluates A with \"calculateAmatrix\", or extract A.data (if A::IncidenceMatrix)\nevaluates BA with \"calculateBAmatrix\", or extract BA.data (if A::BA_Matrix)\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.calculate_radial_arcs-Tuple{SparseArrays.SparseMatrixCSC{Int8, Int64}, Dict{Tuple{Int64, Int64}, Int64}, Dict{Int64, Int64}, Set{Int64}}","page":"Internal API Reference","title":"PowerNetworkMatrices.calculate_radial_arcs","text":"calculate_radial_arcs(\n    A,\n    arc_map,\n    bus_map,\n    ref_bus_positions\n)\n\n\ncalculate_radial_arcs(A::SparseArrays.SparseMatrixCSC{Int8, Int}, arc_map::Dict{Tuple{Int, Int}, Int}, bus_map::Dict{Int, Int}, ref_bus_positions::Set{Int})\n\nIdentify and calculate radial branches and buses that can be eliminated from the network model by analyzing the topological structure of the incidence matrix. Radial elements are leaf nodes with only one connection that do not affect the electrical behavior of the core network.\n\nArguments\n\nA::SparseArrays.SparseMatrixCSC{Int8, Int}:       The incidence matrix data representing bus-branch connectivity structure\narc_map::Dict{Tuple{Int, Int}, Int}:       Dictionary mapping branch endpoint pairs (frombus, tobus) to matrix row indices\nbus_map::Dict{Int, Int}:       Dictionary mapping bus numbers to matrix column indices\nref_bus_positions::Set{Int}:       Set of matrix column indices corresponding to reference (slack) buses that cannot be eliminated\n\nReturns\n\nbus_reduction_map::Dict{Int, Set{Int}}:       Dictionary mapping parent bus numbers to sets of child buses that can be reduced to the parent\nreverse_bus_search_map::Dict{Int, Int}:       Dictionary mapping each bus number to its ultimate parent bus after all reductions\nradial_arcs::Set{Tuple{Int, Int}}:       Set of branch endpoint pairs representing radial branches that can be eliminated\n\nAlgorithm Overview\n\nLeaf Detection: Identifies buses with exactly one connection (radial buses)\nReference Protection: Preserves reference buses from elimination regardless of connectivity\nUpstream Tracing: Traces from radial buses toward the core network to find parent buses\nCascading Reduction: Recursively eliminates buses that become radial after initial reductions\nParallel Processing: Uses multithreading for efficient analysis of large networks\n\nNetwork Topology Preservation\n\nElectrical Equivalence: Ensures reduced network maintains same electrical behavior\nConnectivity Integrity: Preserves essential network connectivity and reference structure\nReduction Validity: Only eliminates elements that truly don't affect network analysis\nReversibility: Maintains mapping information for potential reconstruction if needed\n\nUse Cases\n\nNetwork Simplification: Reduces computational burden by eliminating unnecessary elements\nMatrix Conditioning: Improves numerical properties of network matrices\nAnalysis Acceleration: Speeds up power flow and other network computations\nMemory Optimization: Reduces storage requirements for large network models\n\nImplementation Notes\n\nUses sparse matrix operations for efficiency with large, sparse networks\nHandles edge cases like fully radial networks and isolated islands\nMaintains thread safety for concurrent processing of network analysis\nProvides comprehensive mapping for traceability and debugging\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.check_cache_size!-Tuple{PowerNetworkMatrices.RowCache}","page":"Internal API Reference","title":"PowerNetworkMatrices.check_cache_size!","text":"check_cache_size!(cache; new_add)\n\n\nCheck saved rows in cache and delete one not belonging to persistent_cache_keys.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.find_degree2_chains-Tuple{SparseArrays.SparseMatrixCSC, Set{Int64}}","page":"Internal API Reference","title":"PowerNetworkMatrices.find_degree2_chains","text":"find_degree2_chains(adj_matrix, irreducible_indices)\n\n\nfind_degree2_chains(adj_matrix::SparseArrays.SparseMatrixCSC, irreducible_indices::Set{Int})\n\nFind all chains of degree-2 nodes in a graph represented by a CSC adjacency matrix. A chain is a sequence of connected degree-2 nodes.\n\nReturns a dictionary mapping each starting node to its chain of node indices.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.find_slack_positions-Tuple{Any}","page":"Internal API Reference","title":"PowerNetworkMatrices.find_slack_positions","text":"find_slack_positions(buses)\n\n\nGets the indices  of the reference (slack) buses. NOTE:\n\nthe indices  corresponds to the columns of zeros belonging to the PTDF matrix.\nBA and ABA matrix miss the columns related to the reference buses.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.get_ac_transmission_types-Tuple{NetworkReductionData}","page":"Internal API Reference","title":"PowerNetworkMatrices.get_ac_transmission_types","text":"get_ac_transmission_types(network_reduction_data)\n\n\ngetactransmissiontypes(networkreduction_data::NetworkReductionData)\n\nGets the concrete types of all AC transmission branches included in an instance of NetworkReductionData\n\nArguments\n\nnetwork_reduction_data::NetworkReductionData\n\nReturns\n\nSet{DataType}: Vector of the retained branch types.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.get_arc_axis-Tuple{NetworkReductionData}","page":"Internal API Reference","title":"PowerNetworkMatrices.get_arc_axis","text":"get_arc_axis(nr)\n\n\nInterface to obtain the arc axis based on the network reduction data\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.get_arc_axis-Tuple{Vector{Int64}, Vector{Int64}, Vector{Int64}}","page":"Internal API Reference","title":"PowerNetworkMatrices.get_arc_axis","text":"get_arc_axis(fb, tb, bus_axis)\n\n\nget_arc_axis(fb::Vector{Int}, tb::Vector{Int}, bus_axis::Vector{Int}) -> Vector{Tuple{Int, Int}}\n\nGenerate unique arc axis from from-bus and to-bus index vectors.\n\nCreates a vector of unique (frombus, tobus) tuples representing the arcs (branches) in the system. Used for constructing arc admittance matrices and organizing network topology data.\n\nArguments\n\nfb::Vector{Int}: Vector of from-bus indices into bus_axis\ntb::Vector{Int}: Vector of to-bus indices into bus_axis\nbus_axis::Vector{Int}: Vector of bus numbers\n\nReturns\n\nVector{Tuple{Int, Int}}: Unique arcs as (frombusnumber, tobusnumber) tuples\n\nExamples\n\nfb = [1, 2, 1]  # indices into bus_axis\ntb = [2, 3, 3]  # indices into bus_axis\nbus_axis = [101, 102, 103]  # bus numbers\narcs = get_arc_axis(fb, tb, bus_axis)\n# Returns: [(101, 102), (102, 103), (101, 103)]\n\nImplementation Details\n\nMaps indices to actual bus numbers using bus_axis\nRemoves duplicates with unique()\nPreserves arc direction (from → to)\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.get_data-Tuple{PowerNetworkMatrices.PowerNetworkMatrix}","page":"Internal API Reference","title":"PowerNetworkMatrices.get_data","text":"get_data(mat)\n\n\nreturns the raw array data of the PowerNetworkMatrix\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.get_default_reduction-Tuple{PowerSystems.System}","page":"Internal API Reference","title":"PowerNetworkMatrices.get_default_reduction","text":"get_default_reduction(sys)\n\n\nget_default_reduction(sys::PSY.System) -> NetworkReductionData\n\nBuild a Y-bus matrix from the system and return its default network reduction data.\n\nThis function constructs a Y-bus matrix with no network reductions applied and returns the resulting NetworkReductionData, which contains the basic bus and branch mappings for the system without any reduction algorithms.\n\nArguments\n\nsys::PSY.System: Power system to analyze\n\nReturns\n\nNetworkReductionData: Default network reduction data with basic system mappings\n\nExamples\n\nsystem = System(\"system.json\")\nreduction_data = get_default_reduction(system)\nprintln(\"Number of buses: \", length(get_bus_reduction_map(reduction_data)))\n\nSee Also\n\nYbus: Y-bus matrix construction\nNetworkReductionData: Network reduction data structure\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.get_equivalent_available-Tuple{PowerNetworkMatrices.BranchesParallel}","page":"Internal API Reference","title":"PowerNetworkMatrices.get_equivalent_available","text":"get_equivalent_available(bp)\n\n\nget_equivalent_available(bp::BranchesParallel)\n\nGet the availability status for parallel branches. All branches in parallel must be available for the parallel circuit to be available.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.get_equivalent_available-Tuple{PowerNetworkMatrices.BranchesSeries}","page":"Internal API Reference","title":"PowerNetworkMatrices.get_equivalent_available","text":"get_equivalent_available(bs)\n\n\nget_equivalent_available(bs::BranchesSeries)\n\nGet the availability status for series branches. All branches in series must be available for the series circuit to be available.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.get_equivalent_available-Tuple{PowerNetworkMatrices.ThreeWindingTransformerWinding}","page":"Internal API Reference","title":"PowerNetworkMatrices.get_equivalent_available","text":"get_equivalent_available(tw)\n\n\nget_equivalent_available(tw::ThreeWindingTransformerWinding)\n\nGet the availability status for a specific winding of a three-winding transformer. Returns the availability status of the parent transformer.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.get_equivalent_b-Tuple{PowerNetworkMatrices.ThreeWindingTransformerWinding}","page":"Internal API Reference","title":"PowerNetworkMatrices.get_equivalent_b","text":"get_equivalent_b(tw)\n\n\nget_equivalent_b(tw::ThreeWindingTransformerWinding)\n\nGet the susceptance for a specific winding of a three-winding transformer. For the primary winding (winding 1), returns the shunt susceptance from the transformer. For secondary and tertiary windings, returns 0.0 as the shunt is only on the primary side.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.get_equivalent_r-Tuple{PowerNetworkMatrices.ThreeWindingTransformerWinding}","page":"Internal API Reference","title":"PowerNetworkMatrices.get_equivalent_r","text":"get_equivalent_r(tw)\n\n\nget_equivalent_r(tw::ThreeWindingTransformerWinding)\n\nGet the resistance for a specific winding of a three-winding transformer. Returns the winding-specific series resistance.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.get_equivalent_rating-Tuple{PowerNetworkMatrices.BranchesParallel}","page":"Internal API Reference","title":"PowerNetworkMatrices.get_equivalent_rating","text":"get_equivalent_rating(bp)\n\n\nget_equivalent_rating(bp::BranchesParallel)\n\nCalculate the total rating for branches in parallel. For parallel circuits, the rating is the sum of individual ratings divided by the number of circuits. This provides a conservative estimate that accounts for potential overestimation of total capacity.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.get_equivalent_rating-Tuple{PowerNetworkMatrices.BranchesSeries}","page":"Internal API Reference","title":"PowerNetworkMatrices.get_equivalent_rating","text":"get_equivalent_rating(bs)\n\n\nget_equivalent_rating(bs::BranchesSeries)\n\nCalculate the rating for branches in series. For series circuits, the rating is limited by the weakest link: Rating_total = min(Rating1, Rating2, ..., Ratingn)\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.get_equivalent_rating-Tuple{PowerNetworkMatrices.ThreeWindingTransformerWinding}","page":"Internal API Reference","title":"PowerNetworkMatrices.get_equivalent_rating","text":"get_equivalent_rating(tw)\n\n\nget_equivalent_rating(tw::ThreeWindingTransformerWinding)\n\nGet the rating for a specific winding of a three-winding transformer. Returns the winding-specific rating if non-zero, otherwise returns the parent transformer rating.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.get_equivalent_tap-Tuple{PowerNetworkMatrices.ThreeWindingTransformerWinding{PowerSystems.PhaseShiftingTransformer3W}}","page":"Internal API Reference","title":"PowerNetworkMatrices.get_equivalent_tap","text":"get_equivalent_tap(tw)\n\n\nget_equivalent_tap(tw::ThreeWindingTransformerWinding)\n\nGet the tap (turns ratio) for a specific winding of a three-winding transformer. Returns the winding-specific turns ratio for phase shifting transformers.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.get_equivalent_x-Tuple{PowerNetworkMatrices.ThreeWindingTransformerWinding}","page":"Internal API Reference","title":"PowerNetworkMatrices.get_equivalent_x","text":"get_equivalent_x(tw)\n\n\nget_equivalent_x(tw::ThreeWindingTransformerWinding)\n\nGet the reactance for a specific winding of a three-winding transformer. Returns the winding-specific series reactance.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.get_equivalent_α-Tuple{PowerNetworkMatrices.BranchesParallel}","page":"Internal API Reference","title":"PowerNetworkMatrices.get_equivalent_α","text":"get_equivalent_α(bp)\n\n\nget_equivalent_α(bp::BranchesParallel)\n\nGet the phase angle shift for parallel branches. Returns the average phase angle shift across all parallel branches. Returns 0.0 if branches don't support phase angle shift (e.g., lines).\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.get_equivalent_α-Tuple{PowerNetworkMatrices.BranchesSeries}","page":"Internal API Reference","title":"PowerNetworkMatrices.get_equivalent_α","text":"get_equivalent_α(bs)\n\n\nget_equivalent_α(bs::BranchesSeries)\n\nGet the phase angle shift for series branches. Returns the sum of phase angle shifts across all series branches. Returns 0.0 if branches don't support phase angle shift (e.g., lines).\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.get_equivalent_α-Tuple{PowerNetworkMatrices.ThreeWindingTransformerWinding{PowerSystems.PhaseShiftingTransformer3W}}","page":"Internal API Reference","title":"PowerNetworkMatrices.get_equivalent_α","text":"get_equivalent_α(tw)\n\n\nget_equivalent_α(tw::ThreeWindingTransformerWinding)\n\nGet the phase angle (α) for a specific winding of a three-winding transformer. Returns the winding-specific phase shift angle for phase shifting transformers.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.get_irreducible_indices-Tuple{AdjacencyMatrix, Vector{Int64}}","page":"Internal API Reference","title":"PowerNetworkMatrices.get_irreducible_indices","text":"get_irreducible_indices(A, irreducible_buses)\n\n\nConvert the user input for irreducible_buses to a set of indices based on the Ybus lookup and the prior reductions.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.get_isolated_buses-Tuple{Ybus}","page":"Internal API Reference","title":"PowerNetworkMatrices.get_isolated_buses","text":"get_isolated_buses(M)\n\n\nget_isolated_buses(M::Ybus) -> Vector{Int}\n\nReturn bus numbers that form isolated single-node subnetworks in the Y-bus matrix.\n\nIsolated buses are electrical islands containing only one bus with no connections to other parts of the network. These typically represent buses that were disconnected during network reduction operations or buses with no active branches.\n\nArguments\n\nM::Ybus: Y-bus matrix to analyze\n\nReturns\n\nVector{Int}: Vector of bus numbers that form isolated single-node subnetworks\n\nExamples\n\nybus = Ybus(system)\nisolated = get_isolated_buses(ybus)\nprintln(\"Isolated buses: \", isolated)\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.get_lookup-Tuple{PowerNetworkMatrices.PowerNetworkMatrix}","page":"Internal API Reference","title":"PowerNetworkMatrices.get_lookup","text":"get_lookup(mat)\n\n\nreturns the lookup tuple of the `PowerNetworkMatrix`. The first entry corresponds\nto the first dimension and the second entry corresponds to the second dimension. For\ninstance in Ybus the first dimension is buses and second dimension is buses too, and in\nPTDF the first dimension is branches and the second dimension is buses\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.get_mapped_bus_number-Tuple{NetworkReductionData, Int64}","page":"Internal API Reference","title":"PowerNetworkMatrices.get_mapped_bus_number","text":"get_mapped_bus_number(rb, bus_number)\n\n\nInterface to obtain the parent bus number of a reduced bus when radial branches are eliminated\n\nArguments\n\nrb::NetworkReduction: NetworkReduction object\nbus_number::Int: Bus number of the reduced bus\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.get_mapped_bus_number-Tuple{NetworkReductionData, PowerSystems.ACBus}","page":"Internal API Reference","title":"PowerNetworkMatrices.get_mapped_bus_number","text":"get_mapped_bus_number(rb, bus)\n\n\nInterface to obtain the parent bus number of a reduced bus when radial branches are eliminated\n\nArguments\n\nrb::NetworkReduction: NetworkReduction object\nbus::ACBus: Reduced bus\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.get_reduction-Tuple{Ybus, PowerSystems.System, RadialReduction}","page":"Internal API Reference","title":"PowerNetworkMatrices.get_reduction","text":"get_reduction(ybus, sys, reduction)\n\n\nget_reduction(ybus::Ybus, sys::PSY.System, reduction::RadialReduction) -> NetworkReductionData\n\nApply radial network reduction to a Y-bus matrix.\n\nRadial reduction eliminates radial (dangling) buses that have only one connection. These buses do not affect power flows in the rest of the network and can be safely removed to reduce computational complexity.\n\nArguments\n\nybus::Ybus: Y-bus matrix to reduce\nsys::PSY.System: Power system for validation\nreduction::RadialReduction: Radial reduction configuration\n\nReturns\n\nNetworkReductionData: Reduction data containing eliminated buses and updated mappings\n\nExamples\n\nybus = Ybus(system)\nreduction = RadialReduction(irreducible_buses=[101, 205])\nreduction_data = get_reduction(ybus, system, reduction)\n\nSee Also\n\nRadialReduction: Radial reduction configuration\nget_reduction: Other reduction methods\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.get_representative-Tuple{Vector{Int64}, Int64}","page":"Internal API Reference","title":"PowerNetworkMatrices.get_representative","text":"get_representative(uf, x)\n\n\nFind part of the union-find disjoint set data structure. Vector because nodes are 1:n.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.get_retained_branches_names-Tuple{NetworkReductionData}","page":"Internal API Reference","title":"PowerNetworkMatrices.get_retained_branches_names","text":"get_retained_branches_names(network_reduction_data)\n\n\ngetretainedbranchesnames(networkreduction_data::NetworkReductionData)\n\nGets the branch names that are retained after network reduction. This method only returns the branch names from non-three winding transformer branches that have a one-to-one correspondence with arcs after the reduction. This does not include parallel branches or branches that have been reduced as part of a series chain of degree two nodes.\n\nArguments\n\nnetwork_reduction_data::NetworkReductionData\n\nReturns\n\nVector{String}: Vector of the retained branch names.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.get_tol-Tuple{VirtualLODF}","page":"Internal API Reference","title":"PowerNetworkMatrices.get_tol","text":"get_tol(mat)\n\n\nGets the tolerance used for sparsifying the rows of the VirtualLODF matrix\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.get_tol-Tuple{VirtualPTDF}","page":"Internal API Reference","title":"PowerNetworkMatrices.get_tol","text":"get_tol(vptdf)\n\n\nGets the tolerance used for sparsifying the rows of the VirtualPTDF matrix\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.lookup_index-Tuple{Any, Dict}","page":"Internal API Reference","title":"PowerNetworkMatrices.lookup_index","text":"lookup_index(i, lookup)\n\n\nGets bus indices to a certain branch index\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.lookup_index-Tuple{PowerSystems.ACBus, Dict}","page":"Internal API Reference","title":"PowerNetworkMatrices.lookup_index","text":"lookup_index(i, lookup)\n\n\nGets bus indices to a certain branch name\n\nArguments\n\ni::PSY.ACBranch:       Power System AC branch\nlookup::Dict:       Dictionary mapping branches and buses\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.lookup_index-Tuple{PowerSystems.Arc, Dict}","page":"Internal API Reference","title":"PowerNetworkMatrices.lookup_index","text":"lookup_index(i, lookup)\n\n\nGets bus indices to a certain branch name\n\nArguments\n\ni::PSY.ACBranch:       Power System AC branch\nlookup::Dict:       Dictionary mapping branch and buses\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.make_arc_arc_subnetwork_axes-Tuple{IncidenceMatrix}","page":"Internal API Reference","title":"PowerNetworkMatrices.make_arc_arc_subnetwork_axes","text":"make_arc_arc_subnetwork_axes(A)\n\n\nMake subnetwork axes for LODF and VirtualLODF\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.make_arc_bus_subnetwork_axes-Tuple{Ybus}","page":"Internal API Reference","title":"PowerNetworkMatrices.make_arc_bus_subnetwork_axes","text":"make_arc_bus_subnetwork_axes(ybus)\n\n\nmake_arc_bus_subnetwork_axes(ybus::Ybus) -> Dict{Int, Tuple{Vector{Tuple{Int, Int}}, Vector{Int}}}\n\nCreate subnetwork axes for IncidenceMatrix construction from a Y-bus matrix.\n\nGenerates subnetwork-specific axes with arc-bus ordering needed for constructing incidence matrices. Each subnetwork gets its own arc list and corresponding bus list for matrix indexing.\n\nArguments\n\nybus::Ybus: Y-bus matrix containing subnetwork information\n\nReturns\n\nDict{Int, Tuple{Vector{Tuple{Int, Int}}, Vector{Int}}}: Dictionary mapping reference bus numbers to (arcaxis, busaxis) tuples for each subnetwork\n\nImplementation Details\n\nSwaps order compared to make_bus_arc_subnetwork_axes (arc first, bus second)\nUses same underlying data from ybus.subnetwork_axes and ybus.arc_subnetwork_axis\nUsed for constructing incidence matrices that relate branch connectivity to bus topology\n\nSee Also\n\nIncidenceMatrix: Network incidence matrix\nmake_bus_arc_subnetwork_axes: Bus-Arc variant\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.make_ax_ref-Tuple{AbstractVector{PowerSystems.ACBus}}","page":"Internal API Reference","title":"PowerNetworkMatrices.make_ax_ref","text":"make_ax_ref(buses)\n\n\nEvaluates the map linking the system's buses and branches.\n\nArguments\n\nbuses::AbstractVector{PSY.ACBus}:       system's buses\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.make_ax_ref-Tuple{AbstractVector}","page":"Internal API Reference","title":"PowerNetworkMatrices.make_ax_ref","text":"make_ax_ref(ax)\n\n\nChecks if repetitions are present in the dictionary mapping buses and branches.\n\nArguments\n\nax::AbstractVector:       generic abstract vector\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.make_bus_arc_subnetwork_axes-Tuple{Ybus}","page":"Internal API Reference","title":"PowerNetworkMatrices.make_bus_arc_subnetwork_axes","text":"make_bus_arc_subnetwork_axes(ybus)\n\n\nmake_bus_arc_subnetwork_axes(ybus::Ybus) -> Dict{Int, Tuple{Vector{Int}, Vector{Tuple{Int, Int}}}}\n\nCreate subnetwork axes for BA_Matrix construction from a Y-bus matrix.\n\nGenerates subnetwork-specific axes combining bus and arc information needed for constructing Bus-Arc (BA) matrices. Each subnetwork gets its own bus list and corresponding arc list for matrix indexing.\n\nArguments\n\nybus::Ybus: Y-bus matrix containing subnetwork information\n\nReturns\n\nDict{Int, Tuple{Vector{Int}, Vector{Tuple{Int, Int}}}}: Dictionary mapping reference bus numbers to (busaxis, arcaxis) tuples for each subnetwork\n\nImplementation Details\n\nCombines bus axes from ybus.subnetwork_axes with arc axes from ybus.arc_subnetwork_axis\nMaintains consistency between bus and arc indexing within each electrical island\nUsed for constructing BA matrices that relate bus injections to branch flows\n\nSee Also\n\nBA_Matrix: Bus-Arc matrix construction\nmake_arc_bus_subnetwork_axes: Arc-Bus variant\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.populate_branch_maps_by_type!","page":"Internal API Reference","title":"PowerNetworkMatrices.populate_branch_maps_by_type!","text":"populate_branch_maps_by_type!(nrd)\npopulate_branch_maps_by_type!(nrd, filters)\n\n\npopulate_branch_maps_by_type!(nrd::NetworkReductionData, filters = Dict())\n\nPopulate the branch maps organized by component type within the NetworkReductionData structure.\n\nThis function processes various types of branch mappings (direct, parallel, series, and 3-winding transformers) and organizes them by their component types. It applies optional filters to determine which branches should be included in the type-organized maps.\n\nArguments\n\nnrd::NetworkReductionData: The network reduction data structure to populate\nfilters: Optional dictionary of filters to apply when determining which branches to include (default: empty Dict)\n\nDetails\n\nThe function creates and populates the following map types organized by component type:\n\ndirect_branch_map: Direct branch connections between buses\nreverse_direct_branch_map: Reverse lookup for direct branches\nparallel_branch_map: Parallel branch connections between the same bus pair\nreverse_parallel_branch_map: Reverse lookup for parallel branches\nseries_branch_map: Series branch connections (chains of branches)\nreverse_series_branch_map: Reverse lookup for series branches\ntransformer3W_map: Three-winding transformer connections\nreverse_transformer3W_map: Reverse lookup for three-winding transformers\n\nThe function also populates the name_to_arc_map to provide name-based lookups for branches and stores the applied filters in nrd.filters_applied.\n\nModifies\n\nnrd.all_branch_maps_by_type: Populated with type-organized branch maps\nnrd.name_to_arc_map: Updated with name-to-arc mappings\nnrd.filters_applied: Set to the provided filters\n\nReturns\n\nnothing: This function modifies the input structure in-place\n\n\n\n\n\n","category":"function"},{"location":"api/internal/#PowerNetworkMatrices.purge_one!-Tuple{PowerNetworkMatrices.RowCache}","page":"Internal API Reference","title":"PowerNetworkMatrices.purge_one!","text":"purge_one!(cache)\n\n\nDeletes a row from the stored matrix in cache not belonging to the persistentcachekeys set. Uses LRU (Least Recently Used) eviction strategy based on access_order tracking.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.sparsify-Tuple{Matrix{Float64}, Float64}","page":"Internal API Reference","title":"PowerNetworkMatrices.sparsify","text":"sparsify(dense_array, tol)\n\n\nReturn a sparse matrix given a dense one by dropping elements whose absolute value is below a certain tolerance.\n\nUses optimized droptol! for better performance compared to element-wise iteration.\n\nArguments\n\ndense_array::Matrix{Float64}:       input matrix (e.g., PTDF matrix).\ntol::Float64:       tolerance.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.sparsify-Tuple{Vector{Float64}, Float64}","page":"Internal API Reference","title":"PowerNetworkMatrices.sparsify","text":"sparsify(dense_array, tol)\n\n\nReturn a sparse vector given a dense one by dropping elements whose absolute value is below a certain tolerance.\n\nUses optimized droptol! for better performance compared to element-wise iteration.\n\nArguments\n\ndense_array::Vector{Float64}:       input vector (e.g., PTDF row from VirtualPTDF).\ntol::Float64:       tolerance.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.to_index-Tuple{PowerNetworkMatrices.PowerNetworkMatrix, Vararg{Any}}","page":"Internal API Reference","title":"PowerNetworkMatrices.to_index","text":"to_index(A, idx)\n\n\nGiven the indices, gets the values of the power network matrix considered\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.union_sets!-Tuple{Vector{Int64}, Int64, Int64}","page":"Internal API Reference","title":"PowerNetworkMatrices.union_sets!","text":"union_sets!(uf, x, y)\n\n\nUnion part of the union-find disjoint set data structure. Vector because nodes are 1:n.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.validate_buses-Tuple{AdjacencyMatrix, Vector{Int64}}","page":"Internal API Reference","title":"PowerNetworkMatrices.validate_buses","text":"validate_buses(A, buses)\n\n\nValidates that the user bus input is consistent with the ybus axes and the prior reductions. Is used to check irreducible_buses for Radial and DegreeTwo reductions and study_buses for WardReduction.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.validate_linear_solver-Tuple{String}","page":"Internal API Reference","title":"PowerNetworkMatrices.validate_linear_solver","text":"validate_linear_solver(linear_solver)\n\n\nValidates if the selected linear solver is supported.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.ybus_branch_entries-Tuple{PowerNetworkMatrices.ThreeWindingTransformerWinding}","page":"Internal API Reference","title":"PowerNetworkMatrices.ybus_branch_entries","text":"ybus_branch_entries(tp)\n\n\nYbus branch entries for an arc in the wye model of a ThreeWindingTransformer.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.ybus_branch_entries-Tuple{PowerSystems.ACTransmission}","page":"Internal API Reference","title":"PowerNetworkMatrices.ybus_branch_entries","text":"ybus_branch_entries(br)\n\n\nYbus entries for a Line or a DiscreteControlledACBranch.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerNetworkMatrices.ybus_branch_entries-Tuple{PowerSystems.TwoWindingTransformer}","page":"Internal API Reference","title":"PowerNetworkMatrices.ybus_branch_entries","text":"ybus_branch_entries(br)\n\n\nYbus entries for a Transformer2W, TapTransformer, or PhaseShiftingTransformer.\n\n\n\n\n\n","category":"method"},{"location":"#PowerNetworkMatrices.jl","page":"Welcome Page","title":"PowerNetworkMatrices.jl","text":"","category":"section"},{"location":"#Overview","page":"Welcome Page","title":"Overview","text":"PowerNetworkMatrices.jl is a Julia package for the evaluation of network matrices given the system's data. The package allows to compute the matrices according to different methods, providing a flexible and powerful tool.\n\nThe documentation and code are organized according to the needs of different users depending on their skillset and requirements. In broad terms there are three categories:\n\nModeler: Users that want to run a particular analysis or experiment and use PowerNetworkMatrices.jl to develop data sets.\nModel Developer: Users that want to develop custom components and structs in order to exploit PowerNetworkMatrices.jl features to produce custom data sets.\nCode Base Developers: Users that want to add new core functionalities or fix bugs in the core capabilities of PowerNetworkMatrices.jl.\n\nPowerNetworkMatrices.jl is an active project under development, and we welcome your feedback, suggestions, and bug reports.","category":"section"},{"location":"#Installation","page":"Welcome Page","title":"Installation","text":"The latest stable release of PowerNetworkMatrices can be installed using the Julia package manager with\n\n] add PowerNetworkMatrices\n\nFor the current development version, \"checkout\" this package with\n\n] add PowerNetworkMatrices#main\n\n\n\nPowerNetworkMatrices has been developed as part of the Scalable Integrated Infrastructure Planning (SIIP) initiative at the U.S. Department of Energy's National Renewable Energy Laboratory (NREL).","category":"section"},{"location":"tutorials/tutorial_RadialReduction/#RadialReduction","page":"RadialReduction","title":"RadialReduction","text":"In this tutorial the RadialReduction network reduction algorithm is presented. This reduction eliminates radial (dangling) buses and their associated branches from the power network while preserving the electrical behavior of the core network.\n\nBefore diving into this tutorial we encourage the user to load PowerNetworkMatrices, hit the ? key in the REPL terminal and look for the documentation of RadialReduction.","category":"section"},{"location":"tutorials/tutorial_RadialReduction/#Understanding-Radial-Branches","page":"RadialReduction","title":"Understanding Radial Branches","text":"Radial buses are leaf nodes in the network topology with only one connection. These buses do not affect the electrical behavior of the rest of the network and can be safely eliminated to simplify network matrices and improve computational efficiency.","category":"section"},{"location":"tutorials/tutorial_RadialReduction/#Basic-Usage-of-RadialReduction","page":"RadialReduction","title":"Basic Usage of RadialReduction","text":"The RadialReduction can be applied when constructing various network matrices. The most common use case is with the Ybus matrix:\n\nusing PowerNetworkMatrices\nusing PowerSystemCaseBuilder\n\nconst PNM = PowerNetworkMatrices\nconst PSB = PowerSystemCaseBuilder\n\n# Load a test system\nsys = PSB.build_system(PSB.PSITestSystems, \"c_sys14\");\n\n# Create Ybus with radial reduction\nybus = Ybus(sys; network_reductions=[RadialReduction()]);","category":"section"},{"location":"tutorials/tutorial_RadialReduction/#Accessing-Reduction-Information","page":"RadialReduction","title":"Accessing Reduction Information","text":"After applying the reduction, you can access information about which buses and branches were eliminated:\n\n# Get the network reduction data\nreduction_data = get_network_reduction_data(ybus);\n\n# View the bus reduction mapping\n# This shows which buses were reduced to which parent buses\nget_bus_reduction_map(reduction_data)\n\n# View the reverse bus search mapping\n# This maps each reduced bus to its ultimate parent\nget_reverse_bus_search_map(reduction_data)\n\n# View the removed arcs (branches)\nget_removed_arcs(reduction_data)","category":"section"},{"location":"tutorials/tutorial_RadialReduction/#Protecting-Specific-Buses-from-Reduction","page":"RadialReduction","title":"Protecting Specific Buses from Reduction","text":"In some cases, you may want to preserve certain buses even if they are radial. This can be done using the irreducible_buses parameter:\n\n# Create radial reduction that protects buses 101 and 205\nreduction = RadialReduction(irreducible_buses=[101, 205]);\n\n# Apply to system (if these buses exist in the system)\n# ybus_protected = Ybus(sys; network_reductions=[reduction]);","category":"section"},{"location":"tutorials/tutorial_RadialReduction/#Combining-with-Other-Network-Matrices","page":"RadialReduction","title":"Combining with Other Network Matrices","text":"The RadialReduction can be applied to other network matrix types as well:\n\n# Apply to PTDF matrix\nptdf = PTDF(sys; network_reductions=[RadialReduction()]);\n\n# Apply to LODF matrix\nlodf = LODF(sys; network_reductions=[RadialReduction()]);\n\n# Apply to Incidence Matrix\nincidence = IncidenceMatrix(sys; network_reductions=[RadialReduction()]);","category":"section"},{"location":"tutorials/tutorial_RadialReduction/#Benefits-of-Radial-Reduction","page":"RadialReduction","title":"Benefits of Radial Reduction","text":"Using RadialReduction provides several advantages:\n\nSmaller Matrices: Eliminates unnecessary rows and columns from network matrices\nFaster Computations: Reduced matrix dimensions lead to faster linear algebra operations\nBetter Conditioning: Removing radial elements can improve numerical properties\nMemory Efficiency: Reduces storage requirements for large network models","category":"section"},{"location":"tutorials/tutorial_RadialReduction/#Example:-Comparing-Matrix-Sizes","page":"RadialReduction","title":"Example: Comparing Matrix Sizes","text":"# Create Ybus without reduction\nybus_full = Ybus(sys);\n\n# Create Ybus with radial reduction\nybus_reduced = Ybus(sys; network_reductions=[RadialReduction()]);\n\n# Compare sizes\nsize(ybus_full)\nsize(ybus_reduced)","category":"section"},{"location":"tutorials/tutorial_RadialReduction/#Combining-Multiple-Reductions","page":"RadialReduction","title":"Combining Multiple Reductions","text":"RadialReduction can be combined with other network reduction algorithms like DegreeTwoReduction:\n\n# Apply both radial and degree-two reductions\nreductions = [RadialReduction(), DegreeTwoReduction()];\nybus_multi = Ybus(sys; network_reductions=reductions);","category":"section"},{"location":"tutorials/tutorial_RadialReduction/#Important-Notes","page":"RadialReduction","title":"Important Notes","text":"Reference Bus Protection: Reference (slack) buses are automatically protected from elimination, regardless of their connectivity\nOrder Matters: When combining multiple reductions, they are applied in the order specified in the vector\nReversibility: The reduction maintains mapping information (bus_reduction_map and reverse_bus_search_map) that can be used for result interpretation\nElectrical Equivalence: The reduced network maintains the same electrical behavior as the original network for all non-eliminated elements","category":"section"}]
}
